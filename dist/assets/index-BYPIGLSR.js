(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const o of document.querySelectorAll('link[rel="modulepreload"]'))r(o);new MutationObserver(o=>{for(const a of o)if(a.type==="childList")for(const u of a.addedNodes)u.tagName==="LINK"&&u.rel==="modulepreload"&&r(u)}).observe(document,{childList:!0,subtree:!0});function t(o){const a={};return o.integrity&&(a.integrity=o.integrity),o.referrerPolicy&&(a.referrerPolicy=o.referrerPolicy),o.crossOrigin==="use-credentials"?a.credentials="include":o.crossOrigin==="anonymous"?a.credentials="omit":a.credentials="same-origin",a}function r(o){if(o.ep)return;o.ep=!0;const a=t(o);fetch(o.href,a)}})();var pw=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function Xf(n){return n&&n.__esModule&&Object.prototype.hasOwnProperty.call(n,"default")?n.default:n}function Gx(n){if(Object.prototype.hasOwnProperty.call(n,"__esModule"))return n;var e=n.default;if(typeof e=="function"){var t=function r(){var o=!1;try{o=this instanceof r}catch{}return o?Reflect.construct(e,arguments,this.constructor):e.apply(this,arguments)};t.prototype=e.prototype}else t={};return Object.defineProperty(t,"__esModule",{value:!0}),Object.keys(n).forEach(function(r){var o=Object.getOwnPropertyDescriptor(n,r);Object.defineProperty(t,r,o.get?o:{enumerable:!0,get:function(){return n[r]}})}),t}var ah={exports:{}},Io={},lh={exports:{}},Be={};var qg;function qx(){if(qg)return Be;qg=1;var n=Symbol.for("react.element"),e=Symbol.for("react.portal"),t=Symbol.for("react.fragment"),r=Symbol.for("react.strict_mode"),o=Symbol.for("react.profiler"),a=Symbol.for("react.provider"),u=Symbol.for("react.context"),c=Symbol.for("react.forward_ref"),h=Symbol.for("react.suspense"),d=Symbol.for("react.memo"),m=Symbol.for("react.lazy"),g=Symbol.iterator;function v(A){return A===null||typeof A!="object"?null:(A=g&&A[g]||A["@@iterator"],typeof A=="function"?A:null)}var w={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},k=Object.assign,S={};function x(A,W,te){this.props=A,this.context=W,this.refs=S,this.updater=te||w}x.prototype.isReactComponent={},x.prototype.setState=function(A,W){if(typeof A!="object"&&typeof A!="function"&&A!=null)throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,A,W,"setState")},x.prototype.forceUpdate=function(A){this.updater.enqueueForceUpdate(this,A,"forceUpdate")};function T(){}T.prototype=x.prototype;function z(A,W,te){this.props=A,this.context=W,this.refs=S,this.updater=te||w}var R=z.prototype=new T;R.constructor=z,k(R,x.prototype),R.isPureReactComponent=!0;var $=Array.isArray,B=Object.prototype.hasOwnProperty,H={current:null},Y={key:!0,ref:!0,__self:!0,__source:!0};function Z(A,W,te){var N,F={},U=null,Q=null;if(W!=null)for(N in W.ref!==void 0&&(Q=W.ref),W.key!==void 0&&(U=""+W.key),W)B.call(W,N)&&!Y.hasOwnProperty(N)&&(F[N]=W[N]);var ue=arguments.length-2;if(ue===1)F.children=te;else if(1<ue){for(var fe=Array(ue),ce=0;ce<ue;ce++)fe[ce]=arguments[ce+2];F.children=fe}if(A&&A.defaultProps)for(N in ue=A.defaultProps,ue)F[N]===void 0&&(F[N]=ue[N]);return{$$typeof:n,type:A,key:U,ref:Q,props:F,_owner:H.current}}function ne(A,W){return{$$typeof:n,type:A.type,key:W,ref:A.ref,props:A.props,_owner:A._owner}}function oe(A){return typeof A=="object"&&A!==null&&A.$$typeof===n}function de(A){var W={"=":"=0",":":"=2"};return"$"+A.replace(/[=:]/g,function(te){return W[te]})}var me=/\/+/g;function ve(A,W){return typeof A=="object"&&A!==null&&A.key!=null?de(""+A.key):W.toString(36)}function be(A,W,te,N,F){var U=typeof A;(U==="undefined"||U==="boolean")&&(A=null);var Q=!1;if(A===null)Q=!0;else switch(U){case"string":case"number":Q=!0;break;case"object":switch(A.$$typeof){case n:case e:Q=!0}}if(Q)return Q=A,F=F(Q),A=N===""?"."+ve(Q,0):N,$(F)?(te="",A!=null&&(te=A.replace(me,"$&/")+"/"),be(F,W,te,"",function(ce){return ce})):F!=null&&(oe(F)&&(F=ne(F,te+(!F.key||Q&&Q.key===F.key?"":(""+F.key).replace(me,"$&/")+"/")+A)),W.push(F)),1;if(Q=0,N=N===""?".":N+":",$(A))for(var ue=0;ue<A.length;ue++){U=A[ue];var fe=N+ve(U,ue);Q+=be(U,W,te,fe,F)}else if(fe=v(A),typeof fe=="function")for(A=fe.call(A),ue=0;!(U=A.next()).done;)U=U.value,fe=N+ve(U,ue++),Q+=be(U,W,te,fe,F);else if(U==="object")throw W=String(A),Error("Objects are not valid as a React child (found: "+(W==="[object Object]"?"object with keys {"+Object.keys(A).join(", ")+"}":W)+"). If you meant to render a collection of children, use an array instead.");return Q}function Ne(A,W,te){if(A==null)return A;var N=[],F=0;return be(A,N,"","",function(U){return W.call(te,U,F++)}),N}function Ie(A){if(A._status===-1){var W=A._result;W=W(),W.then(function(te){(A._status===0||A._status===-1)&&(A._status=1,A._result=te)},function(te){(A._status===0||A._status===-1)&&(A._status=2,A._result=te)}),A._status===-1&&(A._status=0,A._result=W)}if(A._status===1)return A._result.default;throw A._result}var Ee={current:null},D={transition:null},I={ReactCurrentDispatcher:Ee,ReactCurrentBatchConfig:D,ReactCurrentOwner:H};return Be.Children={map:Ne,forEach:function(A,W,te){Ne(A,function(){W.apply(this,arguments)},te)},count:function(A){var W=0;return Ne(A,function(){W++}),W},toArray:function(A){return Ne(A,function(W){return W})||[]},only:function(A){if(!oe(A))throw Error("React.Children.only expected to receive a single React element child.");return A}},Be.Component=x,Be.Fragment=t,Be.Profiler=o,Be.PureComponent=z,Be.StrictMode=r,Be.Suspense=h,Be.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=I,Be.cloneElement=function(A,W,te){if(A==null)throw Error("React.cloneElement(...): The argument must be a React element, but you passed "+A+".");var N=k({},A.props),F=A.key,U=A.ref,Q=A._owner;if(W!=null){if(W.ref!==void 0&&(U=W.ref,Q=H.current),W.key!==void 0&&(F=""+W.key),A.type&&A.type.defaultProps)var ue=A.type.defaultProps;for(fe in W)B.call(W,fe)&&!Y.hasOwnProperty(fe)&&(N[fe]=W[fe]===void 0&&ue!==void 0?ue[fe]:W[fe])}var fe=arguments.length-2;if(fe===1)N.children=te;else if(1<fe){ue=Array(fe);for(var ce=0;ce<fe;ce++)ue[ce]=arguments[ce+2];N.children=ue}return{$$typeof:n,type:A.type,key:F,ref:U,props:N,_owner:Q}},Be.createContext=function(A){return A={$$typeof:u,_currentValue:A,_currentValue2:A,_threadCount:0,Provider:null,Consumer:null,_defaultValue:null,_globalName:null},A.Provider={$$typeof:a,_context:A},A.Consumer=A},Be.createElement=Z,Be.createFactory=function(A){var W=Z.bind(null,A);return W.type=A,W},Be.createRef=function(){return{current:null}},Be.forwardRef=function(A){return{$$typeof:c,render:A}},Be.isValidElement=oe,Be.lazy=function(A){return{$$typeof:m,_payload:{_status:-1,_result:A},_init:Ie}},Be.memo=function(A,W){return{$$typeof:d,type:A,compare:W===void 0?null:W}},Be.startTransition=function(A){var W=D.transition;D.transition={};try{A()}finally{D.transition=W}},Be.unstable_act=function(){throw Error("act(...) is not supported in production builds of React.")},Be.useCallback=function(A,W){return Ee.current.useCallback(A,W)},Be.useContext=function(A){return Ee.current.useContext(A)},Be.useDebugValue=function(){},Be.useDeferredValue=function(A){return Ee.current.useDeferredValue(A)},Be.useEffect=function(A,W){return Ee.current.useEffect(A,W)},Be.useId=function(){return Ee.current.useId()},Be.useImperativeHandle=function(A,W,te){return Ee.current.useImperativeHandle(A,W,te)},Be.useInsertionEffect=function(A,W){return Ee.current.useInsertionEffect(A,W)},Be.useLayoutEffect=function(A,W){return Ee.current.useLayoutEffect(A,W)},Be.useMemo=function(A,W){return Ee.current.useMemo(A,W)},Be.useReducer=function(A,W,te){return Ee.current.useReducer(A,W,te)},Be.useRef=function(A){return Ee.current.useRef(A)},Be.useState=function(A){return Ee.current.useState(A)},Be.useSyncExternalStore=function(A,W,te){return Ee.current.useSyncExternalStore(A,W,te)},Be.useTransition=function(){return Ee.current.useTransition()},Be.version="18.2.0",Be}var Hg;function Yf(){return Hg||(Hg=1,lh.exports=qx()),lh.exports}var Kg;function Hx(){if(Kg)return Io;Kg=1;var n=Yf(),e=Symbol.for("react.element"),t=Symbol.for("react.fragment"),r=Object.prototype.hasOwnProperty,o=n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,a={key:!0,ref:!0,__self:!0,__source:!0};function u(c,h,d){var m,g={},v=null,w=null;d!==void 0&&(v=""+d),h.key!==void 0&&(v=""+h.key),h.ref!==void 0&&(w=h.ref);for(m in h)r.call(h,m)&&!a.hasOwnProperty(m)&&(g[m]=h[m]);if(c&&c.defaultProps)for(m in h=c.defaultProps,h)g[m]===void 0&&(g[m]=h[m]);return{$$typeof:e,type:c,key:v,ref:w,props:g,_owner:o.current}}return Io.Fragment=t,Io.jsx=u,Io.jsxs=u,Io}var Jg;function Kx(){return Jg||(Jg=1,ah.exports=Hx()),ah.exports}var Xe=Kx(),vi=Yf();const Jx=Xf(vi);var hl={},uh={exports:{}},hn={},ch={exports:{}},hh={};var Xg;function Xx(){return Xg||(Xg=1,(function(n){function e(D,I){var A=D.length;D.push(I);e:for(;0<A;){var W=A-1>>>1,te=D[W];if(0<o(te,I))D[W]=I,D[A]=te,A=W;else break e}}function t(D){return D.length===0?null:D[0]}function r(D){if(D.length===0)return null;var I=D[0],A=D.pop();if(A!==I){D[0]=A;e:for(var W=0,te=D.length,N=te>>>1;W<N;){var F=2*(W+1)-1,U=D[F],Q=F+1,ue=D[Q];if(0>o(U,A))Q<te&&0>o(ue,U)?(D[W]=ue,D[Q]=A,W=Q):(D[W]=U,D[F]=A,W=F);else if(Q<te&&0>o(ue,A))D[W]=ue,D[Q]=A,W=Q;else break e}}return I}function o(D,I){var A=D.sortIndex-I.sortIndex;return A!==0?A:D.id-I.id}if(typeof performance=="object"&&typeof performance.now=="function"){var a=performance;n.unstable_now=function(){return a.now()}}else{var u=Date,c=u.now();n.unstable_now=function(){return u.now()-c}}var h=[],d=[],m=1,g=null,v=3,w=!1,k=!1,S=!1,x=typeof setTimeout=="function"?setTimeout:null,T=typeof clearTimeout=="function"?clearTimeout:null,z=typeof setImmediate<"u"?setImmediate:null;typeof navigator<"u"&&navigator.scheduling!==void 0&&navigator.scheduling.isInputPending!==void 0&&navigator.scheduling.isInputPending.bind(navigator.scheduling);function R(D){for(var I=t(d);I!==null;){if(I.callback===null)r(d);else if(I.startTime<=D)r(d),I.sortIndex=I.expirationTime,e(h,I);else break;I=t(d)}}function $(D){if(S=!1,R(D),!k)if(t(h)!==null)k=!0,Ie(B);else{var I=t(d);I!==null&&Ee($,I.startTime-D)}}function B(D,I){k=!1,S&&(S=!1,T(Z),Z=-1),w=!0;var A=v;try{for(R(I),g=t(h);g!==null&&(!(g.expirationTime>I)||D&&!de());){var W=g.callback;if(typeof W=="function"){g.callback=null,v=g.priorityLevel;var te=W(g.expirationTime<=I);I=n.unstable_now(),typeof te=="function"?g.callback=te:g===t(h)&&r(h),R(I)}else r(h);g=t(h)}if(g!==null)var N=!0;else{var F=t(d);F!==null&&Ee($,F.startTime-I),N=!1}return N}finally{g=null,v=A,w=!1}}var H=!1,Y=null,Z=-1,ne=5,oe=-1;function de(){return!(n.unstable_now()-oe<ne)}function me(){if(Y!==null){var D=n.unstable_now();oe=D;var I=!0;try{I=Y(!0,D)}finally{I?ve():(H=!1,Y=null)}}else H=!1}var ve;if(typeof z=="function")ve=function(){z(me)};else if(typeof MessageChannel<"u"){var be=new MessageChannel,Ne=be.port2;be.port1.onmessage=me,ve=function(){Ne.postMessage(null)}}else ve=function(){x(me,0)};function Ie(D){Y=D,H||(H=!0,ve())}function Ee(D,I){Z=x(function(){D(n.unstable_now())},I)}n.unstable_IdlePriority=5,n.unstable_ImmediatePriority=1,n.unstable_LowPriority=4,n.unstable_NormalPriority=3,n.unstable_Profiling=null,n.unstable_UserBlockingPriority=2,n.unstable_cancelCallback=function(D){D.callback=null},n.unstable_continueExecution=function(){k||w||(k=!0,Ie(B))},n.unstable_forceFrameRate=function(D){0>D||125<D?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):ne=0<D?Math.floor(1e3/D):5},n.unstable_getCurrentPriorityLevel=function(){return v},n.unstable_getFirstCallbackNode=function(){return t(h)},n.unstable_next=function(D){switch(v){case 1:case 2:case 3:var I=3;break;default:I=v}var A=v;v=I;try{return D()}finally{v=A}},n.unstable_pauseExecution=function(){},n.unstable_requestPaint=function(){},n.unstable_runWithPriority=function(D,I){switch(D){case 1:case 2:case 3:case 4:case 5:break;default:D=3}var A=v;v=D;try{return I()}finally{v=A}},n.unstable_scheduleCallback=function(D,I,A){var W=n.unstable_now();switch(typeof A=="object"&&A!==null?(A=A.delay,A=typeof A=="number"&&0<A?W+A:W):A=W,D){case 1:var te=-1;break;case 2:te=250;break;case 5:te=1073741823;break;case 4:te=1e4;break;default:te=5e3}return te=A+te,D={id:m++,callback:I,priorityLevel:D,startTime:A,expirationTime:te,sortIndex:-1},A>W?(D.sortIndex=A,e(d,D),t(h)===null&&D===t(d)&&(S?(T(Z),Z=-1):S=!0,Ee($,A-W))):(D.sortIndex=te,e(h,D),k||w||(k=!0,Ie(B))),D},n.unstable_shouldYield=de,n.unstable_wrapCallback=function(D){var I=v;return function(){var A=v;v=I;try{return D.apply(this,arguments)}finally{v=A}}}})(hh)),hh}var Yg;function Yx(){return Yg||(Yg=1,ch.exports=Xx()),ch.exports}var Zg;function Zx(){if(Zg)return hn;Zg=1;var n=Yf(),e=Yx();function t(s){for(var i="https://reactjs.org/docs/error-decoder.html?invariant="+s,l=1;l<arguments.length;l++)i+="&args[]="+encodeURIComponent(arguments[l]);return"Minified React error #"+s+"; visit "+i+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var r=new Set,o={};function a(s,i){u(s,i),u(s+"Capture",i)}function u(s,i){for(o[s]=i,s=0;s<i.length;s++)r.add(i[s])}var c=!(typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"),h=Object.prototype.hasOwnProperty,d=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,m={},g={};function v(s){return h.call(g,s)?!0:h.call(m,s)?!1:d.test(s)?g[s]=!0:(m[s]=!0,!1)}function w(s,i,l,f){if(l!==null&&l.type===0)return!1;switch(typeof i){case"function":case"symbol":return!0;case"boolean":return f?!1:l!==null?!l.acceptsBooleans:(s=s.toLowerCase().slice(0,5),s!=="data-"&&s!=="aria-");default:return!1}}function k(s,i,l,f){if(i===null||typeof i>"u"||w(s,i,l,f))return!0;if(f)return!1;if(l!==null)switch(l.type){case 3:return!i;case 4:return i===!1;case 5:return isNaN(i);case 6:return isNaN(i)||1>i}return!1}function S(s,i,l,f,p,y,b){this.acceptsBooleans=i===2||i===3||i===4,this.attributeName=f,this.attributeNamespace=p,this.mustUseProperty=l,this.propertyName=s,this.type=i,this.sanitizeURL=y,this.removeEmptyString=b}var x={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(s){x[s]=new S(s,0,!1,s,null,!1,!1)}),[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(s){var i=s[0];x[i]=new S(i,1,!1,s[1],null,!1,!1)}),["contentEditable","draggable","spellCheck","value"].forEach(function(s){x[s]=new S(s,2,!1,s.toLowerCase(),null,!1,!1)}),["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(s){x[s]=new S(s,2,!1,s,null,!1,!1)}),"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(s){x[s]=new S(s,3,!1,s.toLowerCase(),null,!1,!1)}),["checked","multiple","muted","selected"].forEach(function(s){x[s]=new S(s,3,!0,s,null,!1,!1)}),["capture","download"].forEach(function(s){x[s]=new S(s,4,!1,s,null,!1,!1)}),["cols","rows","size","span"].forEach(function(s){x[s]=new S(s,6,!1,s,null,!1,!1)}),["rowSpan","start"].forEach(function(s){x[s]=new S(s,5,!1,s.toLowerCase(),null,!1,!1)});var T=/[\-:]([a-z])/g;function z(s){return s[1].toUpperCase()}"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(s){var i=s.replace(T,z);x[i]=new S(i,1,!1,s,null,!1,!1)}),"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(s){var i=s.replace(T,z);x[i]=new S(i,1,!1,s,"http://www.w3.org/1999/xlink",!1,!1)}),["xml:base","xml:lang","xml:space"].forEach(function(s){var i=s.replace(T,z);x[i]=new S(i,1,!1,s,"http://www.w3.org/XML/1998/namespace",!1,!1)}),["tabIndex","crossOrigin"].forEach(function(s){x[s]=new S(s,1,!1,s.toLowerCase(),null,!1,!1)}),x.xlinkHref=new S("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1),["src","href","action","formAction"].forEach(function(s){x[s]=new S(s,1,!1,s.toLowerCase(),null,!0,!0)});function R(s,i,l,f){var p=x.hasOwnProperty(i)?x[i]:null;(p!==null?p.type!==0:f||!(2<i.length)||i[0]!=="o"&&i[0]!=="O"||i[1]!=="n"&&i[1]!=="N")&&(k(i,l,p,f)&&(l=null),f||p===null?v(i)&&(l===null?s.removeAttribute(i):s.setAttribute(i,""+l)):p.mustUseProperty?s[p.propertyName]=l===null?p.type===3?!1:"":l:(i=p.attributeName,f=p.attributeNamespace,l===null?s.removeAttribute(i):(p=p.type,l=p===3||p===4&&l===!0?"":""+l,f?s.setAttributeNS(f,i,l):s.setAttribute(i,l))))}var $=n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,B=Symbol.for("react.element"),H=Symbol.for("react.portal"),Y=Symbol.for("react.fragment"),Z=Symbol.for("react.strict_mode"),ne=Symbol.for("react.profiler"),oe=Symbol.for("react.provider"),de=Symbol.for("react.context"),me=Symbol.for("react.forward_ref"),ve=Symbol.for("react.suspense"),be=Symbol.for("react.suspense_list"),Ne=Symbol.for("react.memo"),Ie=Symbol.for("react.lazy"),Ee=Symbol.for("react.offscreen"),D=Symbol.iterator;function I(s){return s===null||typeof s!="object"?null:(s=D&&s[D]||s["@@iterator"],typeof s=="function"?s:null)}var A=Object.assign,W;function te(s){if(W===void 0)try{throw Error()}catch(l){var i=l.stack.trim().match(/\n( *(at )?)/);W=i&&i[1]||""}return`
`+W+s}var N=!1;function F(s,i){if(!s||N)return"";N=!0;var l=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(i)if(i=function(){throw Error()},Object.defineProperty(i.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct(i,[])}catch(K){var f=K}Reflect.construct(s,[],i)}else{try{i.call()}catch(K){f=K}s.call(i.prototype)}else{try{throw Error()}catch(K){f=K}s()}}catch(K){if(K&&f&&typeof K.stack=="string"){for(var p=K.stack.split(`
`),y=f.stack.split(`
`),b=p.length-1,C=y.length-1;1<=b&&0<=C&&p[b]!==y[C];)C--;for(;1<=b&&0<=C;b--,C--)if(p[b]!==y[C]){if(b!==1||C!==1)do if(b--,C--,0>C||p[b]!==y[C]){var M=`
`+p[b].replace(" at new "," at ");return s.displayName&&M.includes("<anonymous>")&&(M=M.replace("<anonymous>",s.displayName)),M}while(1<=b&&0<=C);break}}}finally{N=!1,Error.prepareStackTrace=l}return(s=s?s.displayName||s.name:"")?te(s):""}function U(s){switch(s.tag){case 5:return te(s.type);case 16:return te("Lazy");case 13:return te("Suspense");case 19:return te("SuspenseList");case 0:case 2:case 15:return s=F(s.type,!1),s;case 11:return s=F(s.type.render,!1),s;case 1:return s=F(s.type,!0),s;default:return""}}function Q(s){if(s==null)return null;if(typeof s=="function")return s.displayName||s.name||null;if(typeof s=="string")return s;switch(s){case Y:return"Fragment";case H:return"Portal";case ne:return"Profiler";case Z:return"StrictMode";case ve:return"Suspense";case be:return"SuspenseList"}if(typeof s=="object")switch(s.$$typeof){case de:return(s.displayName||"Context")+".Consumer";case oe:return(s._context.displayName||"Context")+".Provider";case me:var i=s.render;return s=s.displayName,s||(s=i.displayName||i.name||"",s=s!==""?"ForwardRef("+s+")":"ForwardRef"),s;case Ne:return i=s.displayName||null,i!==null?i:Q(s.type)||"Memo";case Ie:i=s._payload,s=s._init;try{return Q(s(i))}catch{}}return null}function ue(s){var i=s.type;switch(s.tag){case 24:return"Cache";case 9:return(i.displayName||"Context")+".Consumer";case 10:return(i._context.displayName||"Context")+".Provider";case 18:return"DehydratedFragment";case 11:return s=i.render,s=s.displayName||s.name||"",i.displayName||(s!==""?"ForwardRef("+s+")":"ForwardRef");case 7:return"Fragment";case 5:return i;case 4:return"Portal";case 3:return"Root";case 6:return"Text";case 16:return Q(i);case 8:return i===Z?"StrictMode":"Mode";case 22:return"Offscreen";case 12:return"Profiler";case 21:return"Scope";case 13:return"Suspense";case 19:return"SuspenseList";case 25:return"TracingMarker";case 1:case 0:case 17:case 2:case 14:case 15:if(typeof i=="function")return i.displayName||i.name||null;if(typeof i=="string")return i}return null}function fe(s){switch(typeof s){case"boolean":case"number":case"string":case"undefined":return s;case"object":return s;default:return""}}function ce(s){var i=s.type;return(s=s.nodeName)&&s.toLowerCase()==="input"&&(i==="checkbox"||i==="radio")}function pe(s){var i=ce(s)?"checked":"value",l=Object.getOwnPropertyDescriptor(s.constructor.prototype,i),f=""+s[i];if(!s.hasOwnProperty(i)&&typeof l<"u"&&typeof l.get=="function"&&typeof l.set=="function"){var p=l.get,y=l.set;return Object.defineProperty(s,i,{configurable:!0,get:function(){return p.call(this)},set:function(b){f=""+b,y.call(this,b)}}),Object.defineProperty(s,i,{enumerable:l.enumerable}),{getValue:function(){return f},setValue:function(b){f=""+b},stopTracking:function(){s._valueTracker=null,delete s[i]}}}}function we(s){s._valueTracker||(s._valueTracker=pe(s))}function ge(s){if(!s)return!1;var i=s._valueTracker;if(!i)return!0;var l=i.getValue(),f="";return s&&(f=ce(s)?s.checked?"true":"false":s.value),s=f,s!==l?(i.setValue(s),!0):!1}function Le(s){if(s=s||(typeof document<"u"?document:void 0),typeof s>"u")return null;try{return s.activeElement||s.body}catch{return s.body}}function Pe(s,i){var l=i.checked;return A({},i,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:l??s._wrapperState.initialChecked})}function Ve(s,i){var l=i.defaultValue==null?"":i.defaultValue,f=i.checked!=null?i.checked:i.defaultChecked;l=fe(i.value!=null?i.value:l),s._wrapperState={initialChecked:f,initialValue:l,controlled:i.type==="checkbox"||i.type==="radio"?i.checked!=null:i.value!=null}}function je(s,i){i=i.checked,i!=null&&R(s,"checked",i,!1)}function wt(s,i){je(s,i);var l=fe(i.value),f=i.type;if(l!=null)f==="number"?(l===0&&s.value===""||s.value!=l)&&(s.value=""+l):s.value!==""+l&&(s.value=""+l);else if(f==="submit"||f==="reset"){s.removeAttribute("value");return}i.hasOwnProperty("value")?ee(s,i.type,l):i.hasOwnProperty("defaultValue")&&ee(s,i.type,fe(i.defaultValue)),i.checked==null&&i.defaultChecked!=null&&(s.defaultChecked=!!i.defaultChecked)}function Nt(s,i,l){if(i.hasOwnProperty("value")||i.hasOwnProperty("defaultValue")){var f=i.type;if(!(f!=="submit"&&f!=="reset"||i.value!==void 0&&i.value!==null))return;i=""+s._wrapperState.initialValue,l||i===s.value||(s.value=i),s.defaultValue=i}l=s.name,l!==""&&(s.name=""),s.defaultChecked=!!s._wrapperState.initialChecked,l!==""&&(s.name=l)}function ee(s,i,l){(i!=="number"||Le(s.ownerDocument)!==s)&&(l==null?s.defaultValue=""+s._wrapperState.initialValue:s.defaultValue!==""+l&&(s.defaultValue=""+l))}var Jt=Array.isArray;function Ct(s,i,l,f){if(s=s.options,i){i={};for(var p=0;p<l.length;p++)i["$"+l[p]]=!0;for(l=0;l<s.length;l++)p=i.hasOwnProperty("$"+s[l].value),s[l].selected!==p&&(s[l].selected=p),p&&f&&(s[l].defaultSelected=!0)}else{for(l=""+fe(l),i=null,p=0;p<s.length;p++){if(s[p].value===l){s[p].selected=!0,f&&(s[p].defaultSelected=!0);return}i!==null||s[p].disabled||(i=s[p])}i!==null&&(i.selected=!0)}}function Fn(s,i){if(i.dangerouslySetInnerHTML!=null)throw Error(t(91));return A({},i,{value:void 0,defaultValue:void 0,children:""+s._wrapperState.initialValue})}function wr(s,i){var l=i.value;if(l==null){if(l=i.children,i=i.defaultValue,l!=null){if(i!=null)throw Error(t(92));if(Jt(l)){if(1<l.length)throw Error(t(93));l=l[0]}i=l}i==null&&(i=""),l=i}s._wrapperState={initialValue:fe(l)}}function nr(s,i){var l=fe(i.value),f=fe(i.defaultValue);l!=null&&(l=""+l,l!==s.value&&(s.value=l),i.defaultValue==null&&s.defaultValue!==l&&(s.defaultValue=l)),f!=null&&(s.defaultValue=""+f)}function na(s){var i=s.textContent;i===s._wrapperState.initialValue&&i!==""&&i!==null&&(s.value=i)}function ra(s){switch(s){case"svg":return"http://www.w3.org/2000/svg";case"math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Vs(s,i){return s==null||s==="http://www.w3.org/1999/xhtml"?ra(i):s==="http://www.w3.org/2000/svg"&&i==="foreignObject"?"http://www.w3.org/1999/xhtml":s}var hs,Gs=(function(s){return typeof MSApp<"u"&&MSApp.execUnsafeLocalFunction?function(i,l,f,p){MSApp.execUnsafeLocalFunction(function(){return s(i,l,f,p)})}:s})(function(s,i){if(s.namespaceURI!=="http://www.w3.org/2000/svg"||"innerHTML"in s)s.innerHTML=i;else{for(hs=hs||document.createElement("div"),hs.innerHTML="<svg>"+i.valueOf().toString()+"</svg>",i=hs.firstChild;s.firstChild;)s.removeChild(s.firstChild);for(;i.firstChild;)s.appendChild(i.firstChild)}});function fs(s,i){if(i){var l=s.firstChild;if(l&&l===s.lastChild&&l.nodeType===3){l.nodeValue=i;return}}s.textContent=i}var ds={animationIterationCount:!0,aspectRatio:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Jk=["Webkit","ms","Moz","O"];Object.keys(ds).forEach(function(s){Jk.forEach(function(i){i=i+s.charAt(0).toUpperCase()+s.substring(1),ds[i]=ds[s]})});function op(s,i,l){return i==null||typeof i=="boolean"||i===""?"":l||typeof i!="number"||i===0||ds.hasOwnProperty(s)&&ds[s]?(""+i).trim():i+"px"}function ap(s,i){s=s.style;for(var l in i)if(i.hasOwnProperty(l)){var f=l.indexOf("--")===0,p=op(l,i[l],f);l==="float"&&(l="cssFloat"),f?s.setProperty(l,p):s[l]=p}}var Xk=A({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});function wu(s,i){if(i){if(Xk[s]&&(i.children!=null||i.dangerouslySetInnerHTML!=null))throw Error(t(137,s));if(i.dangerouslySetInnerHTML!=null){if(i.children!=null)throw Error(t(60));if(typeof i.dangerouslySetInnerHTML!="object"||!("__html"in i.dangerouslySetInnerHTML))throw Error(t(61))}if(i.style!=null&&typeof i.style!="object")throw Error(t(62))}}function bu(s,i){if(s.indexOf("-")===-1)return typeof i.is=="string";switch(s){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var ku=null;function Su(s){return s=s.target||s.srcElement||window,s.correspondingUseElement&&(s=s.correspondingUseElement),s.nodeType===3?s.parentNode:s}var xu=null,qs=null,Hs=null;function lp(s){if(s=co(s)){if(typeof xu!="function")throw Error(t(280));var i=s.stateNode;i&&(i=Ia(i),xu(s.stateNode,s.type,i))}}function up(s){qs?Hs?Hs.push(s):Hs=[s]:qs=s}function cp(){if(qs){var s=qs,i=Hs;if(Hs=qs=null,lp(s),i)for(s=0;s<i.length;s++)lp(i[s])}}function hp(s,i){return s(i)}function fp(){}var Eu=!1;function dp(s,i,l){if(Eu)return s(i,l);Eu=!0;try{return hp(s,i,l)}finally{Eu=!1,(qs!==null||Hs!==null)&&(fp(),cp())}}function Wi(s,i){var l=s.stateNode;if(l===null)return null;var f=Ia(l);if(f===null)return null;l=f[i];e:switch(i){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(f=!f.disabled)||(s=s.type,f=!(s==="button"||s==="input"||s==="select"||s==="textarea")),s=!f;break e;default:s=!1}if(s)return null;if(l&&typeof l!="function")throw Error(t(231,i,typeof l));return l}var Au=!1;if(c)try{var Vi={};Object.defineProperty(Vi,"passive",{get:function(){Au=!0}}),window.addEventListener("test",Vi,Vi),window.removeEventListener("test",Vi,Vi)}catch{Au=!1}function Yk(s,i,l,f,p,y,b,C,M){var K=Array.prototype.slice.call(arguments,3);try{i.apply(l,K)}catch(ie){this.onError(ie)}}var Gi=!1,sa=null,ia=!1,Iu=null,Zk={onError:function(s){Gi=!0,sa=s}};function Qk(s,i,l,f,p,y,b,C,M){Gi=!1,sa=null,Yk.apply(Zk,arguments)}function eS(s,i,l,f,p,y,b,C,M){if(Qk.apply(this,arguments),Gi){if(Gi){var K=sa;Gi=!1,sa=null}else throw Error(t(198));ia||(ia=!0,Iu=K)}}function ps(s){var i=s,l=s;if(s.alternate)for(;i.return;)i=i.return;else{s=i;do i=s,(i.flags&4098)!==0&&(l=i.return),s=i.return;while(s)}return i.tag===3?l:null}function pp(s){if(s.tag===13){var i=s.memoizedState;if(i===null&&(s=s.alternate,s!==null&&(i=s.memoizedState)),i!==null)return i.dehydrated}return null}function mp(s){if(ps(s)!==s)throw Error(t(188))}function tS(s){var i=s.alternate;if(!i){if(i=ps(s),i===null)throw Error(t(188));return i!==s?null:s}for(var l=s,f=i;;){var p=l.return;if(p===null)break;var y=p.alternate;if(y===null){if(f=p.return,f!==null){l=f;continue}break}if(p.child===y.child){for(y=p.child;y;){if(y===l)return mp(p),s;if(y===f)return mp(p),i;y=y.sibling}throw Error(t(188))}if(l.return!==f.return)l=p,f=y;else{for(var b=!1,C=p.child;C;){if(C===l){b=!0,l=p,f=y;break}if(C===f){b=!0,f=p,l=y;break}C=C.sibling}if(!b){for(C=y.child;C;){if(C===l){b=!0,l=y,f=p;break}if(C===f){b=!0,f=y,l=p;break}C=C.sibling}if(!b)throw Error(t(189))}}if(l.alternate!==f)throw Error(t(190))}if(l.tag!==3)throw Error(t(188));return l.stateNode.current===l?s:i}function gp(s){return s=tS(s),s!==null?yp(s):null}function yp(s){if(s.tag===5||s.tag===6)return s;for(s=s.child;s!==null;){var i=yp(s);if(i!==null)return i;s=s.sibling}return null}var vp=e.unstable_scheduleCallback,wp=e.unstable_cancelCallback,nS=e.unstable_shouldYield,rS=e.unstable_requestPaint,bt=e.unstable_now,sS=e.unstable_getCurrentPriorityLevel,Tu=e.unstable_ImmediatePriority,bp=e.unstable_UserBlockingPriority,oa=e.unstable_NormalPriority,iS=e.unstable_LowPriority,kp=e.unstable_IdlePriority,aa=null,rr=null;function oS(s){if(rr&&typeof rr.onCommitFiberRoot=="function")try{rr.onCommitFiberRoot(aa,s,void 0,(s.current.flags&128)===128)}catch{}}var Ln=Math.clz32?Math.clz32:uS,aS=Math.log,lS=Math.LN2;function uS(s){return s>>>=0,s===0?32:31-(aS(s)/lS|0)|0}var la=64,ua=4194304;function qi(s){switch(s&-s){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return s&4194240;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return s&130023424;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 1073741824;default:return s}}function ca(s,i){var l=s.pendingLanes;if(l===0)return 0;var f=0,p=s.suspendedLanes,y=s.pingedLanes,b=l&268435455;if(b!==0){var C=b&~p;C!==0?f=qi(C):(y&=b,y!==0&&(f=qi(y)))}else b=l&~p,b!==0?f=qi(b):y!==0&&(f=qi(y));if(f===0)return 0;if(i!==0&&i!==f&&(i&p)===0&&(p=f&-f,y=i&-i,p>=y||p===16&&(y&4194240)!==0))return i;if((f&4)!==0&&(f|=l&16),i=s.entangledLanes,i!==0)for(s=s.entanglements,i&=f;0<i;)l=31-Ln(i),p=1<<l,f|=s[l],i&=~p;return f}function cS(s,i){switch(s){case 1:case 2:case 4:return i+250;case 8:case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return i+5e3;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return-1;case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}function hS(s,i){for(var l=s.suspendedLanes,f=s.pingedLanes,p=s.expirationTimes,y=s.pendingLanes;0<y;){var b=31-Ln(y),C=1<<b,M=p[b];M===-1?((C&l)===0||(C&f)!==0)&&(p[b]=cS(C,i)):M<=i&&(s.expiredLanes|=C),y&=~C}}function Nu(s){return s=s.pendingLanes&-1073741825,s!==0?s:s&1073741824?1073741824:0}function Sp(){var s=la;return la<<=1,(la&4194240)===0&&(la=64),s}function Cu(s){for(var i=[],l=0;31>l;l++)i.push(s);return i}function Hi(s,i,l){s.pendingLanes|=i,i!==536870912&&(s.suspendedLanes=0,s.pingedLanes=0),s=s.eventTimes,i=31-Ln(i),s[i]=l}function fS(s,i){var l=s.pendingLanes&~i;s.pendingLanes=i,s.suspendedLanes=0,s.pingedLanes=0,s.expiredLanes&=i,s.mutableReadLanes&=i,s.entangledLanes&=i,i=s.entanglements;var f=s.eventTimes;for(s=s.expirationTimes;0<l;){var p=31-Ln(l),y=1<<p;i[p]=0,f[p]=-1,s[p]=-1,l&=~y}}function Du(s,i){var l=s.entangledLanes|=i;for(s=s.entanglements;l;){var f=31-Ln(l),p=1<<f;p&i|s[f]&i&&(s[f]|=i),l&=~p}}var Ze=0;function xp(s){return s&=-s,1<s?4<s?(s&268435455)!==0?16:536870912:4:1}var Ep,zu,Ap,Ip,Tp,$u=!1,ha=[],zr=null,$r=null,Mr=null,Ki=new Map,Ji=new Map,Rr=[],dS="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");function Np(s,i){switch(s){case"focusin":case"focusout":zr=null;break;case"dragenter":case"dragleave":$r=null;break;case"mouseover":case"mouseout":Mr=null;break;case"pointerover":case"pointerout":Ki.delete(i.pointerId);break;case"gotpointercapture":case"lostpointercapture":Ji.delete(i.pointerId)}}function Xi(s,i,l,f,p,y){return s===null||s.nativeEvent!==y?(s={blockedOn:i,domEventName:l,eventSystemFlags:f,nativeEvent:y,targetContainers:[p]},i!==null&&(i=co(i),i!==null&&zu(i)),s):(s.eventSystemFlags|=f,i=s.targetContainers,p!==null&&i.indexOf(p)===-1&&i.push(p),s)}function pS(s,i,l,f,p){switch(i){case"focusin":return zr=Xi(zr,s,i,l,f,p),!0;case"dragenter":return $r=Xi($r,s,i,l,f,p),!0;case"mouseover":return Mr=Xi(Mr,s,i,l,f,p),!0;case"pointerover":var y=p.pointerId;return Ki.set(y,Xi(Ki.get(y)||null,s,i,l,f,p)),!0;case"gotpointercapture":return y=p.pointerId,Ji.set(y,Xi(Ji.get(y)||null,s,i,l,f,p)),!0}return!1}function Cp(s){var i=ms(s.target);if(i!==null){var l=ps(i);if(l!==null){if(i=l.tag,i===13){if(i=pp(l),i!==null){s.blockedOn=i,Tp(s.priority,function(){Ap(l)});return}}else if(i===3&&l.stateNode.current.memoizedState.isDehydrated){s.blockedOn=l.tag===3?l.stateNode.containerInfo:null;return}}}s.blockedOn=null}function fa(s){if(s.blockedOn!==null)return!1;for(var i=s.targetContainers;0<i.length;){var l=Ru(s.domEventName,s.eventSystemFlags,i[0],s.nativeEvent);if(l===null){l=s.nativeEvent;var f=new l.constructor(l.type,l);ku=f,l.target.dispatchEvent(f),ku=null}else return i=co(l),i!==null&&zu(i),s.blockedOn=l,!1;i.shift()}return!0}function Dp(s,i,l){fa(s)&&l.delete(i)}function mS(){$u=!1,zr!==null&&fa(zr)&&(zr=null),$r!==null&&fa($r)&&($r=null),Mr!==null&&fa(Mr)&&(Mr=null),Ki.forEach(Dp),Ji.forEach(Dp)}function Yi(s,i){s.blockedOn===i&&(s.blockedOn=null,$u||($u=!0,e.unstable_scheduleCallback(e.unstable_NormalPriority,mS)))}function Zi(s){function i(p){return Yi(p,s)}if(0<ha.length){Yi(ha[0],s);for(var l=1;l<ha.length;l++){var f=ha[l];f.blockedOn===s&&(f.blockedOn=null)}}for(zr!==null&&Yi(zr,s),$r!==null&&Yi($r,s),Mr!==null&&Yi(Mr,s),Ki.forEach(i),Ji.forEach(i),l=0;l<Rr.length;l++)f=Rr[l],f.blockedOn===s&&(f.blockedOn=null);for(;0<Rr.length&&(l=Rr[0],l.blockedOn===null);)Cp(l),l.blockedOn===null&&Rr.shift()}var Ks=$.ReactCurrentBatchConfig,da=!0;function gS(s,i,l,f){var p=Ze,y=Ks.transition;Ks.transition=null;try{Ze=1,Mu(s,i,l,f)}finally{Ze=p,Ks.transition=y}}function yS(s,i,l,f){var p=Ze,y=Ks.transition;Ks.transition=null;try{Ze=4,Mu(s,i,l,f)}finally{Ze=p,Ks.transition=y}}function Mu(s,i,l,f){if(da){var p=Ru(s,i,l,f);if(p===null)Yu(s,i,f,pa,l),Np(s,f);else if(pS(p,s,i,l,f))f.stopPropagation();else if(Np(s,f),i&4&&-1<dS.indexOf(s)){for(;p!==null;){var y=co(p);if(y!==null&&Ep(y),y=Ru(s,i,l,f),y===null&&Yu(s,i,f,pa,l),y===p)break;p=y}p!==null&&f.stopPropagation()}else Yu(s,i,f,null,l)}}var pa=null;function Ru(s,i,l,f){if(pa=null,s=Su(f),s=ms(s),s!==null)if(i=ps(s),i===null)s=null;else if(l=i.tag,l===13){if(s=pp(i),s!==null)return s;s=null}else if(l===3){if(i.stateNode.current.memoizedState.isDehydrated)return i.tag===3?i.stateNode.containerInfo:null;s=null}else i!==s&&(s=null);return pa=s,null}function zp(s){switch(s){case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 1;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"toggle":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 4;case"message":switch(sS()){case Tu:return 1;case bp:return 4;case oa:case iS:return 16;case kp:return 536870912;default:return 16}default:return 16}}var _r=null,_u=null,ma=null;function $p(){if(ma)return ma;var s,i=_u,l=i.length,f,p="value"in _r?_r.value:_r.textContent,y=p.length;for(s=0;s<l&&i[s]===p[s];s++);var b=l-s;for(f=1;f<=b&&i[l-f]===p[y-f];f++);return ma=p.slice(s,1<f?1-f:void 0)}function ga(s){var i=s.keyCode;return"charCode"in s?(s=s.charCode,s===0&&i===13&&(s=13)):s=i,s===10&&(s=13),32<=s||s===13?s:0}function ya(){return!0}function Mp(){return!1}function mn(s){function i(l,f,p,y,b){this._reactName=l,this._targetInst=p,this.type=f,this.nativeEvent=y,this.target=b,this.currentTarget=null;for(var C in s)s.hasOwnProperty(C)&&(l=s[C],this[C]=l?l(y):y[C]);return this.isDefaultPrevented=(y.defaultPrevented!=null?y.defaultPrevented:y.returnValue===!1)?ya:Mp,this.isPropagationStopped=Mp,this}return A(i.prototype,{preventDefault:function(){this.defaultPrevented=!0;var l=this.nativeEvent;l&&(l.preventDefault?l.preventDefault():typeof l.returnValue!="unknown"&&(l.returnValue=!1),this.isDefaultPrevented=ya)},stopPropagation:function(){var l=this.nativeEvent;l&&(l.stopPropagation?l.stopPropagation():typeof l.cancelBubble!="unknown"&&(l.cancelBubble=!0),this.isPropagationStopped=ya)},persist:function(){},isPersistent:ya}),i}var Js={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(s){return s.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},Fu=mn(Js),Qi=A({},Js,{view:0,detail:0}),vS=mn(Qi),Lu,Ou,eo,va=A({},Qi,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:Bu,button:0,buttons:0,relatedTarget:function(s){return s.relatedTarget===void 0?s.fromElement===s.srcElement?s.toElement:s.fromElement:s.relatedTarget},movementX:function(s){return"movementX"in s?s.movementX:(s!==eo&&(eo&&s.type==="mousemove"?(Lu=s.screenX-eo.screenX,Ou=s.screenY-eo.screenY):Ou=Lu=0,eo=s),Lu)},movementY:function(s){return"movementY"in s?s.movementY:Ou}}),Rp=mn(va),wS=A({},va,{dataTransfer:0}),bS=mn(wS),kS=A({},Qi,{relatedTarget:0}),Pu=mn(kS),SS=A({},Js,{animationName:0,elapsedTime:0,pseudoElement:0}),xS=mn(SS),ES=A({},Js,{clipboardData:function(s){return"clipboardData"in s?s.clipboardData:window.clipboardData}}),AS=mn(ES),IS=A({},Js,{data:0}),_p=mn(IS),TS={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},NS={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},CS={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function DS(s){var i=this.nativeEvent;return i.getModifierState?i.getModifierState(s):(s=CS[s])?!!i[s]:!1}function Bu(){return DS}var zS=A({},Qi,{key:function(s){if(s.key){var i=TS[s.key]||s.key;if(i!=="Unidentified")return i}return s.type==="keypress"?(s=ga(s),s===13?"Enter":String.fromCharCode(s)):s.type==="keydown"||s.type==="keyup"?NS[s.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:Bu,charCode:function(s){return s.type==="keypress"?ga(s):0},keyCode:function(s){return s.type==="keydown"||s.type==="keyup"?s.keyCode:0},which:function(s){return s.type==="keypress"?ga(s):s.type==="keydown"||s.type==="keyup"?s.keyCode:0}}),$S=mn(zS),MS=A({},va,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),Fp=mn(MS),RS=A({},Qi,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:Bu}),_S=mn(RS),FS=A({},Js,{propertyName:0,elapsedTime:0,pseudoElement:0}),LS=mn(FS),OS=A({},va,{deltaX:function(s){return"deltaX"in s?s.deltaX:"wheelDeltaX"in s?-s.wheelDeltaX:0},deltaY:function(s){return"deltaY"in s?s.deltaY:"wheelDeltaY"in s?-s.wheelDeltaY:"wheelDelta"in s?-s.wheelDelta:0},deltaZ:0,deltaMode:0}),PS=mn(OS),BS=[9,13,27,32],Uu=c&&"CompositionEvent"in window,to=null;c&&"documentMode"in document&&(to=document.documentMode);var US=c&&"TextEvent"in window&&!to,Lp=c&&(!Uu||to&&8<to&&11>=to),Op=" ",Pp=!1;function Bp(s,i){switch(s){case"keyup":return BS.indexOf(i.keyCode)!==-1;case"keydown":return i.keyCode!==229;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function Up(s){return s=s.detail,typeof s=="object"&&"data"in s?s.data:null}var Xs=!1;function jS(s,i){switch(s){case"compositionend":return Up(i);case"keypress":return i.which!==32?null:(Pp=!0,Op);case"textInput":return s=i.data,s===Op&&Pp?null:s;default:return null}}function WS(s,i){if(Xs)return s==="compositionend"||!Uu&&Bp(s,i)?(s=$p(),ma=_u=_r=null,Xs=!1,s):null;switch(s){case"paste":return null;case"keypress":if(!(i.ctrlKey||i.altKey||i.metaKey)||i.ctrlKey&&i.altKey){if(i.char&&1<i.char.length)return i.char;if(i.which)return String.fromCharCode(i.which)}return null;case"compositionend":return Lp&&i.locale!=="ko"?null:i.data;default:return null}}var VS={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function jp(s){var i=s&&s.nodeName&&s.nodeName.toLowerCase();return i==="input"?!!VS[s.type]:i==="textarea"}function Wp(s,i,l,f){up(f),i=xa(i,"onChange"),0<i.length&&(l=new Fu("onChange","change",null,l,f),s.push({event:l,listeners:i}))}var no=null,ro=null;function GS(s){am(s,0)}function wa(s){var i=ti(s);if(ge(i))return s}function qS(s,i){if(s==="change")return i}var Vp=!1;if(c){var ju;if(c){var Wu="oninput"in document;if(!Wu){var Gp=document.createElement("div");Gp.setAttribute("oninput","return;"),Wu=typeof Gp.oninput=="function"}ju=Wu}else ju=!1;Vp=ju&&(!document.documentMode||9<document.documentMode)}function qp(){no&&(no.detachEvent("onpropertychange",Hp),ro=no=null)}function Hp(s){if(s.propertyName==="value"&&wa(ro)){var i=[];Wp(i,ro,s,Su(s)),dp(GS,i)}}function HS(s,i,l){s==="focusin"?(qp(),no=i,ro=l,no.attachEvent("onpropertychange",Hp)):s==="focusout"&&qp()}function KS(s){if(s==="selectionchange"||s==="keyup"||s==="keydown")return wa(ro)}function JS(s,i){if(s==="click")return wa(i)}function XS(s,i){if(s==="input"||s==="change")return wa(i)}function YS(s,i){return s===i&&(s!==0||1/s===1/i)||s!==s&&i!==i}var On=typeof Object.is=="function"?Object.is:YS;function so(s,i){if(On(s,i))return!0;if(typeof s!="object"||s===null||typeof i!="object"||i===null)return!1;var l=Object.keys(s),f=Object.keys(i);if(l.length!==f.length)return!1;for(f=0;f<l.length;f++){var p=l[f];if(!h.call(i,p)||!On(s[p],i[p]))return!1}return!0}function Kp(s){for(;s&&s.firstChild;)s=s.firstChild;return s}function Jp(s,i){var l=Kp(s);s=0;for(var f;l;){if(l.nodeType===3){if(f=s+l.textContent.length,s<=i&&f>=i)return{node:l,offset:i-s};s=f}e:{for(;l;){if(l.nextSibling){l=l.nextSibling;break e}l=l.parentNode}l=void 0}l=Kp(l)}}function Xp(s,i){return s&&i?s===i?!0:s&&s.nodeType===3?!1:i&&i.nodeType===3?Xp(s,i.parentNode):"contains"in s?s.contains(i):s.compareDocumentPosition?!!(s.compareDocumentPosition(i)&16):!1:!1}function Yp(){for(var s=window,i=Le();i instanceof s.HTMLIFrameElement;){try{var l=typeof i.contentWindow.location.href=="string"}catch{l=!1}if(l)s=i.contentWindow;else break;i=Le(s.document)}return i}function Vu(s){var i=s&&s.nodeName&&s.nodeName.toLowerCase();return i&&(i==="input"&&(s.type==="text"||s.type==="search"||s.type==="tel"||s.type==="url"||s.type==="password")||i==="textarea"||s.contentEditable==="true")}function ZS(s){var i=Yp(),l=s.focusedElem,f=s.selectionRange;if(i!==l&&l&&l.ownerDocument&&Xp(l.ownerDocument.documentElement,l)){if(f!==null&&Vu(l)){if(i=f.start,s=f.end,s===void 0&&(s=i),"selectionStart"in l)l.selectionStart=i,l.selectionEnd=Math.min(s,l.value.length);else if(s=(i=l.ownerDocument||document)&&i.defaultView||window,s.getSelection){s=s.getSelection();var p=l.textContent.length,y=Math.min(f.start,p);f=f.end===void 0?y:Math.min(f.end,p),!s.extend&&y>f&&(p=f,f=y,y=p),p=Jp(l,y);var b=Jp(l,f);p&&b&&(s.rangeCount!==1||s.anchorNode!==p.node||s.anchorOffset!==p.offset||s.focusNode!==b.node||s.focusOffset!==b.offset)&&(i=i.createRange(),i.setStart(p.node,p.offset),s.removeAllRanges(),y>f?(s.addRange(i),s.extend(b.node,b.offset)):(i.setEnd(b.node,b.offset),s.addRange(i)))}}for(i=[],s=l;s=s.parentNode;)s.nodeType===1&&i.push({element:s,left:s.scrollLeft,top:s.scrollTop});for(typeof l.focus=="function"&&l.focus(),l=0;l<i.length;l++)s=i[l],s.element.scrollLeft=s.left,s.element.scrollTop=s.top}}var QS=c&&"documentMode"in document&&11>=document.documentMode,Ys=null,Gu=null,io=null,qu=!1;function Zp(s,i,l){var f=l.window===l?l.document:l.nodeType===9?l:l.ownerDocument;qu||Ys==null||Ys!==Le(f)||(f=Ys,"selectionStart"in f&&Vu(f)?f={start:f.selectionStart,end:f.selectionEnd}:(f=(f.ownerDocument&&f.ownerDocument.defaultView||window).getSelection(),f={anchorNode:f.anchorNode,anchorOffset:f.anchorOffset,focusNode:f.focusNode,focusOffset:f.focusOffset}),io&&so(io,f)||(io=f,f=xa(Gu,"onSelect"),0<f.length&&(i=new Fu("onSelect","select",null,i,l),s.push({event:i,listeners:f}),i.target=Ys)))}function ba(s,i){var l={};return l[s.toLowerCase()]=i.toLowerCase(),l["Webkit"+s]="webkit"+i,l["Moz"+s]="moz"+i,l}var Zs={animationend:ba("Animation","AnimationEnd"),animationiteration:ba("Animation","AnimationIteration"),animationstart:ba("Animation","AnimationStart"),transitionend:ba("Transition","TransitionEnd")},Hu={},Qp={};c&&(Qp=document.createElement("div").style,"AnimationEvent"in window||(delete Zs.animationend.animation,delete Zs.animationiteration.animation,delete Zs.animationstart.animation),"TransitionEvent"in window||delete Zs.transitionend.transition);function ka(s){if(Hu[s])return Hu[s];if(!Zs[s])return s;var i=Zs[s],l;for(l in i)if(i.hasOwnProperty(l)&&l in Qp)return Hu[s]=i[l];return s}var em=ka("animationend"),tm=ka("animationiteration"),nm=ka("animationstart"),rm=ka("transitionend"),sm=new Map,im="abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");function Fr(s,i){sm.set(s,i),a(i,[s])}for(var Ku=0;Ku<im.length;Ku++){var Ju=im[Ku],ex=Ju.toLowerCase(),tx=Ju[0].toUpperCase()+Ju.slice(1);Fr(ex,"on"+tx)}Fr(em,"onAnimationEnd"),Fr(tm,"onAnimationIteration"),Fr(nm,"onAnimationStart"),Fr("dblclick","onDoubleClick"),Fr("focusin","onFocus"),Fr("focusout","onBlur"),Fr(rm,"onTransitionEnd"),u("onMouseEnter",["mouseout","mouseover"]),u("onMouseLeave",["mouseout","mouseover"]),u("onPointerEnter",["pointerout","pointerover"]),u("onPointerLeave",["pointerout","pointerover"]),a("onChange","change click focusin focusout input keydown keyup selectionchange".split(" ")),a("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),a("onBeforeInput",["compositionend","keypress","textInput","paste"]),a("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" ")),a("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" ")),a("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var oo="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),nx=new Set("cancel close invalid load scroll toggle".split(" ").concat(oo));function om(s,i,l){var f=s.type||"unknown-event";s.currentTarget=l,eS(f,i,void 0,s),s.currentTarget=null}function am(s,i){i=(i&4)!==0;for(var l=0;l<s.length;l++){var f=s[l],p=f.event;f=f.listeners;e:{var y=void 0;if(i)for(var b=f.length-1;0<=b;b--){var C=f[b],M=C.instance,K=C.currentTarget;if(C=C.listener,M!==y&&p.isPropagationStopped())break e;om(p,C,K),y=M}else for(b=0;b<f.length;b++){if(C=f[b],M=C.instance,K=C.currentTarget,C=C.listener,M!==y&&p.isPropagationStopped())break e;om(p,C,K),y=M}}}if(ia)throw s=Iu,ia=!1,Iu=null,s}function rt(s,i){var l=i[rc];l===void 0&&(l=i[rc]=new Set);var f=s+"__bubble";l.has(f)||(lm(i,s,2,!1),l.add(f))}function Xu(s,i,l){var f=0;i&&(f|=4),lm(l,s,f,i)}var Sa="_reactListening"+Math.random().toString(36).slice(2);function ao(s){if(!s[Sa]){s[Sa]=!0,r.forEach(function(l){l!=="selectionchange"&&(nx.has(l)||Xu(l,!1,s),Xu(l,!0,s))});var i=s.nodeType===9?s:s.ownerDocument;i===null||i[Sa]||(i[Sa]=!0,Xu("selectionchange",!1,i))}}function lm(s,i,l,f){switch(zp(i)){case 1:var p=gS;break;case 4:p=yS;break;default:p=Mu}l=p.bind(null,i,l,s),p=void 0,!Au||i!=="touchstart"&&i!=="touchmove"&&i!=="wheel"||(p=!0),f?p!==void 0?s.addEventListener(i,l,{capture:!0,passive:p}):s.addEventListener(i,l,!0):p!==void 0?s.addEventListener(i,l,{passive:p}):s.addEventListener(i,l,!1)}function Yu(s,i,l,f,p){var y=f;if((i&1)===0&&(i&2)===0&&f!==null)e:for(;;){if(f===null)return;var b=f.tag;if(b===3||b===4){var C=f.stateNode.containerInfo;if(C===p||C.nodeType===8&&C.parentNode===p)break;if(b===4)for(b=f.return;b!==null;){var M=b.tag;if((M===3||M===4)&&(M=b.stateNode.containerInfo,M===p||M.nodeType===8&&M.parentNode===p))return;b=b.return}for(;C!==null;){if(b=ms(C),b===null)return;if(M=b.tag,M===5||M===6){f=y=b;continue e}C=C.parentNode}}f=f.return}dp(function(){var K=y,ie=Su(l),ae=[];e:{var se=sm.get(s);if(se!==void 0){var ye=Fu,xe=s;switch(s){case"keypress":if(ga(l)===0)break e;case"keydown":case"keyup":ye=$S;break;case"focusin":xe="focus",ye=Pu;break;case"focusout":xe="blur",ye=Pu;break;case"beforeblur":case"afterblur":ye=Pu;break;case"click":if(l.button===2)break e;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":ye=Rp;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":ye=bS;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":ye=_S;break;case em:case tm:case nm:ye=xS;break;case rm:ye=LS;break;case"scroll":ye=vS;break;case"wheel":ye=PS;break;case"copy":case"cut":case"paste":ye=AS;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":ye=Fp}var Ae=(i&4)!==0,kt=!Ae&&s==="scroll",j=Ae?se!==null?se+"Capture":null:se;Ae=[];for(var L=K,q;L!==null;){q=L;var he=q.stateNode;if(q.tag===5&&he!==null&&(q=he,j!==null&&(he=Wi(L,j),he!=null&&Ae.push(lo(L,he,q)))),kt)break;L=L.return}0<Ae.length&&(se=new ye(se,xe,null,l,ie),ae.push({event:se,listeners:Ae}))}}if((i&7)===0){e:{if(se=s==="mouseover"||s==="pointerover",ye=s==="mouseout"||s==="pointerout",se&&l!==ku&&(xe=l.relatedTarget||l.fromElement)&&(ms(xe)||xe[br]))break e;if((ye||se)&&(se=ie.window===ie?ie:(se=ie.ownerDocument)?se.defaultView||se.parentWindow:window,ye?(xe=l.relatedTarget||l.toElement,ye=K,xe=xe?ms(xe):null,xe!==null&&(kt=ps(xe),xe!==kt||xe.tag!==5&&xe.tag!==6)&&(xe=null)):(ye=null,xe=K),ye!==xe)){if(Ae=Rp,he="onMouseLeave",j="onMouseEnter",L="mouse",(s==="pointerout"||s==="pointerover")&&(Ae=Fp,he="onPointerLeave",j="onPointerEnter",L="pointer"),kt=ye==null?se:ti(ye),q=xe==null?se:ti(xe),se=new Ae(he,L+"leave",ye,l,ie),se.target=kt,se.relatedTarget=q,he=null,ms(ie)===K&&(Ae=new Ae(j,L+"enter",xe,l,ie),Ae.target=q,Ae.relatedTarget=kt,he=Ae),kt=he,ye&&xe)t:{for(Ae=ye,j=xe,L=0,q=Ae;q;q=Qs(q))L++;for(q=0,he=j;he;he=Qs(he))q++;for(;0<L-q;)Ae=Qs(Ae),L--;for(;0<q-L;)j=Qs(j),q--;for(;L--;){if(Ae===j||j!==null&&Ae===j.alternate)break t;Ae=Qs(Ae),j=Qs(j)}Ae=null}else Ae=null;ye!==null&&um(ae,se,ye,Ae,!1),xe!==null&&kt!==null&&um(ae,kt,xe,Ae,!0)}}e:{if(se=K?ti(K):window,ye=se.nodeName&&se.nodeName.toLowerCase(),ye==="select"||ye==="input"&&se.type==="file")var Te=qS;else if(jp(se))if(Vp)Te=XS;else{Te=KS;var De=HS}else(ye=se.nodeName)&&ye.toLowerCase()==="input"&&(se.type==="checkbox"||se.type==="radio")&&(Te=JS);if(Te&&(Te=Te(s,K))){Wp(ae,Te,l,ie);break e}De&&De(s,se,K),s==="focusout"&&(De=se._wrapperState)&&De.controlled&&se.type==="number"&&ee(se,"number",se.value)}switch(De=K?ti(K):window,s){case"focusin":(jp(De)||De.contentEditable==="true")&&(Ys=De,Gu=K,io=null);break;case"focusout":io=Gu=Ys=null;break;case"mousedown":qu=!0;break;case"contextmenu":case"mouseup":case"dragend":qu=!1,Zp(ae,l,ie);break;case"selectionchange":if(QS)break;case"keydown":case"keyup":Zp(ae,l,ie)}var ze;if(Uu)e:{switch(s){case"compositionstart":var _e="onCompositionStart";break e;case"compositionend":_e="onCompositionEnd";break e;case"compositionupdate":_e="onCompositionUpdate";break e}_e=void 0}else Xs?Bp(s,l)&&(_e="onCompositionEnd"):s==="keydown"&&l.keyCode===229&&(_e="onCompositionStart");_e&&(Lp&&l.locale!=="ko"&&(Xs||_e!=="onCompositionStart"?_e==="onCompositionEnd"&&Xs&&(ze=$p()):(_r=ie,_u="value"in _r?_r.value:_r.textContent,Xs=!0)),De=xa(K,_e),0<De.length&&(_e=new _p(_e,s,null,l,ie),ae.push({event:_e,listeners:De}),ze?_e.data=ze:(ze=Up(l),ze!==null&&(_e.data=ze)))),(ze=US?jS(s,l):WS(s,l))&&(K=xa(K,"onBeforeInput"),0<K.length&&(ie=new _p("onBeforeInput","beforeinput",null,l,ie),ae.push({event:ie,listeners:K}),ie.data=ze))}am(ae,i)})}function lo(s,i,l){return{instance:s,listener:i,currentTarget:l}}function xa(s,i){for(var l=i+"Capture",f=[];s!==null;){var p=s,y=p.stateNode;p.tag===5&&y!==null&&(p=y,y=Wi(s,l),y!=null&&f.unshift(lo(s,y,p)),y=Wi(s,i),y!=null&&f.push(lo(s,y,p))),s=s.return}return f}function Qs(s){if(s===null)return null;do s=s.return;while(s&&s.tag!==5);return s||null}function um(s,i,l,f,p){for(var y=i._reactName,b=[];l!==null&&l!==f;){var C=l,M=C.alternate,K=C.stateNode;if(M!==null&&M===f)break;C.tag===5&&K!==null&&(C=K,p?(M=Wi(l,y),M!=null&&b.unshift(lo(l,M,C))):p||(M=Wi(l,y),M!=null&&b.push(lo(l,M,C)))),l=l.return}b.length!==0&&s.push({event:i,listeners:b})}var rx=/\r\n?/g,sx=/\u0000|\uFFFD/g;function cm(s){return(typeof s=="string"?s:""+s).replace(rx,`
`).replace(sx,"")}function Ea(s,i,l){if(i=cm(i),cm(s)!==i&&l)throw Error(t(425))}function Aa(){}var Zu=null,Qu=null;function ec(s,i){return s==="textarea"||s==="noscript"||typeof i.children=="string"||typeof i.children=="number"||typeof i.dangerouslySetInnerHTML=="object"&&i.dangerouslySetInnerHTML!==null&&i.dangerouslySetInnerHTML.__html!=null}var tc=typeof setTimeout=="function"?setTimeout:void 0,ix=typeof clearTimeout=="function"?clearTimeout:void 0,hm=typeof Promise=="function"?Promise:void 0,ox=typeof queueMicrotask=="function"?queueMicrotask:typeof hm<"u"?function(s){return hm.resolve(null).then(s).catch(ax)}:tc;function ax(s){setTimeout(function(){throw s})}function nc(s,i){var l=i,f=0;do{var p=l.nextSibling;if(s.removeChild(l),p&&p.nodeType===8)if(l=p.data,l==="/$"){if(f===0){s.removeChild(p),Zi(i);return}f--}else l!=="$"&&l!=="$?"&&l!=="$!"||f++;l=p}while(l);Zi(i)}function Lr(s){for(;s!=null;s=s.nextSibling){var i=s.nodeType;if(i===1||i===3)break;if(i===8){if(i=s.data,i==="$"||i==="$!"||i==="$?")break;if(i==="/$")return null}}return s}function fm(s){s=s.previousSibling;for(var i=0;s;){if(s.nodeType===8){var l=s.data;if(l==="$"||l==="$!"||l==="$?"){if(i===0)return s;i--}else l==="/$"&&i++}s=s.previousSibling}return null}var ei=Math.random().toString(36).slice(2),sr="__reactFiber$"+ei,uo="__reactProps$"+ei,br="__reactContainer$"+ei,rc="__reactEvents$"+ei,lx="__reactListeners$"+ei,ux="__reactHandles$"+ei;function ms(s){var i=s[sr];if(i)return i;for(var l=s.parentNode;l;){if(i=l[br]||l[sr]){if(l=i.alternate,i.child!==null||l!==null&&l.child!==null)for(s=fm(s);s!==null;){if(l=s[sr])return l;s=fm(s)}return i}s=l,l=s.parentNode}return null}function co(s){return s=s[sr]||s[br],!s||s.tag!==5&&s.tag!==6&&s.tag!==13&&s.tag!==3?null:s}function ti(s){if(s.tag===5||s.tag===6)return s.stateNode;throw Error(t(33))}function Ia(s){return s[uo]||null}var sc=[],ni=-1;function Or(s){return{current:s}}function st(s){0>ni||(s.current=sc[ni],sc[ni]=null,ni--)}function tt(s,i){ni++,sc[ni]=s.current,s.current=i}var Pr={},Vt=Or(Pr),on=Or(!1),gs=Pr;function ri(s,i){var l=s.type.contextTypes;if(!l)return Pr;var f=s.stateNode;if(f&&f.__reactInternalMemoizedUnmaskedChildContext===i)return f.__reactInternalMemoizedMaskedChildContext;var p={},y;for(y in l)p[y]=i[y];return f&&(s=s.stateNode,s.__reactInternalMemoizedUnmaskedChildContext=i,s.__reactInternalMemoizedMaskedChildContext=p),p}function an(s){return s=s.childContextTypes,s!=null}function Ta(){st(on),st(Vt)}function dm(s,i,l){if(Vt.current!==Pr)throw Error(t(168));tt(Vt,i),tt(on,l)}function pm(s,i,l){var f=s.stateNode;if(i=i.childContextTypes,typeof f.getChildContext!="function")return l;f=f.getChildContext();for(var p in f)if(!(p in i))throw Error(t(108,ue(s)||"Unknown",p));return A({},l,f)}function Na(s){return s=(s=s.stateNode)&&s.__reactInternalMemoizedMergedChildContext||Pr,gs=Vt.current,tt(Vt,s),tt(on,on.current),!0}function mm(s,i,l){var f=s.stateNode;if(!f)throw Error(t(169));l?(s=pm(s,i,gs),f.__reactInternalMemoizedMergedChildContext=s,st(on),st(Vt),tt(Vt,s)):st(on),tt(on,l)}var kr=null,Ca=!1,ic=!1;function gm(s){kr===null?kr=[s]:kr.push(s)}function cx(s){Ca=!0,gm(s)}function Br(){if(!ic&&kr!==null){ic=!0;var s=0,i=Ze;try{var l=kr;for(Ze=1;s<l.length;s++){var f=l[s];do f=f(!0);while(f!==null)}kr=null,Ca=!1}catch(p){throw kr!==null&&(kr=kr.slice(s+1)),vp(Tu,Br),p}finally{Ze=i,ic=!1}}return null}var si=[],ii=0,Da=null,za=0,kn=[],Sn=0,ys=null,Sr=1,xr="";function vs(s,i){si[ii++]=za,si[ii++]=Da,Da=s,za=i}function ym(s,i,l){kn[Sn++]=Sr,kn[Sn++]=xr,kn[Sn++]=ys,ys=s;var f=Sr;s=xr;var p=32-Ln(f)-1;f&=~(1<<p),l+=1;var y=32-Ln(i)+p;if(30<y){var b=p-p%5;y=(f&(1<<b)-1).toString(32),f>>=b,p-=b,Sr=1<<32-Ln(i)+p|l<<p|f,xr=y+s}else Sr=1<<y|l<<p|f,xr=s}function oc(s){s.return!==null&&(vs(s,1),ym(s,1,0))}function ac(s){for(;s===Da;)Da=si[--ii],si[ii]=null,za=si[--ii],si[ii]=null;for(;s===ys;)ys=kn[--Sn],kn[Sn]=null,xr=kn[--Sn],kn[Sn]=null,Sr=kn[--Sn],kn[Sn]=null}var gn=null,yn=null,ct=!1,Pn=null;function vm(s,i){var l=In(5,null,null,0);l.elementType="DELETED",l.stateNode=i,l.return=s,i=s.deletions,i===null?(s.deletions=[l],s.flags|=16):i.push(l)}function wm(s,i){switch(s.tag){case 5:var l=s.type;return i=i.nodeType!==1||l.toLowerCase()!==i.nodeName.toLowerCase()?null:i,i!==null?(s.stateNode=i,gn=s,yn=Lr(i.firstChild),!0):!1;case 6:return i=s.pendingProps===""||i.nodeType!==3?null:i,i!==null?(s.stateNode=i,gn=s,yn=null,!0):!1;case 13:return i=i.nodeType!==8?null:i,i!==null?(l=ys!==null?{id:Sr,overflow:xr}:null,s.memoizedState={dehydrated:i,treeContext:l,retryLane:1073741824},l=In(18,null,null,0),l.stateNode=i,l.return=s,s.child=l,gn=s,yn=null,!0):!1;default:return!1}}function lc(s){return(s.mode&1)!==0&&(s.flags&128)===0}function uc(s){if(ct){var i=yn;if(i){var l=i;if(!wm(s,i)){if(lc(s))throw Error(t(418));i=Lr(l.nextSibling);var f=gn;i&&wm(s,i)?vm(f,l):(s.flags=s.flags&-4097|2,ct=!1,gn=s)}}else{if(lc(s))throw Error(t(418));s.flags=s.flags&-4097|2,ct=!1,gn=s}}}function bm(s){for(s=s.return;s!==null&&s.tag!==5&&s.tag!==3&&s.tag!==13;)s=s.return;gn=s}function $a(s){if(s!==gn)return!1;if(!ct)return bm(s),ct=!0,!1;var i;if((i=s.tag!==3)&&!(i=s.tag!==5)&&(i=s.type,i=i!=="head"&&i!=="body"&&!ec(s.type,s.memoizedProps)),i&&(i=yn)){if(lc(s))throw km(),Error(t(418));for(;i;)vm(s,i),i=Lr(i.nextSibling)}if(bm(s),s.tag===13){if(s=s.memoizedState,s=s!==null?s.dehydrated:null,!s)throw Error(t(317));e:{for(s=s.nextSibling,i=0;s;){if(s.nodeType===8){var l=s.data;if(l==="/$"){if(i===0){yn=Lr(s.nextSibling);break e}i--}else l!=="$"&&l!=="$!"&&l!=="$?"||i++}s=s.nextSibling}yn=null}}else yn=gn?Lr(s.stateNode.nextSibling):null;return!0}function km(){for(var s=yn;s;)s=Lr(s.nextSibling)}function oi(){yn=gn=null,ct=!1}function cc(s){Pn===null?Pn=[s]:Pn.push(s)}var hx=$.ReactCurrentBatchConfig;function Bn(s,i){if(s&&s.defaultProps){i=A({},i),s=s.defaultProps;for(var l in s)i[l]===void 0&&(i[l]=s[l]);return i}return i}var Ma=Or(null),Ra=null,ai=null,hc=null;function fc(){hc=ai=Ra=null}function dc(s){var i=Ma.current;st(Ma),s._currentValue=i}function pc(s,i,l){for(;s!==null;){var f=s.alternate;if((s.childLanes&i)!==i?(s.childLanes|=i,f!==null&&(f.childLanes|=i)):f!==null&&(f.childLanes&i)!==i&&(f.childLanes|=i),s===l)break;s=s.return}}function li(s,i){Ra=s,hc=ai=null,s=s.dependencies,s!==null&&s.firstContext!==null&&((s.lanes&i)!==0&&(ln=!0),s.firstContext=null)}function xn(s){var i=s._currentValue;if(hc!==s)if(s={context:s,memoizedValue:i,next:null},ai===null){if(Ra===null)throw Error(t(308));ai=s,Ra.dependencies={lanes:0,firstContext:s}}else ai=ai.next=s;return i}var ws=null;function mc(s){ws===null?ws=[s]:ws.push(s)}function Sm(s,i,l,f){var p=i.interleaved;return p===null?(l.next=l,mc(i)):(l.next=p.next,p.next=l),i.interleaved=l,Er(s,f)}function Er(s,i){s.lanes|=i;var l=s.alternate;for(l!==null&&(l.lanes|=i),l=s,s=s.return;s!==null;)s.childLanes|=i,l=s.alternate,l!==null&&(l.childLanes|=i),l=s,s=s.return;return l.tag===3?l.stateNode:null}var Ur=!1;function gc(s){s.updateQueue={baseState:s.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:0},effects:null}}function xm(s,i){s=s.updateQueue,i.updateQueue===s&&(i.updateQueue={baseState:s.baseState,firstBaseUpdate:s.firstBaseUpdate,lastBaseUpdate:s.lastBaseUpdate,shared:s.shared,effects:s.effects})}function Ar(s,i){return{eventTime:s,lane:i,tag:0,payload:null,callback:null,next:null}}function jr(s,i,l){var f=s.updateQueue;if(f===null)return null;if(f=f.shared,(Ge&2)!==0){var p=f.pending;return p===null?i.next=i:(i.next=p.next,p.next=i),f.pending=i,Er(s,l)}return p=f.interleaved,p===null?(i.next=i,mc(f)):(i.next=p.next,p.next=i),f.interleaved=i,Er(s,l)}function _a(s,i,l){if(i=i.updateQueue,i!==null&&(i=i.shared,(l&4194240)!==0)){var f=i.lanes;f&=s.pendingLanes,l|=f,i.lanes=l,Du(s,l)}}function Em(s,i){var l=s.updateQueue,f=s.alternate;if(f!==null&&(f=f.updateQueue,l===f)){var p=null,y=null;if(l=l.firstBaseUpdate,l!==null){do{var b={eventTime:l.eventTime,lane:l.lane,tag:l.tag,payload:l.payload,callback:l.callback,next:null};y===null?p=y=b:y=y.next=b,l=l.next}while(l!==null);y===null?p=y=i:y=y.next=i}else p=y=i;l={baseState:f.baseState,firstBaseUpdate:p,lastBaseUpdate:y,shared:f.shared,effects:f.effects},s.updateQueue=l;return}s=l.lastBaseUpdate,s===null?l.firstBaseUpdate=i:s.next=i,l.lastBaseUpdate=i}function Fa(s,i,l,f){var p=s.updateQueue;Ur=!1;var y=p.firstBaseUpdate,b=p.lastBaseUpdate,C=p.shared.pending;if(C!==null){p.shared.pending=null;var M=C,K=M.next;M.next=null,b===null?y=K:b.next=K,b=M;var ie=s.alternate;ie!==null&&(ie=ie.updateQueue,C=ie.lastBaseUpdate,C!==b&&(C===null?ie.firstBaseUpdate=K:C.next=K,ie.lastBaseUpdate=M))}if(y!==null){var ae=p.baseState;b=0,ie=K=M=null,C=y;do{var se=C.lane,ye=C.eventTime;if((f&se)===se){ie!==null&&(ie=ie.next={eventTime:ye,lane:0,tag:C.tag,payload:C.payload,callback:C.callback,next:null});e:{var xe=s,Ae=C;switch(se=i,ye=l,Ae.tag){case 1:if(xe=Ae.payload,typeof xe=="function"){ae=xe.call(ye,ae,se);break e}ae=xe;break e;case 3:xe.flags=xe.flags&-65537|128;case 0:if(xe=Ae.payload,se=typeof xe=="function"?xe.call(ye,ae,se):xe,se==null)break e;ae=A({},ae,se);break e;case 2:Ur=!0}}C.callback!==null&&C.lane!==0&&(s.flags|=64,se=p.effects,se===null?p.effects=[C]:se.push(C))}else ye={eventTime:ye,lane:se,tag:C.tag,payload:C.payload,callback:C.callback,next:null},ie===null?(K=ie=ye,M=ae):ie=ie.next=ye,b|=se;if(C=C.next,C===null){if(C=p.shared.pending,C===null)break;se=C,C=se.next,se.next=null,p.lastBaseUpdate=se,p.shared.pending=null}}while(!0);if(ie===null&&(M=ae),p.baseState=M,p.firstBaseUpdate=K,p.lastBaseUpdate=ie,i=p.shared.interleaved,i!==null){p=i;do b|=p.lane,p=p.next;while(p!==i)}else y===null&&(p.shared.lanes=0);Ss|=b,s.lanes=b,s.memoizedState=ae}}function Am(s,i,l){if(s=i.effects,i.effects=null,s!==null)for(i=0;i<s.length;i++){var f=s[i],p=f.callback;if(p!==null){if(f.callback=null,f=l,typeof p!="function")throw Error(t(191,p));p.call(f)}}}var Im=new n.Component().refs;function yc(s,i,l,f){i=s.memoizedState,l=l(f,i),l=l==null?i:A({},i,l),s.memoizedState=l,s.lanes===0&&(s.updateQueue.baseState=l)}var La={isMounted:function(s){return(s=s._reactInternals)?ps(s)===s:!1},enqueueSetState:function(s,i,l){s=s._reactInternals;var f=Yt(),p=qr(s),y=Ar(f,p);y.payload=i,l!=null&&(y.callback=l),i=jr(s,y,p),i!==null&&(Wn(i,s,p,f),_a(i,s,p))},enqueueReplaceState:function(s,i,l){s=s._reactInternals;var f=Yt(),p=qr(s),y=Ar(f,p);y.tag=1,y.payload=i,l!=null&&(y.callback=l),i=jr(s,y,p),i!==null&&(Wn(i,s,p,f),_a(i,s,p))},enqueueForceUpdate:function(s,i){s=s._reactInternals;var l=Yt(),f=qr(s),p=Ar(l,f);p.tag=2,i!=null&&(p.callback=i),i=jr(s,p,f),i!==null&&(Wn(i,s,f,l),_a(i,s,f))}};function Tm(s,i,l,f,p,y,b){return s=s.stateNode,typeof s.shouldComponentUpdate=="function"?s.shouldComponentUpdate(f,y,b):i.prototype&&i.prototype.isPureReactComponent?!so(l,f)||!so(p,y):!0}function Nm(s,i,l){var f=!1,p=Pr,y=i.contextType;return typeof y=="object"&&y!==null?y=xn(y):(p=an(i)?gs:Vt.current,f=i.contextTypes,y=(f=f!=null)?ri(s,p):Pr),i=new i(l,y),s.memoizedState=i.state!==null&&i.state!==void 0?i.state:null,i.updater=La,s.stateNode=i,i._reactInternals=s,f&&(s=s.stateNode,s.__reactInternalMemoizedUnmaskedChildContext=p,s.__reactInternalMemoizedMaskedChildContext=y),i}function Cm(s,i,l,f){s=i.state,typeof i.componentWillReceiveProps=="function"&&i.componentWillReceiveProps(l,f),typeof i.UNSAFE_componentWillReceiveProps=="function"&&i.UNSAFE_componentWillReceiveProps(l,f),i.state!==s&&La.enqueueReplaceState(i,i.state,null)}function vc(s,i,l,f){var p=s.stateNode;p.props=l,p.state=s.memoizedState,p.refs=Im,gc(s);var y=i.contextType;typeof y=="object"&&y!==null?p.context=xn(y):(y=an(i)?gs:Vt.current,p.context=ri(s,y)),p.state=s.memoizedState,y=i.getDerivedStateFromProps,typeof y=="function"&&(yc(s,i,y,l),p.state=s.memoizedState),typeof i.getDerivedStateFromProps=="function"||typeof p.getSnapshotBeforeUpdate=="function"||typeof p.UNSAFE_componentWillMount!="function"&&typeof p.componentWillMount!="function"||(i=p.state,typeof p.componentWillMount=="function"&&p.componentWillMount(),typeof p.UNSAFE_componentWillMount=="function"&&p.UNSAFE_componentWillMount(),i!==p.state&&La.enqueueReplaceState(p,p.state,null),Fa(s,l,p,f),p.state=s.memoizedState),typeof p.componentDidMount=="function"&&(s.flags|=4194308)}function ho(s,i,l){if(s=l.ref,s!==null&&typeof s!="function"&&typeof s!="object"){if(l._owner){if(l=l._owner,l){if(l.tag!==1)throw Error(t(309));var f=l.stateNode}if(!f)throw Error(t(147,s));var p=f,y=""+s;return i!==null&&i.ref!==null&&typeof i.ref=="function"&&i.ref._stringRef===y?i.ref:(i=function(b){var C=p.refs;C===Im&&(C=p.refs={}),b===null?delete C[y]:C[y]=b},i._stringRef=y,i)}if(typeof s!="string")throw Error(t(284));if(!l._owner)throw Error(t(290,s))}return s}function Oa(s,i){throw s=Object.prototype.toString.call(i),Error(t(31,s==="[object Object]"?"object with keys {"+Object.keys(i).join(", ")+"}":s))}function Dm(s){var i=s._init;return i(s._payload)}function zm(s){function i(j,L){if(s){var q=j.deletions;q===null?(j.deletions=[L],j.flags|=16):q.push(L)}}function l(j,L){if(!s)return null;for(;L!==null;)i(j,L),L=L.sibling;return null}function f(j,L){for(j=new Map;L!==null;)L.key!==null?j.set(L.key,L):j.set(L.index,L),L=L.sibling;return j}function p(j,L){return j=Kr(j,L),j.index=0,j.sibling=null,j}function y(j,L,q){return j.index=q,s?(q=j.alternate,q!==null?(q=q.index,q<L?(j.flags|=2,L):q):(j.flags|=2,L)):(j.flags|=1048576,L)}function b(j){return s&&j.alternate===null&&(j.flags|=2),j}function C(j,L,q,he){return L===null||L.tag!==6?(L=th(q,j.mode,he),L.return=j,L):(L=p(L,q),L.return=j,L)}function M(j,L,q,he){var Te=q.type;return Te===Y?ie(j,L,q.props.children,he,q.key):L!==null&&(L.elementType===Te||typeof Te=="object"&&Te!==null&&Te.$$typeof===Ie&&Dm(Te)===L.type)?(he=p(L,q.props),he.ref=ho(j,L,q),he.return=j,he):(he=rl(q.type,q.key,q.props,null,j.mode,he),he.ref=ho(j,L,q),he.return=j,he)}function K(j,L,q,he){return L===null||L.tag!==4||L.stateNode.containerInfo!==q.containerInfo||L.stateNode.implementation!==q.implementation?(L=nh(q,j.mode,he),L.return=j,L):(L=p(L,q.children||[]),L.return=j,L)}function ie(j,L,q,he,Te){return L===null||L.tag!==7?(L=Is(q,j.mode,he,Te),L.return=j,L):(L=p(L,q),L.return=j,L)}function ae(j,L,q){if(typeof L=="string"&&L!==""||typeof L=="number")return L=th(""+L,j.mode,q),L.return=j,L;if(typeof L=="object"&&L!==null){switch(L.$$typeof){case B:return q=rl(L.type,L.key,L.props,null,j.mode,q),q.ref=ho(j,null,L),q.return=j,q;case H:return L=nh(L,j.mode,q),L.return=j,L;case Ie:var he=L._init;return ae(j,he(L._payload),q)}if(Jt(L)||I(L))return L=Is(L,j.mode,q,null),L.return=j,L;Oa(j,L)}return null}function se(j,L,q,he){var Te=L!==null?L.key:null;if(typeof q=="string"&&q!==""||typeof q=="number")return Te!==null?null:C(j,L,""+q,he);if(typeof q=="object"&&q!==null){switch(q.$$typeof){case B:return q.key===Te?M(j,L,q,he):null;case H:return q.key===Te?K(j,L,q,he):null;case Ie:return Te=q._init,se(j,L,Te(q._payload),he)}if(Jt(q)||I(q))return Te!==null?null:ie(j,L,q,he,null);Oa(j,q)}return null}function ye(j,L,q,he,Te){if(typeof he=="string"&&he!==""||typeof he=="number")return j=j.get(q)||null,C(L,j,""+he,Te);if(typeof he=="object"&&he!==null){switch(he.$$typeof){case B:return j=j.get(he.key===null?q:he.key)||null,M(L,j,he,Te);case H:return j=j.get(he.key===null?q:he.key)||null,K(L,j,he,Te);case Ie:var De=he._init;return ye(j,L,q,De(he._payload),Te)}if(Jt(he)||I(he))return j=j.get(q)||null,ie(L,j,he,Te,null);Oa(L,he)}return null}function xe(j,L,q,he){for(var Te=null,De=null,ze=L,_e=L=0,Lt=null;ze!==null&&_e<q.length;_e++){ze.index>_e?(Lt=ze,ze=null):Lt=ze.sibling;var qe=se(j,ze,q[_e],he);if(qe===null){ze===null&&(ze=Lt);break}s&&ze&&qe.alternate===null&&i(j,ze),L=y(qe,L,_e),De===null?Te=qe:De.sibling=qe,De=qe,ze=Lt}if(_e===q.length)return l(j,ze),ct&&vs(j,_e),Te;if(ze===null){for(;_e<q.length;_e++)ze=ae(j,q[_e],he),ze!==null&&(L=y(ze,L,_e),De===null?Te=ze:De.sibling=ze,De=ze);return ct&&vs(j,_e),Te}for(ze=f(j,ze);_e<q.length;_e++)Lt=ye(ze,j,_e,q[_e],he),Lt!==null&&(s&&Lt.alternate!==null&&ze.delete(Lt.key===null?_e:Lt.key),L=y(Lt,L,_e),De===null?Te=Lt:De.sibling=Lt,De=Lt);return s&&ze.forEach(function(Jr){return i(j,Jr)}),ct&&vs(j,_e),Te}function Ae(j,L,q,he){var Te=I(q);if(typeof Te!="function")throw Error(t(150));if(q=Te.call(q),q==null)throw Error(t(151));for(var De=Te=null,ze=L,_e=L=0,Lt=null,qe=q.next();ze!==null&&!qe.done;_e++,qe=q.next()){ze.index>_e?(Lt=ze,ze=null):Lt=ze.sibling;var Jr=se(j,ze,qe.value,he);if(Jr===null){ze===null&&(ze=Lt);break}s&&ze&&Jr.alternate===null&&i(j,ze),L=y(Jr,L,_e),De===null?Te=Jr:De.sibling=Jr,De=Jr,ze=Lt}if(qe.done)return l(j,ze),ct&&vs(j,_e),Te;if(ze===null){for(;!qe.done;_e++,qe=q.next())qe=ae(j,qe.value,he),qe!==null&&(L=y(qe,L,_e),De===null?Te=qe:De.sibling=qe,De=qe);return ct&&vs(j,_e),Te}for(ze=f(j,ze);!qe.done;_e++,qe=q.next())qe=ye(ze,j,_e,qe.value,he),qe!==null&&(s&&qe.alternate!==null&&ze.delete(qe.key===null?_e:qe.key),L=y(qe,L,_e),De===null?Te=qe:De.sibling=qe,De=qe);return s&&ze.forEach(function(Vx){return i(j,Vx)}),ct&&vs(j,_e),Te}function kt(j,L,q,he){if(typeof q=="object"&&q!==null&&q.type===Y&&q.key===null&&(q=q.props.children),typeof q=="object"&&q!==null){switch(q.$$typeof){case B:e:{for(var Te=q.key,De=L;De!==null;){if(De.key===Te){if(Te=q.type,Te===Y){if(De.tag===7){l(j,De.sibling),L=p(De,q.props.children),L.return=j,j=L;break e}}else if(De.elementType===Te||typeof Te=="object"&&Te!==null&&Te.$$typeof===Ie&&Dm(Te)===De.type){l(j,De.sibling),L=p(De,q.props),L.ref=ho(j,De,q),L.return=j,j=L;break e}l(j,De);break}else i(j,De);De=De.sibling}q.type===Y?(L=Is(q.props.children,j.mode,he,q.key),L.return=j,j=L):(he=rl(q.type,q.key,q.props,null,j.mode,he),he.ref=ho(j,L,q),he.return=j,j=he)}return b(j);case H:e:{for(De=q.key;L!==null;){if(L.key===De)if(L.tag===4&&L.stateNode.containerInfo===q.containerInfo&&L.stateNode.implementation===q.implementation){l(j,L.sibling),L=p(L,q.children||[]),L.return=j,j=L;break e}else{l(j,L);break}else i(j,L);L=L.sibling}L=nh(q,j.mode,he),L.return=j,j=L}return b(j);case Ie:return De=q._init,kt(j,L,De(q._payload),he)}if(Jt(q))return xe(j,L,q,he);if(I(q))return Ae(j,L,q,he);Oa(j,q)}return typeof q=="string"&&q!==""||typeof q=="number"?(q=""+q,L!==null&&L.tag===6?(l(j,L.sibling),L=p(L,q),L.return=j,j=L):(l(j,L),L=th(q,j.mode,he),L.return=j,j=L),b(j)):l(j,L)}return kt}var ui=zm(!0),$m=zm(!1),fo={},ir=Or(fo),po=Or(fo),mo=Or(fo);function bs(s){if(s===fo)throw Error(t(174));return s}function wc(s,i){switch(tt(mo,i),tt(po,s),tt(ir,fo),s=i.nodeType,s){case 9:case 11:i=(i=i.documentElement)?i.namespaceURI:Vs(null,"");break;default:s=s===8?i.parentNode:i,i=s.namespaceURI||null,s=s.tagName,i=Vs(i,s)}st(ir),tt(ir,i)}function ci(){st(ir),st(po),st(mo)}function Mm(s){bs(mo.current);var i=bs(ir.current),l=Vs(i,s.type);i!==l&&(tt(po,s),tt(ir,l))}function bc(s){po.current===s&&(st(ir),st(po))}var pt=Or(0);function Pa(s){for(var i=s;i!==null;){if(i.tag===13){var l=i.memoizedState;if(l!==null&&(l=l.dehydrated,l===null||l.data==="$?"||l.data==="$!"))return i}else if(i.tag===19&&i.memoizedProps.revealOrder!==void 0){if((i.flags&128)!==0)return i}else if(i.child!==null){i.child.return=i,i=i.child;continue}if(i===s)break;for(;i.sibling===null;){if(i.return===null||i.return===s)return null;i=i.return}i.sibling.return=i.return,i=i.sibling}return null}var kc=[];function Sc(){for(var s=0;s<kc.length;s++)kc[s]._workInProgressVersionPrimary=null;kc.length=0}var Ba=$.ReactCurrentDispatcher,xc=$.ReactCurrentBatchConfig,ks=0,mt=null,Dt=null,_t=null,Ua=!1,go=!1,yo=0,fx=0;function Gt(){throw Error(t(321))}function Ec(s,i){if(i===null)return!1;for(var l=0;l<i.length&&l<s.length;l++)if(!On(s[l],i[l]))return!1;return!0}function Ac(s,i,l,f,p,y){if(ks=y,mt=i,i.memoizedState=null,i.updateQueue=null,i.lanes=0,Ba.current=s===null||s.memoizedState===null?gx:yx,s=l(f,p),go){y=0;do{if(go=!1,yo=0,25<=y)throw Error(t(301));y+=1,_t=Dt=null,i.updateQueue=null,Ba.current=vx,s=l(f,p)}while(go)}if(Ba.current=Va,i=Dt!==null&&Dt.next!==null,ks=0,_t=Dt=mt=null,Ua=!1,i)throw Error(t(300));return s}function Ic(){var s=yo!==0;return yo=0,s}function or(){var s={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return _t===null?mt.memoizedState=_t=s:_t=_t.next=s,_t}function En(){if(Dt===null){var s=mt.alternate;s=s!==null?s.memoizedState:null}else s=Dt.next;var i=_t===null?mt.memoizedState:_t.next;if(i!==null)_t=i,Dt=s;else{if(s===null)throw Error(t(310));Dt=s,s={memoizedState:Dt.memoizedState,baseState:Dt.baseState,baseQueue:Dt.baseQueue,queue:Dt.queue,next:null},_t===null?mt.memoizedState=_t=s:_t=_t.next=s}return _t}function vo(s,i){return typeof i=="function"?i(s):i}function Tc(s){var i=En(),l=i.queue;if(l===null)throw Error(t(311));l.lastRenderedReducer=s;var f=Dt,p=f.baseQueue,y=l.pending;if(y!==null){if(p!==null){var b=p.next;p.next=y.next,y.next=b}f.baseQueue=p=y,l.pending=null}if(p!==null){y=p.next,f=f.baseState;var C=b=null,M=null,K=y;do{var ie=K.lane;if((ks&ie)===ie)M!==null&&(M=M.next={lane:0,action:K.action,hasEagerState:K.hasEagerState,eagerState:K.eagerState,next:null}),f=K.hasEagerState?K.eagerState:s(f,K.action);else{var ae={lane:ie,action:K.action,hasEagerState:K.hasEagerState,eagerState:K.eagerState,next:null};M===null?(C=M=ae,b=f):M=M.next=ae,mt.lanes|=ie,Ss|=ie}K=K.next}while(K!==null&&K!==y);M===null?b=f:M.next=C,On(f,i.memoizedState)||(ln=!0),i.memoizedState=f,i.baseState=b,i.baseQueue=M,l.lastRenderedState=f}if(s=l.interleaved,s!==null){p=s;do y=p.lane,mt.lanes|=y,Ss|=y,p=p.next;while(p!==s)}else p===null&&(l.lanes=0);return[i.memoizedState,l.dispatch]}function Nc(s){var i=En(),l=i.queue;if(l===null)throw Error(t(311));l.lastRenderedReducer=s;var f=l.dispatch,p=l.pending,y=i.memoizedState;if(p!==null){l.pending=null;var b=p=p.next;do y=s(y,b.action),b=b.next;while(b!==p);On(y,i.memoizedState)||(ln=!0),i.memoizedState=y,i.baseQueue===null&&(i.baseState=y),l.lastRenderedState=y}return[y,f]}function Rm(){}function _m(s,i){var l=mt,f=En(),p=i(),y=!On(f.memoizedState,p);if(y&&(f.memoizedState=p,ln=!0),f=f.queue,Cc(Om.bind(null,l,f,s),[s]),f.getSnapshot!==i||y||_t!==null&&_t.memoizedState.tag&1){if(l.flags|=2048,wo(9,Lm.bind(null,l,f,p,i),void 0,null),Ft===null)throw Error(t(349));(ks&30)!==0||Fm(l,i,p)}return p}function Fm(s,i,l){s.flags|=16384,s={getSnapshot:i,value:l},i=mt.updateQueue,i===null?(i={lastEffect:null,stores:null},mt.updateQueue=i,i.stores=[s]):(l=i.stores,l===null?i.stores=[s]:l.push(s))}function Lm(s,i,l,f){i.value=l,i.getSnapshot=f,Pm(i)&&Bm(s)}function Om(s,i,l){return l(function(){Pm(i)&&Bm(s)})}function Pm(s){var i=s.getSnapshot;s=s.value;try{var l=i();return!On(s,l)}catch{return!0}}function Bm(s){var i=Er(s,1);i!==null&&Wn(i,s,1,-1)}function Um(s){var i=or();return typeof s=="function"&&(s=s()),i.memoizedState=i.baseState=s,s={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:vo,lastRenderedState:s},i.queue=s,s=s.dispatch=mx.bind(null,mt,s),[i.memoizedState,s]}function wo(s,i,l,f){return s={tag:s,create:i,destroy:l,deps:f,next:null},i=mt.updateQueue,i===null?(i={lastEffect:null,stores:null},mt.updateQueue=i,i.lastEffect=s.next=s):(l=i.lastEffect,l===null?i.lastEffect=s.next=s:(f=l.next,l.next=s,s.next=f,i.lastEffect=s)),s}function jm(){return En().memoizedState}function ja(s,i,l,f){var p=or();mt.flags|=s,p.memoizedState=wo(1|i,l,void 0,f===void 0?null:f)}function Wa(s,i,l,f){var p=En();f=f===void 0?null:f;var y=void 0;if(Dt!==null){var b=Dt.memoizedState;if(y=b.destroy,f!==null&&Ec(f,b.deps)){p.memoizedState=wo(i,l,y,f);return}}mt.flags|=s,p.memoizedState=wo(1|i,l,y,f)}function Wm(s,i){return ja(8390656,8,s,i)}function Cc(s,i){return Wa(2048,8,s,i)}function Vm(s,i){return Wa(4,2,s,i)}function Gm(s,i){return Wa(4,4,s,i)}function qm(s,i){if(typeof i=="function")return s=s(),i(s),function(){i(null)};if(i!=null)return s=s(),i.current=s,function(){i.current=null}}function Hm(s,i,l){return l=l!=null?l.concat([s]):null,Wa(4,4,qm.bind(null,i,s),l)}function Dc(){}function Km(s,i){var l=En();i=i===void 0?null:i;var f=l.memoizedState;return f!==null&&i!==null&&Ec(i,f[1])?f[0]:(l.memoizedState=[s,i],s)}function Jm(s,i){var l=En();i=i===void 0?null:i;var f=l.memoizedState;return f!==null&&i!==null&&Ec(i,f[1])?f[0]:(s=s(),l.memoizedState=[s,i],s)}function Xm(s,i,l){return(ks&21)===0?(s.baseState&&(s.baseState=!1,ln=!0),s.memoizedState=l):(On(l,i)||(l=Sp(),mt.lanes|=l,Ss|=l,s.baseState=!0),i)}function dx(s,i){var l=Ze;Ze=l!==0&&4>l?l:4,s(!0);var f=xc.transition;xc.transition={};try{s(!1),i()}finally{Ze=l,xc.transition=f}}function Ym(){return En().memoizedState}function px(s,i,l){var f=qr(s);if(l={lane:f,action:l,hasEagerState:!1,eagerState:null,next:null},Zm(s))Qm(i,l);else if(l=Sm(s,i,l,f),l!==null){var p=Yt();Wn(l,s,f,p),eg(l,i,f)}}function mx(s,i,l){var f=qr(s),p={lane:f,action:l,hasEagerState:!1,eagerState:null,next:null};if(Zm(s))Qm(i,p);else{var y=s.alternate;if(s.lanes===0&&(y===null||y.lanes===0)&&(y=i.lastRenderedReducer,y!==null))try{var b=i.lastRenderedState,C=y(b,l);if(p.hasEagerState=!0,p.eagerState=C,On(C,b)){var M=i.interleaved;M===null?(p.next=p,mc(i)):(p.next=M.next,M.next=p),i.interleaved=p;return}}catch{}l=Sm(s,i,p,f),l!==null&&(p=Yt(),Wn(l,s,f,p),eg(l,i,f))}}function Zm(s){var i=s.alternate;return s===mt||i!==null&&i===mt}function Qm(s,i){go=Ua=!0;var l=s.pending;l===null?i.next=i:(i.next=l.next,l.next=i),s.pending=i}function eg(s,i,l){if((l&4194240)!==0){var f=i.lanes;f&=s.pendingLanes,l|=f,i.lanes=l,Du(s,l)}}var Va={readContext:xn,useCallback:Gt,useContext:Gt,useEffect:Gt,useImperativeHandle:Gt,useInsertionEffect:Gt,useLayoutEffect:Gt,useMemo:Gt,useReducer:Gt,useRef:Gt,useState:Gt,useDebugValue:Gt,useDeferredValue:Gt,useTransition:Gt,useMutableSource:Gt,useSyncExternalStore:Gt,useId:Gt,unstable_isNewReconciler:!1},gx={readContext:xn,useCallback:function(s,i){return or().memoizedState=[s,i===void 0?null:i],s},useContext:xn,useEffect:Wm,useImperativeHandle:function(s,i,l){return l=l!=null?l.concat([s]):null,ja(4194308,4,qm.bind(null,i,s),l)},useLayoutEffect:function(s,i){return ja(4194308,4,s,i)},useInsertionEffect:function(s,i){return ja(4,2,s,i)},useMemo:function(s,i){var l=or();return i=i===void 0?null:i,s=s(),l.memoizedState=[s,i],s},useReducer:function(s,i,l){var f=or();return i=l!==void 0?l(i):i,f.memoizedState=f.baseState=i,s={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:s,lastRenderedState:i},f.queue=s,s=s.dispatch=px.bind(null,mt,s),[f.memoizedState,s]},useRef:function(s){var i=or();return s={current:s},i.memoizedState=s},useState:Um,useDebugValue:Dc,useDeferredValue:function(s){return or().memoizedState=s},useTransition:function(){var s=Um(!1),i=s[0];return s=dx.bind(null,s[1]),or().memoizedState=s,[i,s]},useMutableSource:function(){},useSyncExternalStore:function(s,i,l){var f=mt,p=or();if(ct){if(l===void 0)throw Error(t(407));l=l()}else{if(l=i(),Ft===null)throw Error(t(349));(ks&30)!==0||Fm(f,i,l)}p.memoizedState=l;var y={value:l,getSnapshot:i};return p.queue=y,Wm(Om.bind(null,f,y,s),[s]),f.flags|=2048,wo(9,Lm.bind(null,f,y,l,i),void 0,null),l},useId:function(){var s=or(),i=Ft.identifierPrefix;if(ct){var l=xr,f=Sr;l=(f&~(1<<32-Ln(f)-1)).toString(32)+l,i=":"+i+"R"+l,l=yo++,0<l&&(i+="H"+l.toString(32)),i+=":"}else l=fx++,i=":"+i+"r"+l.toString(32)+":";return s.memoizedState=i},unstable_isNewReconciler:!1},yx={readContext:xn,useCallback:Km,useContext:xn,useEffect:Cc,useImperativeHandle:Hm,useInsertionEffect:Vm,useLayoutEffect:Gm,useMemo:Jm,useReducer:Tc,useRef:jm,useState:function(){return Tc(vo)},useDebugValue:Dc,useDeferredValue:function(s){var i=En();return Xm(i,Dt.memoizedState,s)},useTransition:function(){var s=Tc(vo)[0],i=En().memoizedState;return[s,i]},useMutableSource:Rm,useSyncExternalStore:_m,useId:Ym,unstable_isNewReconciler:!1},vx={readContext:xn,useCallback:Km,useContext:xn,useEffect:Cc,useImperativeHandle:Hm,useInsertionEffect:Vm,useLayoutEffect:Gm,useMemo:Jm,useReducer:Nc,useRef:jm,useState:function(){return Nc(vo)},useDebugValue:Dc,useDeferredValue:function(s){var i=En();return Dt===null?i.memoizedState=s:Xm(i,Dt.memoizedState,s)},useTransition:function(){var s=Nc(vo)[0],i=En().memoizedState;return[s,i]},useMutableSource:Rm,useSyncExternalStore:_m,useId:Ym,unstable_isNewReconciler:!1};function hi(s,i){try{var l="",f=i;do l+=U(f),f=f.return;while(f);var p=l}catch(y){p=`
Error generating stack: `+y.message+`
`+y.stack}return{value:s,source:i,stack:p,digest:null}}function zc(s,i,l){return{value:s,source:null,stack:l??null,digest:i??null}}function $c(s,i){try{console.error(i.value)}catch(l){setTimeout(function(){throw l})}}var wx=typeof WeakMap=="function"?WeakMap:Map;function tg(s,i,l){l=Ar(-1,l),l.tag=3,l.payload={element:null};var f=i.value;return l.callback=function(){Ya||(Ya=!0,Hc=f),$c(s,i)},l}function ng(s,i,l){l=Ar(-1,l),l.tag=3;var f=s.type.getDerivedStateFromError;if(typeof f=="function"){var p=i.value;l.payload=function(){return f(p)},l.callback=function(){$c(s,i)}}var y=s.stateNode;return y!==null&&typeof y.componentDidCatch=="function"&&(l.callback=function(){$c(s,i),typeof f!="function"&&(Vr===null?Vr=new Set([this]):Vr.add(this));var b=i.stack;this.componentDidCatch(i.value,{componentStack:b!==null?b:""})}),l}function rg(s,i,l){var f=s.pingCache;if(f===null){f=s.pingCache=new wx;var p=new Set;f.set(i,p)}else p=f.get(i),p===void 0&&(p=new Set,f.set(i,p));p.has(l)||(p.add(l),s=Mx.bind(null,s,i,l),i.then(s,s))}function sg(s){do{var i;if((i=s.tag===13)&&(i=s.memoizedState,i=i!==null?i.dehydrated!==null:!0),i)return s;s=s.return}while(s!==null);return null}function ig(s,i,l,f,p){return(s.mode&1)===0?(s===i?s.flags|=65536:(s.flags|=128,l.flags|=131072,l.flags&=-52805,l.tag===1&&(l.alternate===null?l.tag=17:(i=Ar(-1,1),i.tag=2,jr(l,i,1))),l.lanes|=1),s):(s.flags|=65536,s.lanes=p,s)}var bx=$.ReactCurrentOwner,ln=!1;function Xt(s,i,l,f){i.child=s===null?$m(i,null,l,f):ui(i,s.child,l,f)}function og(s,i,l,f,p){l=l.render;var y=i.ref;return li(i,p),f=Ac(s,i,l,f,y,p),l=Ic(),s!==null&&!ln?(i.updateQueue=s.updateQueue,i.flags&=-2053,s.lanes&=~p,Ir(s,i,p)):(ct&&l&&oc(i),i.flags|=1,Xt(s,i,f,p),i.child)}function ag(s,i,l,f,p){if(s===null){var y=l.type;return typeof y=="function"&&!eh(y)&&y.defaultProps===void 0&&l.compare===null&&l.defaultProps===void 0?(i.tag=15,i.type=y,lg(s,i,y,f,p)):(s=rl(l.type,null,f,i,i.mode,p),s.ref=i.ref,s.return=i,i.child=s)}if(y=s.child,(s.lanes&p)===0){var b=y.memoizedProps;if(l=l.compare,l=l!==null?l:so,l(b,f)&&s.ref===i.ref)return Ir(s,i,p)}return i.flags|=1,s=Kr(y,f),s.ref=i.ref,s.return=i,i.child=s}function lg(s,i,l,f,p){if(s!==null){var y=s.memoizedProps;if(so(y,f)&&s.ref===i.ref)if(ln=!1,i.pendingProps=f=y,(s.lanes&p)!==0)(s.flags&131072)!==0&&(ln=!0);else return i.lanes=s.lanes,Ir(s,i,p)}return Mc(s,i,l,f,p)}function ug(s,i,l){var f=i.pendingProps,p=f.children,y=s!==null?s.memoizedState:null;if(f.mode==="hidden")if((i.mode&1)===0)i.memoizedState={baseLanes:0,cachePool:null,transitions:null},tt(di,vn),vn|=l;else{if((l&1073741824)===0)return s=y!==null?y.baseLanes|l:l,i.lanes=i.childLanes=1073741824,i.memoizedState={baseLanes:s,cachePool:null,transitions:null},i.updateQueue=null,tt(di,vn),vn|=s,null;i.memoizedState={baseLanes:0,cachePool:null,transitions:null},f=y!==null?y.baseLanes:l,tt(di,vn),vn|=f}else y!==null?(f=y.baseLanes|l,i.memoizedState=null):f=l,tt(di,vn),vn|=f;return Xt(s,i,p,l),i.child}function cg(s,i){var l=i.ref;(s===null&&l!==null||s!==null&&s.ref!==l)&&(i.flags|=512,i.flags|=2097152)}function Mc(s,i,l,f,p){var y=an(l)?gs:Vt.current;return y=ri(i,y),li(i,p),l=Ac(s,i,l,f,y,p),f=Ic(),s!==null&&!ln?(i.updateQueue=s.updateQueue,i.flags&=-2053,s.lanes&=~p,Ir(s,i,p)):(ct&&f&&oc(i),i.flags|=1,Xt(s,i,l,p),i.child)}function hg(s,i,l,f,p){if(an(l)){var y=!0;Na(i)}else y=!1;if(li(i,p),i.stateNode===null)qa(s,i),Nm(i,l,f),vc(i,l,f,p),f=!0;else if(s===null){var b=i.stateNode,C=i.memoizedProps;b.props=C;var M=b.context,K=l.contextType;typeof K=="object"&&K!==null?K=xn(K):(K=an(l)?gs:Vt.current,K=ri(i,K));var ie=l.getDerivedStateFromProps,ae=typeof ie=="function"||typeof b.getSnapshotBeforeUpdate=="function";ae||typeof b.UNSAFE_componentWillReceiveProps!="function"&&typeof b.componentWillReceiveProps!="function"||(C!==f||M!==K)&&Cm(i,b,f,K),Ur=!1;var se=i.memoizedState;b.state=se,Fa(i,f,b,p),M=i.memoizedState,C!==f||se!==M||on.current||Ur?(typeof ie=="function"&&(yc(i,l,ie,f),M=i.memoizedState),(C=Ur||Tm(i,l,C,f,se,M,K))?(ae||typeof b.UNSAFE_componentWillMount!="function"&&typeof b.componentWillMount!="function"||(typeof b.componentWillMount=="function"&&b.componentWillMount(),typeof b.UNSAFE_componentWillMount=="function"&&b.UNSAFE_componentWillMount()),typeof b.componentDidMount=="function"&&(i.flags|=4194308)):(typeof b.componentDidMount=="function"&&(i.flags|=4194308),i.memoizedProps=f,i.memoizedState=M),b.props=f,b.state=M,b.context=K,f=C):(typeof b.componentDidMount=="function"&&(i.flags|=4194308),f=!1)}else{b=i.stateNode,xm(s,i),C=i.memoizedProps,K=i.type===i.elementType?C:Bn(i.type,C),b.props=K,ae=i.pendingProps,se=b.context,M=l.contextType,typeof M=="object"&&M!==null?M=xn(M):(M=an(l)?gs:Vt.current,M=ri(i,M));var ye=l.getDerivedStateFromProps;(ie=typeof ye=="function"||typeof b.getSnapshotBeforeUpdate=="function")||typeof b.UNSAFE_componentWillReceiveProps!="function"&&typeof b.componentWillReceiveProps!="function"||(C!==ae||se!==M)&&Cm(i,b,f,M),Ur=!1,se=i.memoizedState,b.state=se,Fa(i,f,b,p);var xe=i.memoizedState;C!==ae||se!==xe||on.current||Ur?(typeof ye=="function"&&(yc(i,l,ye,f),xe=i.memoizedState),(K=Ur||Tm(i,l,K,f,se,xe,M)||!1)?(ie||typeof b.UNSAFE_componentWillUpdate!="function"&&typeof b.componentWillUpdate!="function"||(typeof b.componentWillUpdate=="function"&&b.componentWillUpdate(f,xe,M),typeof b.UNSAFE_componentWillUpdate=="function"&&b.UNSAFE_componentWillUpdate(f,xe,M)),typeof b.componentDidUpdate=="function"&&(i.flags|=4),typeof b.getSnapshotBeforeUpdate=="function"&&(i.flags|=1024)):(typeof b.componentDidUpdate!="function"||C===s.memoizedProps&&se===s.memoizedState||(i.flags|=4),typeof b.getSnapshotBeforeUpdate!="function"||C===s.memoizedProps&&se===s.memoizedState||(i.flags|=1024),i.memoizedProps=f,i.memoizedState=xe),b.props=f,b.state=xe,b.context=M,f=K):(typeof b.componentDidUpdate!="function"||C===s.memoizedProps&&se===s.memoizedState||(i.flags|=4),typeof b.getSnapshotBeforeUpdate!="function"||C===s.memoizedProps&&se===s.memoizedState||(i.flags|=1024),f=!1)}return Rc(s,i,l,f,y,p)}function Rc(s,i,l,f,p,y){cg(s,i);var b=(i.flags&128)!==0;if(!f&&!b)return p&&mm(i,l,!1),Ir(s,i,y);f=i.stateNode,bx.current=i;var C=b&&typeof l.getDerivedStateFromError!="function"?null:f.render();return i.flags|=1,s!==null&&b?(i.child=ui(i,s.child,null,y),i.child=ui(i,null,C,y)):Xt(s,i,C,y),i.memoizedState=f.state,p&&mm(i,l,!0),i.child}function fg(s){var i=s.stateNode;i.pendingContext?dm(s,i.pendingContext,i.pendingContext!==i.context):i.context&&dm(s,i.context,!1),wc(s,i.containerInfo)}function dg(s,i,l,f,p){return oi(),cc(p),i.flags|=256,Xt(s,i,l,f),i.child}var _c={dehydrated:null,treeContext:null,retryLane:0};function Fc(s){return{baseLanes:s,cachePool:null,transitions:null}}function pg(s,i,l){var f=i.pendingProps,p=pt.current,y=!1,b=(i.flags&128)!==0,C;if((C=b)||(C=s!==null&&s.memoizedState===null?!1:(p&2)!==0),C?(y=!0,i.flags&=-129):(s===null||s.memoizedState!==null)&&(p|=1),tt(pt,p&1),s===null)return uc(i),s=i.memoizedState,s!==null&&(s=s.dehydrated,s!==null)?((i.mode&1)===0?i.lanes=1:s.data==="$!"?i.lanes=8:i.lanes=1073741824,null):(b=f.children,s=f.fallback,y?(f=i.mode,y=i.child,b={mode:"hidden",children:b},(f&1)===0&&y!==null?(y.childLanes=0,y.pendingProps=b):y=sl(b,f,0,null),s=Is(s,f,l,null),y.return=i,s.return=i,y.sibling=s,i.child=y,i.child.memoizedState=Fc(l),i.memoizedState=_c,s):Lc(i,b));if(p=s.memoizedState,p!==null&&(C=p.dehydrated,C!==null))return kx(s,i,b,f,C,p,l);if(y){y=f.fallback,b=i.mode,p=s.child,C=p.sibling;var M={mode:"hidden",children:f.children};return(b&1)===0&&i.child!==p?(f=i.child,f.childLanes=0,f.pendingProps=M,i.deletions=null):(f=Kr(p,M),f.subtreeFlags=p.subtreeFlags&14680064),C!==null?y=Kr(C,y):(y=Is(y,b,l,null),y.flags|=2),y.return=i,f.return=i,f.sibling=y,i.child=f,f=y,y=i.child,b=s.child.memoizedState,b=b===null?Fc(l):{baseLanes:b.baseLanes|l,cachePool:null,transitions:b.transitions},y.memoizedState=b,y.childLanes=s.childLanes&~l,i.memoizedState=_c,f}return y=s.child,s=y.sibling,f=Kr(y,{mode:"visible",children:f.children}),(i.mode&1)===0&&(f.lanes=l),f.return=i,f.sibling=null,s!==null&&(l=i.deletions,l===null?(i.deletions=[s],i.flags|=16):l.push(s)),i.child=f,i.memoizedState=null,f}function Lc(s,i){return i=sl({mode:"visible",children:i},s.mode,0,null),i.return=s,s.child=i}function Ga(s,i,l,f){return f!==null&&cc(f),ui(i,s.child,null,l),s=Lc(i,i.pendingProps.children),s.flags|=2,i.memoizedState=null,s}function kx(s,i,l,f,p,y,b){if(l)return i.flags&256?(i.flags&=-257,f=zc(Error(t(422))),Ga(s,i,b,f)):i.memoizedState!==null?(i.child=s.child,i.flags|=128,null):(y=f.fallback,p=i.mode,f=sl({mode:"visible",children:f.children},p,0,null),y=Is(y,p,b,null),y.flags|=2,f.return=i,y.return=i,f.sibling=y,i.child=f,(i.mode&1)!==0&&ui(i,s.child,null,b),i.child.memoizedState=Fc(b),i.memoizedState=_c,y);if((i.mode&1)===0)return Ga(s,i,b,null);if(p.data==="$!"){if(f=p.nextSibling&&p.nextSibling.dataset,f)var C=f.dgst;return f=C,y=Error(t(419)),f=zc(y,f,void 0),Ga(s,i,b,f)}if(C=(b&s.childLanes)!==0,ln||C){if(f=Ft,f!==null){switch(b&-b){case 4:p=2;break;case 16:p=8;break;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:p=32;break;case 536870912:p=268435456;break;default:p=0}p=(p&(f.suspendedLanes|b))!==0?0:p,p!==0&&p!==y.retryLane&&(y.retryLane=p,Er(s,p),Wn(f,s,p,-1))}return Qc(),f=zc(Error(t(421))),Ga(s,i,b,f)}return p.data==="$?"?(i.flags|=128,i.child=s.child,i=Rx.bind(null,s),p._reactRetry=i,null):(s=y.treeContext,yn=Lr(p.nextSibling),gn=i,ct=!0,Pn=null,s!==null&&(kn[Sn++]=Sr,kn[Sn++]=xr,kn[Sn++]=ys,Sr=s.id,xr=s.overflow,ys=i),i=Lc(i,f.children),i.flags|=4096,i)}function mg(s,i,l){s.lanes|=i;var f=s.alternate;f!==null&&(f.lanes|=i),pc(s.return,i,l)}function Oc(s,i,l,f,p){var y=s.memoizedState;y===null?s.memoizedState={isBackwards:i,rendering:null,renderingStartTime:0,last:f,tail:l,tailMode:p}:(y.isBackwards=i,y.rendering=null,y.renderingStartTime=0,y.last=f,y.tail=l,y.tailMode=p)}function gg(s,i,l){var f=i.pendingProps,p=f.revealOrder,y=f.tail;if(Xt(s,i,f.children,l),f=pt.current,(f&2)!==0)f=f&1|2,i.flags|=128;else{if(s!==null&&(s.flags&128)!==0)e:for(s=i.child;s!==null;){if(s.tag===13)s.memoizedState!==null&&mg(s,l,i);else if(s.tag===19)mg(s,l,i);else if(s.child!==null){s.child.return=s,s=s.child;continue}if(s===i)break e;for(;s.sibling===null;){if(s.return===null||s.return===i)break e;s=s.return}s.sibling.return=s.return,s=s.sibling}f&=1}if(tt(pt,f),(i.mode&1)===0)i.memoizedState=null;else switch(p){case"forwards":for(l=i.child,p=null;l!==null;)s=l.alternate,s!==null&&Pa(s)===null&&(p=l),l=l.sibling;l=p,l===null?(p=i.child,i.child=null):(p=l.sibling,l.sibling=null),Oc(i,!1,p,l,y);break;case"backwards":for(l=null,p=i.child,i.child=null;p!==null;){if(s=p.alternate,s!==null&&Pa(s)===null){i.child=p;break}s=p.sibling,p.sibling=l,l=p,p=s}Oc(i,!0,l,null,y);break;case"together":Oc(i,!1,null,null,void 0);break;default:i.memoizedState=null}return i.child}function qa(s,i){(i.mode&1)===0&&s!==null&&(s.alternate=null,i.alternate=null,i.flags|=2)}function Ir(s,i,l){if(s!==null&&(i.dependencies=s.dependencies),Ss|=i.lanes,(l&i.childLanes)===0)return null;if(s!==null&&i.child!==s.child)throw Error(t(153));if(i.child!==null){for(s=i.child,l=Kr(s,s.pendingProps),i.child=l,l.return=i;s.sibling!==null;)s=s.sibling,l=l.sibling=Kr(s,s.pendingProps),l.return=i;l.sibling=null}return i.child}function Sx(s,i,l){switch(i.tag){case 3:fg(i),oi();break;case 5:Mm(i);break;case 1:an(i.type)&&Na(i);break;case 4:wc(i,i.stateNode.containerInfo);break;case 10:var f=i.type._context,p=i.memoizedProps.value;tt(Ma,f._currentValue),f._currentValue=p;break;case 13:if(f=i.memoizedState,f!==null)return f.dehydrated!==null?(tt(pt,pt.current&1),i.flags|=128,null):(l&i.child.childLanes)!==0?pg(s,i,l):(tt(pt,pt.current&1),s=Ir(s,i,l),s!==null?s.sibling:null);tt(pt,pt.current&1);break;case 19:if(f=(l&i.childLanes)!==0,(s.flags&128)!==0){if(f)return gg(s,i,l);i.flags|=128}if(p=i.memoizedState,p!==null&&(p.rendering=null,p.tail=null,p.lastEffect=null),tt(pt,pt.current),f)break;return null;case 22:case 23:return i.lanes=0,ug(s,i,l)}return Ir(s,i,l)}var yg,Pc,vg,wg;yg=function(s,i){for(var l=i.child;l!==null;){if(l.tag===5||l.tag===6)s.appendChild(l.stateNode);else if(l.tag!==4&&l.child!==null){l.child.return=l,l=l.child;continue}if(l===i)break;for(;l.sibling===null;){if(l.return===null||l.return===i)return;l=l.return}l.sibling.return=l.return,l=l.sibling}},Pc=function(){},vg=function(s,i,l,f){var p=s.memoizedProps;if(p!==f){s=i.stateNode,bs(ir.current);var y=null;switch(l){case"input":p=Pe(s,p),f=Pe(s,f),y=[];break;case"select":p=A({},p,{value:void 0}),f=A({},f,{value:void 0}),y=[];break;case"textarea":p=Fn(s,p),f=Fn(s,f),y=[];break;default:typeof p.onClick!="function"&&typeof f.onClick=="function"&&(s.onclick=Aa)}wu(l,f);var b;l=null;for(K in p)if(!f.hasOwnProperty(K)&&p.hasOwnProperty(K)&&p[K]!=null)if(K==="style"){var C=p[K];for(b in C)C.hasOwnProperty(b)&&(l||(l={}),l[b]="")}else K!=="dangerouslySetInnerHTML"&&K!=="children"&&K!=="suppressContentEditableWarning"&&K!=="suppressHydrationWarning"&&K!=="autoFocus"&&(o.hasOwnProperty(K)?y||(y=[]):(y=y||[]).push(K,null));for(K in f){var M=f[K];if(C=p?.[K],f.hasOwnProperty(K)&&M!==C&&(M!=null||C!=null))if(K==="style")if(C){for(b in C)!C.hasOwnProperty(b)||M&&M.hasOwnProperty(b)||(l||(l={}),l[b]="");for(b in M)M.hasOwnProperty(b)&&C[b]!==M[b]&&(l||(l={}),l[b]=M[b])}else l||(y||(y=[]),y.push(K,l)),l=M;else K==="dangerouslySetInnerHTML"?(M=M?M.__html:void 0,C=C?C.__html:void 0,M!=null&&C!==M&&(y=y||[]).push(K,M)):K==="children"?typeof M!="string"&&typeof M!="number"||(y=y||[]).push(K,""+M):K!=="suppressContentEditableWarning"&&K!=="suppressHydrationWarning"&&(o.hasOwnProperty(K)?(M!=null&&K==="onScroll"&&rt("scroll",s),y||C===M||(y=[])):(y=y||[]).push(K,M))}l&&(y=y||[]).push("style",l);var K=y;(i.updateQueue=K)&&(i.flags|=4)}},wg=function(s,i,l,f){l!==f&&(i.flags|=4)};function bo(s,i){if(!ct)switch(s.tailMode){case"hidden":i=s.tail;for(var l=null;i!==null;)i.alternate!==null&&(l=i),i=i.sibling;l===null?s.tail=null:l.sibling=null;break;case"collapsed":l=s.tail;for(var f=null;l!==null;)l.alternate!==null&&(f=l),l=l.sibling;f===null?i||s.tail===null?s.tail=null:s.tail.sibling=null:f.sibling=null}}function qt(s){var i=s.alternate!==null&&s.alternate.child===s.child,l=0,f=0;if(i)for(var p=s.child;p!==null;)l|=p.lanes|p.childLanes,f|=p.subtreeFlags&14680064,f|=p.flags&14680064,p.return=s,p=p.sibling;else for(p=s.child;p!==null;)l|=p.lanes|p.childLanes,f|=p.subtreeFlags,f|=p.flags,p.return=s,p=p.sibling;return s.subtreeFlags|=f,s.childLanes=l,i}function xx(s,i,l){var f=i.pendingProps;switch(ac(i),i.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return qt(i),null;case 1:return an(i.type)&&Ta(),qt(i),null;case 3:return f=i.stateNode,ci(),st(on),st(Vt),Sc(),f.pendingContext&&(f.context=f.pendingContext,f.pendingContext=null),(s===null||s.child===null)&&($a(i)?i.flags|=4:s===null||s.memoizedState.isDehydrated&&(i.flags&256)===0||(i.flags|=1024,Pn!==null&&(Xc(Pn),Pn=null))),Pc(s,i),qt(i),null;case 5:bc(i);var p=bs(mo.current);if(l=i.type,s!==null&&i.stateNode!=null)vg(s,i,l,f,p),s.ref!==i.ref&&(i.flags|=512,i.flags|=2097152);else{if(!f){if(i.stateNode===null)throw Error(t(166));return qt(i),null}if(s=bs(ir.current),$a(i)){f=i.stateNode,l=i.type;var y=i.memoizedProps;switch(f[sr]=i,f[uo]=y,s=(i.mode&1)!==0,l){case"dialog":rt("cancel",f),rt("close",f);break;case"iframe":case"object":case"embed":rt("load",f);break;case"video":case"audio":for(p=0;p<oo.length;p++)rt(oo[p],f);break;case"source":rt("error",f);break;case"img":case"image":case"link":rt("error",f),rt("load",f);break;case"details":rt("toggle",f);break;case"input":Ve(f,y),rt("invalid",f);break;case"select":f._wrapperState={wasMultiple:!!y.multiple},rt("invalid",f);break;case"textarea":wr(f,y),rt("invalid",f)}wu(l,y),p=null;for(var b in y)if(y.hasOwnProperty(b)){var C=y[b];b==="children"?typeof C=="string"?f.textContent!==C&&(y.suppressHydrationWarning!==!0&&Ea(f.textContent,C,s),p=["children",C]):typeof C=="number"&&f.textContent!==""+C&&(y.suppressHydrationWarning!==!0&&Ea(f.textContent,C,s),p=["children",""+C]):o.hasOwnProperty(b)&&C!=null&&b==="onScroll"&&rt("scroll",f)}switch(l){case"input":we(f),Nt(f,y,!0);break;case"textarea":we(f),na(f);break;case"select":case"option":break;default:typeof y.onClick=="function"&&(f.onclick=Aa)}f=p,i.updateQueue=f,f!==null&&(i.flags|=4)}else{b=p.nodeType===9?p:p.ownerDocument,s==="http://www.w3.org/1999/xhtml"&&(s=ra(l)),s==="http://www.w3.org/1999/xhtml"?l==="script"?(s=b.createElement("div"),s.innerHTML="<script><\/script>",s=s.removeChild(s.firstChild)):typeof f.is=="string"?s=b.createElement(l,{is:f.is}):(s=b.createElement(l),l==="select"&&(b=s,f.multiple?b.multiple=!0:f.size&&(b.size=f.size))):s=b.createElementNS(s,l),s[sr]=i,s[uo]=f,yg(s,i,!1,!1),i.stateNode=s;e:{switch(b=bu(l,f),l){case"dialog":rt("cancel",s),rt("close",s),p=f;break;case"iframe":case"object":case"embed":rt("load",s),p=f;break;case"video":case"audio":for(p=0;p<oo.length;p++)rt(oo[p],s);p=f;break;case"source":rt("error",s),p=f;break;case"img":case"image":case"link":rt("error",s),rt("load",s),p=f;break;case"details":rt("toggle",s),p=f;break;case"input":Ve(s,f),p=Pe(s,f),rt("invalid",s);break;case"option":p=f;break;case"select":s._wrapperState={wasMultiple:!!f.multiple},p=A({},f,{value:void 0}),rt("invalid",s);break;case"textarea":wr(s,f),p=Fn(s,f),rt("invalid",s);break;default:p=f}wu(l,p),C=p;for(y in C)if(C.hasOwnProperty(y)){var M=C[y];y==="style"?ap(s,M):y==="dangerouslySetInnerHTML"?(M=M?M.__html:void 0,M!=null&&Gs(s,M)):y==="children"?typeof M=="string"?(l!=="textarea"||M!=="")&&fs(s,M):typeof M=="number"&&fs(s,""+M):y!=="suppressContentEditableWarning"&&y!=="suppressHydrationWarning"&&y!=="autoFocus"&&(o.hasOwnProperty(y)?M!=null&&y==="onScroll"&&rt("scroll",s):M!=null&&R(s,y,M,b))}switch(l){case"input":we(s),Nt(s,f,!1);break;case"textarea":we(s),na(s);break;case"option":f.value!=null&&s.setAttribute("value",""+fe(f.value));break;case"select":s.multiple=!!f.multiple,y=f.value,y!=null?Ct(s,!!f.multiple,y,!1):f.defaultValue!=null&&Ct(s,!!f.multiple,f.defaultValue,!0);break;default:typeof p.onClick=="function"&&(s.onclick=Aa)}switch(l){case"button":case"input":case"select":case"textarea":f=!!f.autoFocus;break e;case"img":f=!0;break e;default:f=!1}}f&&(i.flags|=4)}i.ref!==null&&(i.flags|=512,i.flags|=2097152)}return qt(i),null;case 6:if(s&&i.stateNode!=null)wg(s,i,s.memoizedProps,f);else{if(typeof f!="string"&&i.stateNode===null)throw Error(t(166));if(l=bs(mo.current),bs(ir.current),$a(i)){if(f=i.stateNode,l=i.memoizedProps,f[sr]=i,(y=f.nodeValue!==l)&&(s=gn,s!==null))switch(s.tag){case 3:Ea(f.nodeValue,l,(s.mode&1)!==0);break;case 5:s.memoizedProps.suppressHydrationWarning!==!0&&Ea(f.nodeValue,l,(s.mode&1)!==0)}y&&(i.flags|=4)}else f=(l.nodeType===9?l:l.ownerDocument).createTextNode(f),f[sr]=i,i.stateNode=f}return qt(i),null;case 13:if(st(pt),f=i.memoizedState,s===null||s.memoizedState!==null&&s.memoizedState.dehydrated!==null){if(ct&&yn!==null&&(i.mode&1)!==0&&(i.flags&128)===0)km(),oi(),i.flags|=98560,y=!1;else if(y=$a(i),f!==null&&f.dehydrated!==null){if(s===null){if(!y)throw Error(t(318));if(y=i.memoizedState,y=y!==null?y.dehydrated:null,!y)throw Error(t(317));y[sr]=i}else oi(),(i.flags&128)===0&&(i.memoizedState=null),i.flags|=4;qt(i),y=!1}else Pn!==null&&(Xc(Pn),Pn=null),y=!0;if(!y)return i.flags&65536?i:null}return(i.flags&128)!==0?(i.lanes=l,i):(f=f!==null,f!==(s!==null&&s.memoizedState!==null)&&f&&(i.child.flags|=8192,(i.mode&1)!==0&&(s===null||(pt.current&1)!==0?zt===0&&(zt=3):Qc())),i.updateQueue!==null&&(i.flags|=4),qt(i),null);case 4:return ci(),Pc(s,i),s===null&&ao(i.stateNode.containerInfo),qt(i),null;case 10:return dc(i.type._context),qt(i),null;case 17:return an(i.type)&&Ta(),qt(i),null;case 19:if(st(pt),y=i.memoizedState,y===null)return qt(i),null;if(f=(i.flags&128)!==0,b=y.rendering,b===null)if(f)bo(y,!1);else{if(zt!==0||s!==null&&(s.flags&128)!==0)for(s=i.child;s!==null;){if(b=Pa(s),b!==null){for(i.flags|=128,bo(y,!1),f=b.updateQueue,f!==null&&(i.updateQueue=f,i.flags|=4),i.subtreeFlags=0,f=l,l=i.child;l!==null;)y=l,s=f,y.flags&=14680066,b=y.alternate,b===null?(y.childLanes=0,y.lanes=s,y.child=null,y.subtreeFlags=0,y.memoizedProps=null,y.memoizedState=null,y.updateQueue=null,y.dependencies=null,y.stateNode=null):(y.childLanes=b.childLanes,y.lanes=b.lanes,y.child=b.child,y.subtreeFlags=0,y.deletions=null,y.memoizedProps=b.memoizedProps,y.memoizedState=b.memoizedState,y.updateQueue=b.updateQueue,y.type=b.type,s=b.dependencies,y.dependencies=s===null?null:{lanes:s.lanes,firstContext:s.firstContext}),l=l.sibling;return tt(pt,pt.current&1|2),i.child}s=s.sibling}y.tail!==null&&bt()>pi&&(i.flags|=128,f=!0,bo(y,!1),i.lanes=4194304)}else{if(!f)if(s=Pa(b),s!==null){if(i.flags|=128,f=!0,l=s.updateQueue,l!==null&&(i.updateQueue=l,i.flags|=4),bo(y,!0),y.tail===null&&y.tailMode==="hidden"&&!b.alternate&&!ct)return qt(i),null}else 2*bt()-y.renderingStartTime>pi&&l!==1073741824&&(i.flags|=128,f=!0,bo(y,!1),i.lanes=4194304);y.isBackwards?(b.sibling=i.child,i.child=b):(l=y.last,l!==null?l.sibling=b:i.child=b,y.last=b)}return y.tail!==null?(i=y.tail,y.rendering=i,y.tail=i.sibling,y.renderingStartTime=bt(),i.sibling=null,l=pt.current,tt(pt,f?l&1|2:l&1),i):(qt(i),null);case 22:case 23:return Zc(),f=i.memoizedState!==null,s!==null&&s.memoizedState!==null!==f&&(i.flags|=8192),f&&(i.mode&1)!==0?(vn&1073741824)!==0&&(qt(i),i.subtreeFlags&6&&(i.flags|=8192)):qt(i),null;case 24:return null;case 25:return null}throw Error(t(156,i.tag))}function Ex(s,i){switch(ac(i),i.tag){case 1:return an(i.type)&&Ta(),s=i.flags,s&65536?(i.flags=s&-65537|128,i):null;case 3:return ci(),st(on),st(Vt),Sc(),s=i.flags,(s&65536)!==0&&(s&128)===0?(i.flags=s&-65537|128,i):null;case 5:return bc(i),null;case 13:if(st(pt),s=i.memoizedState,s!==null&&s.dehydrated!==null){if(i.alternate===null)throw Error(t(340));oi()}return s=i.flags,s&65536?(i.flags=s&-65537|128,i):null;case 19:return st(pt),null;case 4:return ci(),null;case 10:return dc(i.type._context),null;case 22:case 23:return Zc(),null;case 24:return null;default:return null}}var Ha=!1,Ht=!1,Ax=typeof WeakSet=="function"?WeakSet:Set,ke=null;function fi(s,i){var l=s.ref;if(l!==null)if(typeof l=="function")try{l(null)}catch(f){yt(s,i,f)}else l.current=null}function Bc(s,i,l){try{l()}catch(f){yt(s,i,f)}}var bg=!1;function Ix(s,i){if(Zu=da,s=Yp(),Vu(s)){if("selectionStart"in s)var l={start:s.selectionStart,end:s.selectionEnd};else e:{l=(l=s.ownerDocument)&&l.defaultView||window;var f=l.getSelection&&l.getSelection();if(f&&f.rangeCount!==0){l=f.anchorNode;var p=f.anchorOffset,y=f.focusNode;f=f.focusOffset;try{l.nodeType,y.nodeType}catch{l=null;break e}var b=0,C=-1,M=-1,K=0,ie=0,ae=s,se=null;t:for(;;){for(var ye;ae!==l||p!==0&&ae.nodeType!==3||(C=b+p),ae!==y||f!==0&&ae.nodeType!==3||(M=b+f),ae.nodeType===3&&(b+=ae.nodeValue.length),(ye=ae.firstChild)!==null;)se=ae,ae=ye;for(;;){if(ae===s)break t;if(se===l&&++K===p&&(C=b),se===y&&++ie===f&&(M=b),(ye=ae.nextSibling)!==null)break;ae=se,se=ae.parentNode}ae=ye}l=C===-1||M===-1?null:{start:C,end:M}}else l=null}l=l||{start:0,end:0}}else l=null;for(Qu={focusedElem:s,selectionRange:l},da=!1,ke=i;ke!==null;)if(i=ke,s=i.child,(i.subtreeFlags&1028)!==0&&s!==null)s.return=i,ke=s;else for(;ke!==null;){i=ke;try{var xe=i.alternate;if((i.flags&1024)!==0)switch(i.tag){case 0:case 11:case 15:break;case 1:if(xe!==null){var Ae=xe.memoizedProps,kt=xe.memoizedState,j=i.stateNode,L=j.getSnapshotBeforeUpdate(i.elementType===i.type?Ae:Bn(i.type,Ae),kt);j.__reactInternalSnapshotBeforeUpdate=L}break;case 3:var q=i.stateNode.containerInfo;q.nodeType===1?q.textContent="":q.nodeType===9&&q.documentElement&&q.removeChild(q.documentElement);break;case 5:case 6:case 4:case 17:break;default:throw Error(t(163))}}catch(he){yt(i,i.return,he)}if(s=i.sibling,s!==null){s.return=i.return,ke=s;break}ke=i.return}return xe=bg,bg=!1,xe}function ko(s,i,l){var f=i.updateQueue;if(f=f!==null?f.lastEffect:null,f!==null){var p=f=f.next;do{if((p.tag&s)===s){var y=p.destroy;p.destroy=void 0,y!==void 0&&Bc(i,l,y)}p=p.next}while(p!==f)}}function Ka(s,i){if(i=i.updateQueue,i=i!==null?i.lastEffect:null,i!==null){var l=i=i.next;do{if((l.tag&s)===s){var f=l.create;l.destroy=f()}l=l.next}while(l!==i)}}function Uc(s){var i=s.ref;if(i!==null){var l=s.stateNode;s.tag,s=l,typeof i=="function"?i(s):i.current=s}}function kg(s){var i=s.alternate;i!==null&&(s.alternate=null,kg(i)),s.child=null,s.deletions=null,s.sibling=null,s.tag===5&&(i=s.stateNode,i!==null&&(delete i[sr],delete i[uo],delete i[rc],delete i[lx],delete i[ux])),s.stateNode=null,s.return=null,s.dependencies=null,s.memoizedProps=null,s.memoizedState=null,s.pendingProps=null,s.stateNode=null,s.updateQueue=null}function Sg(s){return s.tag===5||s.tag===3||s.tag===4}function xg(s){e:for(;;){for(;s.sibling===null;){if(s.return===null||Sg(s.return))return null;s=s.return}for(s.sibling.return=s.return,s=s.sibling;s.tag!==5&&s.tag!==6&&s.tag!==18;){if(s.flags&2||s.child===null||s.tag===4)continue e;s.child.return=s,s=s.child}if(!(s.flags&2))return s.stateNode}}function jc(s,i,l){var f=s.tag;if(f===5||f===6)s=s.stateNode,i?l.nodeType===8?l.parentNode.insertBefore(s,i):l.insertBefore(s,i):(l.nodeType===8?(i=l.parentNode,i.insertBefore(s,l)):(i=l,i.appendChild(s)),l=l._reactRootContainer,l!=null||i.onclick!==null||(i.onclick=Aa));else if(f!==4&&(s=s.child,s!==null))for(jc(s,i,l),s=s.sibling;s!==null;)jc(s,i,l),s=s.sibling}function Wc(s,i,l){var f=s.tag;if(f===5||f===6)s=s.stateNode,i?l.insertBefore(s,i):l.appendChild(s);else if(f!==4&&(s=s.child,s!==null))for(Wc(s,i,l),s=s.sibling;s!==null;)Wc(s,i,l),s=s.sibling}var Bt=null,Un=!1;function Wr(s,i,l){for(l=l.child;l!==null;)Eg(s,i,l),l=l.sibling}function Eg(s,i,l){if(rr&&typeof rr.onCommitFiberUnmount=="function")try{rr.onCommitFiberUnmount(aa,l)}catch{}switch(l.tag){case 5:Ht||fi(l,i);case 6:var f=Bt,p=Un;Bt=null,Wr(s,i,l),Bt=f,Un=p,Bt!==null&&(Un?(s=Bt,l=l.stateNode,s.nodeType===8?s.parentNode.removeChild(l):s.removeChild(l)):Bt.removeChild(l.stateNode));break;case 18:Bt!==null&&(Un?(s=Bt,l=l.stateNode,s.nodeType===8?nc(s.parentNode,l):s.nodeType===1&&nc(s,l),Zi(s)):nc(Bt,l.stateNode));break;case 4:f=Bt,p=Un,Bt=l.stateNode.containerInfo,Un=!0,Wr(s,i,l),Bt=f,Un=p;break;case 0:case 11:case 14:case 15:if(!Ht&&(f=l.updateQueue,f!==null&&(f=f.lastEffect,f!==null))){p=f=f.next;do{var y=p,b=y.destroy;y=y.tag,b!==void 0&&((y&2)!==0||(y&4)!==0)&&Bc(l,i,b),p=p.next}while(p!==f)}Wr(s,i,l);break;case 1:if(!Ht&&(fi(l,i),f=l.stateNode,typeof f.componentWillUnmount=="function"))try{f.props=l.memoizedProps,f.state=l.memoizedState,f.componentWillUnmount()}catch(C){yt(l,i,C)}Wr(s,i,l);break;case 21:Wr(s,i,l);break;case 22:l.mode&1?(Ht=(f=Ht)||l.memoizedState!==null,Wr(s,i,l),Ht=f):Wr(s,i,l);break;default:Wr(s,i,l)}}function Ag(s){var i=s.updateQueue;if(i!==null){s.updateQueue=null;var l=s.stateNode;l===null&&(l=s.stateNode=new Ax),i.forEach(function(f){var p=_x.bind(null,s,f);l.has(f)||(l.add(f),f.then(p,p))})}}function jn(s,i){var l=i.deletions;if(l!==null)for(var f=0;f<l.length;f++){var p=l[f];try{var y=s,b=i,C=b;e:for(;C!==null;){switch(C.tag){case 5:Bt=C.stateNode,Un=!1;break e;case 3:Bt=C.stateNode.containerInfo,Un=!0;break e;case 4:Bt=C.stateNode.containerInfo,Un=!0;break e}C=C.return}if(Bt===null)throw Error(t(160));Eg(y,b,p),Bt=null,Un=!1;var M=p.alternate;M!==null&&(M.return=null),p.return=null}catch(K){yt(p,i,K)}}if(i.subtreeFlags&12854)for(i=i.child;i!==null;)Ig(i,s),i=i.sibling}function Ig(s,i){var l=s.alternate,f=s.flags;switch(s.tag){case 0:case 11:case 14:case 15:if(jn(i,s),ar(s),f&4){try{ko(3,s,s.return),Ka(3,s)}catch(Ae){yt(s,s.return,Ae)}try{ko(5,s,s.return)}catch(Ae){yt(s,s.return,Ae)}}break;case 1:jn(i,s),ar(s),f&512&&l!==null&&fi(l,l.return);break;case 5:if(jn(i,s),ar(s),f&512&&l!==null&&fi(l,l.return),s.flags&32){var p=s.stateNode;try{fs(p,"")}catch(Ae){yt(s,s.return,Ae)}}if(f&4&&(p=s.stateNode,p!=null)){var y=s.memoizedProps,b=l!==null?l.memoizedProps:y,C=s.type,M=s.updateQueue;if(s.updateQueue=null,M!==null)try{C==="input"&&y.type==="radio"&&y.name!=null&&je(p,y),bu(C,b);var K=bu(C,y);for(b=0;b<M.length;b+=2){var ie=M[b],ae=M[b+1];ie==="style"?ap(p,ae):ie==="dangerouslySetInnerHTML"?Gs(p,ae):ie==="children"?fs(p,ae):R(p,ie,ae,K)}switch(C){case"input":wt(p,y);break;case"textarea":nr(p,y);break;case"select":var se=p._wrapperState.wasMultiple;p._wrapperState.wasMultiple=!!y.multiple;var ye=y.value;ye!=null?Ct(p,!!y.multiple,ye,!1):se!==!!y.multiple&&(y.defaultValue!=null?Ct(p,!!y.multiple,y.defaultValue,!0):Ct(p,!!y.multiple,y.multiple?[]:"",!1))}p[uo]=y}catch(Ae){yt(s,s.return,Ae)}}break;case 6:if(jn(i,s),ar(s),f&4){if(s.stateNode===null)throw Error(t(162));p=s.stateNode,y=s.memoizedProps;try{p.nodeValue=y}catch(Ae){yt(s,s.return,Ae)}}break;case 3:if(jn(i,s),ar(s),f&4&&l!==null&&l.memoizedState.isDehydrated)try{Zi(i.containerInfo)}catch(Ae){yt(s,s.return,Ae)}break;case 4:jn(i,s),ar(s);break;case 13:jn(i,s),ar(s),p=s.child,p.flags&8192&&(y=p.memoizedState!==null,p.stateNode.isHidden=y,!y||p.alternate!==null&&p.alternate.memoizedState!==null||(qc=bt())),f&4&&Ag(s);break;case 22:if(ie=l!==null&&l.memoizedState!==null,s.mode&1?(Ht=(K=Ht)||ie,jn(i,s),Ht=K):jn(i,s),ar(s),f&8192){if(K=s.memoizedState!==null,(s.stateNode.isHidden=K)&&!ie&&(s.mode&1)!==0)for(ke=s,ie=s.child;ie!==null;){for(ae=ke=ie;ke!==null;){switch(se=ke,ye=se.child,se.tag){case 0:case 11:case 14:case 15:ko(4,se,se.return);break;case 1:fi(se,se.return);var xe=se.stateNode;if(typeof xe.componentWillUnmount=="function"){f=se,l=se.return;try{i=f,xe.props=i.memoizedProps,xe.state=i.memoizedState,xe.componentWillUnmount()}catch(Ae){yt(f,l,Ae)}}break;case 5:fi(se,se.return);break;case 22:if(se.memoizedState!==null){Cg(ae);continue}}ye!==null?(ye.return=se,ke=ye):Cg(ae)}ie=ie.sibling}e:for(ie=null,ae=s;;){if(ae.tag===5){if(ie===null){ie=ae;try{p=ae.stateNode,K?(y=p.style,typeof y.setProperty=="function"?y.setProperty("display","none","important"):y.display="none"):(C=ae.stateNode,M=ae.memoizedProps.style,b=M!=null&&M.hasOwnProperty("display")?M.display:null,C.style.display=op("display",b))}catch(Ae){yt(s,s.return,Ae)}}}else if(ae.tag===6){if(ie===null)try{ae.stateNode.nodeValue=K?"":ae.memoizedProps}catch(Ae){yt(s,s.return,Ae)}}else if((ae.tag!==22&&ae.tag!==23||ae.memoizedState===null||ae===s)&&ae.child!==null){ae.child.return=ae,ae=ae.child;continue}if(ae===s)break e;for(;ae.sibling===null;){if(ae.return===null||ae.return===s)break e;ie===ae&&(ie=null),ae=ae.return}ie===ae&&(ie=null),ae.sibling.return=ae.return,ae=ae.sibling}}break;case 19:jn(i,s),ar(s),f&4&&Ag(s);break;case 21:break;default:jn(i,s),ar(s)}}function ar(s){var i=s.flags;if(i&2){try{e:{for(var l=s.return;l!==null;){if(Sg(l)){var f=l;break e}l=l.return}throw Error(t(160))}switch(f.tag){case 5:var p=f.stateNode;f.flags&32&&(fs(p,""),f.flags&=-33);var y=xg(s);Wc(s,y,p);break;case 3:case 4:var b=f.stateNode.containerInfo,C=xg(s);jc(s,C,b);break;default:throw Error(t(161))}}catch(M){yt(s,s.return,M)}s.flags&=-3}i&4096&&(s.flags&=-4097)}function Tx(s,i,l){ke=s,Tg(s)}function Tg(s,i,l){for(var f=(s.mode&1)!==0;ke!==null;){var p=ke,y=p.child;if(p.tag===22&&f){var b=p.memoizedState!==null||Ha;if(!b){var C=p.alternate,M=C!==null&&C.memoizedState!==null||Ht;C=Ha;var K=Ht;if(Ha=b,(Ht=M)&&!K)for(ke=p;ke!==null;)b=ke,M=b.child,b.tag===22&&b.memoizedState!==null?Dg(p):M!==null?(M.return=b,ke=M):Dg(p);for(;y!==null;)ke=y,Tg(y),y=y.sibling;ke=p,Ha=C,Ht=K}Ng(s)}else(p.subtreeFlags&8772)!==0&&y!==null?(y.return=p,ke=y):Ng(s)}}function Ng(s){for(;ke!==null;){var i=ke;if((i.flags&8772)!==0){var l=i.alternate;try{if((i.flags&8772)!==0)switch(i.tag){case 0:case 11:case 15:Ht||Ka(5,i);break;case 1:var f=i.stateNode;if(i.flags&4&&!Ht)if(l===null)f.componentDidMount();else{var p=i.elementType===i.type?l.memoizedProps:Bn(i.type,l.memoizedProps);f.componentDidUpdate(p,l.memoizedState,f.__reactInternalSnapshotBeforeUpdate)}var y=i.updateQueue;y!==null&&Am(i,y,f);break;case 3:var b=i.updateQueue;if(b!==null){if(l=null,i.child!==null)switch(i.child.tag){case 5:l=i.child.stateNode;break;case 1:l=i.child.stateNode}Am(i,b,l)}break;case 5:var C=i.stateNode;if(l===null&&i.flags&4){l=C;var M=i.memoizedProps;switch(i.type){case"button":case"input":case"select":case"textarea":M.autoFocus&&l.focus();break;case"img":M.src&&(l.src=M.src)}}break;case 6:break;case 4:break;case 12:break;case 13:if(i.memoizedState===null){var K=i.alternate;if(K!==null){var ie=K.memoizedState;if(ie!==null){var ae=ie.dehydrated;ae!==null&&Zi(ae)}}}break;case 19:case 17:case 21:case 22:case 23:case 25:break;default:throw Error(t(163))}Ht||i.flags&512&&Uc(i)}catch(se){yt(i,i.return,se)}}if(i===s){ke=null;break}if(l=i.sibling,l!==null){l.return=i.return,ke=l;break}ke=i.return}}function Cg(s){for(;ke!==null;){var i=ke;if(i===s){ke=null;break}var l=i.sibling;if(l!==null){l.return=i.return,ke=l;break}ke=i.return}}function Dg(s){for(;ke!==null;){var i=ke;try{switch(i.tag){case 0:case 11:case 15:var l=i.return;try{Ka(4,i)}catch(M){yt(i,l,M)}break;case 1:var f=i.stateNode;if(typeof f.componentDidMount=="function"){var p=i.return;try{f.componentDidMount()}catch(M){yt(i,p,M)}}var y=i.return;try{Uc(i)}catch(M){yt(i,y,M)}break;case 5:var b=i.return;try{Uc(i)}catch(M){yt(i,b,M)}}}catch(M){yt(i,i.return,M)}if(i===s){ke=null;break}var C=i.sibling;if(C!==null){C.return=i.return,ke=C;break}ke=i.return}}var Nx=Math.ceil,Ja=$.ReactCurrentDispatcher,Vc=$.ReactCurrentOwner,An=$.ReactCurrentBatchConfig,Ge=0,Ft=null,xt=null,Ut=0,vn=0,di=Or(0),zt=0,So=null,Ss=0,Xa=0,Gc=0,xo=null,un=null,qc=0,pi=1/0,Tr=null,Ya=!1,Hc=null,Vr=null,Za=!1,Gr=null,Qa=0,Eo=0,Kc=null,el=-1,tl=0;function Yt(){return(Ge&6)!==0?bt():el!==-1?el:el=bt()}function qr(s){return(s.mode&1)===0?1:(Ge&2)!==0&&Ut!==0?Ut&-Ut:hx.transition!==null?(tl===0&&(tl=Sp()),tl):(s=Ze,s!==0||(s=window.event,s=s===void 0?16:zp(s.type)),s)}function Wn(s,i,l,f){if(50<Eo)throw Eo=0,Kc=null,Error(t(185));Hi(s,l,f),((Ge&2)===0||s!==Ft)&&(s===Ft&&((Ge&2)===0&&(Xa|=l),zt===4&&Hr(s,Ut)),cn(s,f),l===1&&Ge===0&&(i.mode&1)===0&&(pi=bt()+500,Ca&&Br()))}function cn(s,i){var l=s.callbackNode;hS(s,i);var f=ca(s,s===Ft?Ut:0);if(f===0)l!==null&&wp(l),s.callbackNode=null,s.callbackPriority=0;else if(i=f&-f,s.callbackPriority!==i){if(l!=null&&wp(l),i===1)s.tag===0?cx($g.bind(null,s)):gm($g.bind(null,s)),ox(function(){(Ge&6)===0&&Br()}),l=null;else{switch(xp(f)){case 1:l=Tu;break;case 4:l=bp;break;case 16:l=oa;break;case 536870912:l=kp;break;default:l=oa}l=Bg(l,zg.bind(null,s))}s.callbackPriority=i,s.callbackNode=l}}function zg(s,i){if(el=-1,tl=0,(Ge&6)!==0)throw Error(t(327));var l=s.callbackNode;if(mi()&&s.callbackNode!==l)return null;var f=ca(s,s===Ft?Ut:0);if(f===0)return null;if((f&30)!==0||(f&s.expiredLanes)!==0||i)i=nl(s,f);else{i=f;var p=Ge;Ge|=2;var y=Rg();(Ft!==s||Ut!==i)&&(Tr=null,pi=bt()+500,Es(s,i));do try{zx();break}catch(C){Mg(s,C)}while(!0);fc(),Ja.current=y,Ge=p,xt!==null?i=0:(Ft=null,Ut=0,i=zt)}if(i!==0){if(i===2&&(p=Nu(s),p!==0&&(f=p,i=Jc(s,p))),i===1)throw l=So,Es(s,0),Hr(s,f),cn(s,bt()),l;if(i===6)Hr(s,f);else{if(p=s.current.alternate,(f&30)===0&&!Cx(p)&&(i=nl(s,f),i===2&&(y=Nu(s),y!==0&&(f=y,i=Jc(s,y))),i===1))throw l=So,Es(s,0),Hr(s,f),cn(s,bt()),l;switch(s.finishedWork=p,s.finishedLanes=f,i){case 0:case 1:throw Error(t(345));case 2:As(s,un,Tr);break;case 3:if(Hr(s,f),(f&130023424)===f&&(i=qc+500-bt(),10<i)){if(ca(s,0)!==0)break;if(p=s.suspendedLanes,(p&f)!==f){Yt(),s.pingedLanes|=s.suspendedLanes&p;break}s.timeoutHandle=tc(As.bind(null,s,un,Tr),i);break}As(s,un,Tr);break;case 4:if(Hr(s,f),(f&4194240)===f)break;for(i=s.eventTimes,p=-1;0<f;){var b=31-Ln(f);y=1<<b,b=i[b],b>p&&(p=b),f&=~y}if(f=p,f=bt()-f,f=(120>f?120:480>f?480:1080>f?1080:1920>f?1920:3e3>f?3e3:4320>f?4320:1960*Nx(f/1960))-f,10<f){s.timeoutHandle=tc(As.bind(null,s,un,Tr),f);break}As(s,un,Tr);break;case 5:As(s,un,Tr);break;default:throw Error(t(329))}}}return cn(s,bt()),s.callbackNode===l?zg.bind(null,s):null}function Jc(s,i){var l=xo;return s.current.memoizedState.isDehydrated&&(Es(s,i).flags|=256),s=nl(s,i),s!==2&&(i=un,un=l,i!==null&&Xc(i)),s}function Xc(s){un===null?un=s:un.push.apply(un,s)}function Cx(s){for(var i=s;;){if(i.flags&16384){var l=i.updateQueue;if(l!==null&&(l=l.stores,l!==null))for(var f=0;f<l.length;f++){var p=l[f],y=p.getSnapshot;p=p.value;try{if(!On(y(),p))return!1}catch{return!1}}}if(l=i.child,i.subtreeFlags&16384&&l!==null)l.return=i,i=l;else{if(i===s)break;for(;i.sibling===null;){if(i.return===null||i.return===s)return!0;i=i.return}i.sibling.return=i.return,i=i.sibling}}return!0}function Hr(s,i){for(i&=~Gc,i&=~Xa,s.suspendedLanes|=i,s.pingedLanes&=~i,s=s.expirationTimes;0<i;){var l=31-Ln(i),f=1<<l;s[l]=-1,i&=~f}}function $g(s){if((Ge&6)!==0)throw Error(t(327));mi();var i=ca(s,0);if((i&1)===0)return cn(s,bt()),null;var l=nl(s,i);if(s.tag!==0&&l===2){var f=Nu(s);f!==0&&(i=f,l=Jc(s,f))}if(l===1)throw l=So,Es(s,0),Hr(s,i),cn(s,bt()),l;if(l===6)throw Error(t(345));return s.finishedWork=s.current.alternate,s.finishedLanes=i,As(s,un,Tr),cn(s,bt()),null}function Yc(s,i){var l=Ge;Ge|=1;try{return s(i)}finally{Ge=l,Ge===0&&(pi=bt()+500,Ca&&Br())}}function xs(s){Gr!==null&&Gr.tag===0&&(Ge&6)===0&&mi();var i=Ge;Ge|=1;var l=An.transition,f=Ze;try{if(An.transition=null,Ze=1,s)return s()}finally{Ze=f,An.transition=l,Ge=i,(Ge&6)===0&&Br()}}function Zc(){vn=di.current,st(di)}function Es(s,i){s.finishedWork=null,s.finishedLanes=0;var l=s.timeoutHandle;if(l!==-1&&(s.timeoutHandle=-1,ix(l)),xt!==null)for(l=xt.return;l!==null;){var f=l;switch(ac(f),f.tag){case 1:f=f.type.childContextTypes,f!=null&&Ta();break;case 3:ci(),st(on),st(Vt),Sc();break;case 5:bc(f);break;case 4:ci();break;case 13:st(pt);break;case 19:st(pt);break;case 10:dc(f.type._context);break;case 22:case 23:Zc()}l=l.return}if(Ft=s,xt=s=Kr(s.current,null),Ut=vn=i,zt=0,So=null,Gc=Xa=Ss=0,un=xo=null,ws!==null){for(i=0;i<ws.length;i++)if(l=ws[i],f=l.interleaved,f!==null){l.interleaved=null;var p=f.next,y=l.pending;if(y!==null){var b=y.next;y.next=p,f.next=b}l.pending=f}ws=null}return s}function Mg(s,i){do{var l=xt;try{if(fc(),Ba.current=Va,Ua){for(var f=mt.memoizedState;f!==null;){var p=f.queue;p!==null&&(p.pending=null),f=f.next}Ua=!1}if(ks=0,_t=Dt=mt=null,go=!1,yo=0,Vc.current=null,l===null||l.return===null){zt=1,So=i,xt=null;break}e:{var y=s,b=l.return,C=l,M=i;if(i=Ut,C.flags|=32768,M!==null&&typeof M=="object"&&typeof M.then=="function"){var K=M,ie=C,ae=ie.tag;if((ie.mode&1)===0&&(ae===0||ae===11||ae===15)){var se=ie.alternate;se?(ie.updateQueue=se.updateQueue,ie.memoizedState=se.memoizedState,ie.lanes=se.lanes):(ie.updateQueue=null,ie.memoizedState=null)}var ye=sg(b);if(ye!==null){ye.flags&=-257,ig(ye,b,C,y,i),ye.mode&1&&rg(y,K,i),i=ye,M=K;var xe=i.updateQueue;if(xe===null){var Ae=new Set;Ae.add(M),i.updateQueue=Ae}else xe.add(M);break e}else{if((i&1)===0){rg(y,K,i),Qc();break e}M=Error(t(426))}}else if(ct&&C.mode&1){var kt=sg(b);if(kt!==null){(kt.flags&65536)===0&&(kt.flags|=256),ig(kt,b,C,y,i),cc(hi(M,C));break e}}y=M=hi(M,C),zt!==4&&(zt=2),xo===null?xo=[y]:xo.push(y),y=b;do{switch(y.tag){case 3:y.flags|=65536,i&=-i,y.lanes|=i;var j=tg(y,M,i);Em(y,j);break e;case 1:C=M;var L=y.type,q=y.stateNode;if((y.flags&128)===0&&(typeof L.getDerivedStateFromError=="function"||q!==null&&typeof q.componentDidCatch=="function"&&(Vr===null||!Vr.has(q)))){y.flags|=65536,i&=-i,y.lanes|=i;var he=ng(y,C,i);Em(y,he);break e}}y=y.return}while(y!==null)}Fg(l)}catch(Te){i=Te,xt===l&&l!==null&&(xt=l=l.return);continue}break}while(!0)}function Rg(){var s=Ja.current;return Ja.current=Va,s===null?Va:s}function Qc(){(zt===0||zt===3||zt===2)&&(zt=4),Ft===null||(Ss&268435455)===0&&(Xa&268435455)===0||Hr(Ft,Ut)}function nl(s,i){var l=Ge;Ge|=2;var f=Rg();(Ft!==s||Ut!==i)&&(Tr=null,Es(s,i));do try{Dx();break}catch(p){Mg(s,p)}while(!0);if(fc(),Ge=l,Ja.current=f,xt!==null)throw Error(t(261));return Ft=null,Ut=0,zt}function Dx(){for(;xt!==null;)_g(xt)}function zx(){for(;xt!==null&&!nS();)_g(xt)}function _g(s){var i=Pg(s.alternate,s,vn);s.memoizedProps=s.pendingProps,i===null?Fg(s):xt=i,Vc.current=null}function Fg(s){var i=s;do{var l=i.alternate;if(s=i.return,(i.flags&32768)===0){if(l=xx(l,i,vn),l!==null){xt=l;return}}else{if(l=Ex(l,i),l!==null){l.flags&=32767,xt=l;return}if(s!==null)s.flags|=32768,s.subtreeFlags=0,s.deletions=null;else{zt=6,xt=null;return}}if(i=i.sibling,i!==null){xt=i;return}xt=i=s}while(i!==null);zt===0&&(zt=5)}function As(s,i,l){var f=Ze,p=An.transition;try{An.transition=null,Ze=1,$x(s,i,l,f)}finally{An.transition=p,Ze=f}return null}function $x(s,i,l,f){do mi();while(Gr!==null);if((Ge&6)!==0)throw Error(t(327));l=s.finishedWork;var p=s.finishedLanes;if(l===null)return null;if(s.finishedWork=null,s.finishedLanes=0,l===s.current)throw Error(t(177));s.callbackNode=null,s.callbackPriority=0;var y=l.lanes|l.childLanes;if(fS(s,y),s===Ft&&(xt=Ft=null,Ut=0),(l.subtreeFlags&2064)===0&&(l.flags&2064)===0||Za||(Za=!0,Bg(oa,function(){return mi(),null})),y=(l.flags&15990)!==0,(l.subtreeFlags&15990)!==0||y){y=An.transition,An.transition=null;var b=Ze;Ze=1;var C=Ge;Ge|=4,Vc.current=null,Ix(s,l),Ig(l,s),ZS(Qu),da=!!Zu,Qu=Zu=null,s.current=l,Tx(l),rS(),Ge=C,Ze=b,An.transition=y}else s.current=l;if(Za&&(Za=!1,Gr=s,Qa=p),y=s.pendingLanes,y===0&&(Vr=null),oS(l.stateNode),cn(s,bt()),i!==null)for(f=s.onRecoverableError,l=0;l<i.length;l++)p=i[l],f(p.value,{componentStack:p.stack,digest:p.digest});if(Ya)throw Ya=!1,s=Hc,Hc=null,s;return(Qa&1)!==0&&s.tag!==0&&mi(),y=s.pendingLanes,(y&1)!==0?s===Kc?Eo++:(Eo=0,Kc=s):Eo=0,Br(),null}function mi(){if(Gr!==null){var s=xp(Qa),i=An.transition,l=Ze;try{if(An.transition=null,Ze=16>s?16:s,Gr===null)var f=!1;else{if(s=Gr,Gr=null,Qa=0,(Ge&6)!==0)throw Error(t(331));var p=Ge;for(Ge|=4,ke=s.current;ke!==null;){var y=ke,b=y.child;if((ke.flags&16)!==0){var C=y.deletions;if(C!==null){for(var M=0;M<C.length;M++){var K=C[M];for(ke=K;ke!==null;){var ie=ke;switch(ie.tag){case 0:case 11:case 15:ko(8,ie,y)}var ae=ie.child;if(ae!==null)ae.return=ie,ke=ae;else for(;ke!==null;){ie=ke;var se=ie.sibling,ye=ie.return;if(kg(ie),ie===K){ke=null;break}if(se!==null){se.return=ye,ke=se;break}ke=ye}}}var xe=y.alternate;if(xe!==null){var Ae=xe.child;if(Ae!==null){xe.child=null;do{var kt=Ae.sibling;Ae.sibling=null,Ae=kt}while(Ae!==null)}}ke=y}}if((y.subtreeFlags&2064)!==0&&b!==null)b.return=y,ke=b;else e:for(;ke!==null;){if(y=ke,(y.flags&2048)!==0)switch(y.tag){case 0:case 11:case 15:ko(9,y,y.return)}var j=y.sibling;if(j!==null){j.return=y.return,ke=j;break e}ke=y.return}}var L=s.current;for(ke=L;ke!==null;){b=ke;var q=b.child;if((b.subtreeFlags&2064)!==0&&q!==null)q.return=b,ke=q;else e:for(b=L;ke!==null;){if(C=ke,(C.flags&2048)!==0)try{switch(C.tag){case 0:case 11:case 15:Ka(9,C)}}catch(Te){yt(C,C.return,Te)}if(C===b){ke=null;break e}var he=C.sibling;if(he!==null){he.return=C.return,ke=he;break e}ke=C.return}}if(Ge=p,Br(),rr&&typeof rr.onPostCommitFiberRoot=="function")try{rr.onPostCommitFiberRoot(aa,s)}catch{}f=!0}return f}finally{Ze=l,An.transition=i}}return!1}function Lg(s,i,l){i=hi(l,i),i=tg(s,i,1),s=jr(s,i,1),i=Yt(),s!==null&&(Hi(s,1,i),cn(s,i))}function yt(s,i,l){if(s.tag===3)Lg(s,s,l);else for(;i!==null;){if(i.tag===3){Lg(i,s,l);break}else if(i.tag===1){var f=i.stateNode;if(typeof i.type.getDerivedStateFromError=="function"||typeof f.componentDidCatch=="function"&&(Vr===null||!Vr.has(f))){s=hi(l,s),s=ng(i,s,1),i=jr(i,s,1),s=Yt(),i!==null&&(Hi(i,1,s),cn(i,s));break}}i=i.return}}function Mx(s,i,l){var f=s.pingCache;f!==null&&f.delete(i),i=Yt(),s.pingedLanes|=s.suspendedLanes&l,Ft===s&&(Ut&l)===l&&(zt===4||zt===3&&(Ut&130023424)===Ut&&500>bt()-qc?Es(s,0):Gc|=l),cn(s,i)}function Og(s,i){i===0&&((s.mode&1)===0?i=1:(i=ua,ua<<=1,(ua&130023424)===0&&(ua=4194304)));var l=Yt();s=Er(s,i),s!==null&&(Hi(s,i,l),cn(s,l))}function Rx(s){var i=s.memoizedState,l=0;i!==null&&(l=i.retryLane),Og(s,l)}function _x(s,i){var l=0;switch(s.tag){case 13:var f=s.stateNode,p=s.memoizedState;p!==null&&(l=p.retryLane);break;case 19:f=s.stateNode;break;default:throw Error(t(314))}f!==null&&f.delete(i),Og(s,l)}var Pg;Pg=function(s,i,l){if(s!==null)if(s.memoizedProps!==i.pendingProps||on.current)ln=!0;else{if((s.lanes&l)===0&&(i.flags&128)===0)return ln=!1,Sx(s,i,l);ln=(s.flags&131072)!==0}else ln=!1,ct&&(i.flags&1048576)!==0&&ym(i,za,i.index);switch(i.lanes=0,i.tag){case 2:var f=i.type;qa(s,i),s=i.pendingProps;var p=ri(i,Vt.current);li(i,l),p=Ac(null,i,f,s,p,l);var y=Ic();return i.flags|=1,typeof p=="object"&&p!==null&&typeof p.render=="function"&&p.$$typeof===void 0?(i.tag=1,i.memoizedState=null,i.updateQueue=null,an(f)?(y=!0,Na(i)):y=!1,i.memoizedState=p.state!==null&&p.state!==void 0?p.state:null,gc(i),p.updater=La,i.stateNode=p,p._reactInternals=i,vc(i,f,s,l),i=Rc(null,i,f,!0,y,l)):(i.tag=0,ct&&y&&oc(i),Xt(null,i,p,l),i=i.child),i;case 16:f=i.elementType;e:{switch(qa(s,i),s=i.pendingProps,p=f._init,f=p(f._payload),i.type=f,p=i.tag=Lx(f),s=Bn(f,s),p){case 0:i=Mc(null,i,f,s,l);break e;case 1:i=hg(null,i,f,s,l);break e;case 11:i=og(null,i,f,s,l);break e;case 14:i=ag(null,i,f,Bn(f.type,s),l);break e}throw Error(t(306,f,""))}return i;case 0:return f=i.type,p=i.pendingProps,p=i.elementType===f?p:Bn(f,p),Mc(s,i,f,p,l);case 1:return f=i.type,p=i.pendingProps,p=i.elementType===f?p:Bn(f,p),hg(s,i,f,p,l);case 3:e:{if(fg(i),s===null)throw Error(t(387));f=i.pendingProps,y=i.memoizedState,p=y.element,xm(s,i),Fa(i,f,null,l);var b=i.memoizedState;if(f=b.element,y.isDehydrated)if(y={element:f,isDehydrated:!1,cache:b.cache,pendingSuspenseBoundaries:b.pendingSuspenseBoundaries,transitions:b.transitions},i.updateQueue.baseState=y,i.memoizedState=y,i.flags&256){p=hi(Error(t(423)),i),i=dg(s,i,f,l,p);break e}else if(f!==p){p=hi(Error(t(424)),i),i=dg(s,i,f,l,p);break e}else for(yn=Lr(i.stateNode.containerInfo.firstChild),gn=i,ct=!0,Pn=null,l=$m(i,null,f,l),i.child=l;l;)l.flags=l.flags&-3|4096,l=l.sibling;else{if(oi(),f===p){i=Ir(s,i,l);break e}Xt(s,i,f,l)}i=i.child}return i;case 5:return Mm(i),s===null&&uc(i),f=i.type,p=i.pendingProps,y=s!==null?s.memoizedProps:null,b=p.children,ec(f,p)?b=null:y!==null&&ec(f,y)&&(i.flags|=32),cg(s,i),Xt(s,i,b,l),i.child;case 6:return s===null&&uc(i),null;case 13:return pg(s,i,l);case 4:return wc(i,i.stateNode.containerInfo),f=i.pendingProps,s===null?i.child=ui(i,null,f,l):Xt(s,i,f,l),i.child;case 11:return f=i.type,p=i.pendingProps,p=i.elementType===f?p:Bn(f,p),og(s,i,f,p,l);case 7:return Xt(s,i,i.pendingProps,l),i.child;case 8:return Xt(s,i,i.pendingProps.children,l),i.child;case 12:return Xt(s,i,i.pendingProps.children,l),i.child;case 10:e:{if(f=i.type._context,p=i.pendingProps,y=i.memoizedProps,b=p.value,tt(Ma,f._currentValue),f._currentValue=b,y!==null)if(On(y.value,b)){if(y.children===p.children&&!on.current){i=Ir(s,i,l);break e}}else for(y=i.child,y!==null&&(y.return=i);y!==null;){var C=y.dependencies;if(C!==null){b=y.child;for(var M=C.firstContext;M!==null;){if(M.context===f){if(y.tag===1){M=Ar(-1,l&-l),M.tag=2;var K=y.updateQueue;if(K!==null){K=K.shared;var ie=K.pending;ie===null?M.next=M:(M.next=ie.next,ie.next=M),K.pending=M}}y.lanes|=l,M=y.alternate,M!==null&&(M.lanes|=l),pc(y.return,l,i),C.lanes|=l;break}M=M.next}}else if(y.tag===10)b=y.type===i.type?null:y.child;else if(y.tag===18){if(b=y.return,b===null)throw Error(t(341));b.lanes|=l,C=b.alternate,C!==null&&(C.lanes|=l),pc(b,l,i),b=y.sibling}else b=y.child;if(b!==null)b.return=y;else for(b=y;b!==null;){if(b===i){b=null;break}if(y=b.sibling,y!==null){y.return=b.return,b=y;break}b=b.return}y=b}Xt(s,i,p.children,l),i=i.child}return i;case 9:return p=i.type,f=i.pendingProps.children,li(i,l),p=xn(p),f=f(p),i.flags|=1,Xt(s,i,f,l),i.child;case 14:return f=i.type,p=Bn(f,i.pendingProps),p=Bn(f.type,p),ag(s,i,f,p,l);case 15:return lg(s,i,i.type,i.pendingProps,l);case 17:return f=i.type,p=i.pendingProps,p=i.elementType===f?p:Bn(f,p),qa(s,i),i.tag=1,an(f)?(s=!0,Na(i)):s=!1,li(i,l),Nm(i,f,p),vc(i,f,p,l),Rc(null,i,f,!0,s,l);case 19:return gg(s,i,l);case 22:return ug(s,i,l)}throw Error(t(156,i.tag))};function Bg(s,i){return vp(s,i)}function Fx(s,i,l,f){this.tag=s,this.key=l,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.ref=null,this.pendingProps=i,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=f,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function In(s,i,l,f){return new Fx(s,i,l,f)}function eh(s){return s=s.prototype,!(!s||!s.isReactComponent)}function Lx(s){if(typeof s=="function")return eh(s)?1:0;if(s!=null){if(s=s.$$typeof,s===me)return 11;if(s===Ne)return 14}return 2}function Kr(s,i){var l=s.alternate;return l===null?(l=In(s.tag,i,s.key,s.mode),l.elementType=s.elementType,l.type=s.type,l.stateNode=s.stateNode,l.alternate=s,s.alternate=l):(l.pendingProps=i,l.type=s.type,l.flags=0,l.subtreeFlags=0,l.deletions=null),l.flags=s.flags&14680064,l.childLanes=s.childLanes,l.lanes=s.lanes,l.child=s.child,l.memoizedProps=s.memoizedProps,l.memoizedState=s.memoizedState,l.updateQueue=s.updateQueue,i=s.dependencies,l.dependencies=i===null?null:{lanes:i.lanes,firstContext:i.firstContext},l.sibling=s.sibling,l.index=s.index,l.ref=s.ref,l}function rl(s,i,l,f,p,y){var b=2;if(f=s,typeof s=="function")eh(s)&&(b=1);else if(typeof s=="string")b=5;else e:switch(s){case Y:return Is(l.children,p,y,i);case Z:b=8,p|=8;break;case ne:return s=In(12,l,i,p|2),s.elementType=ne,s.lanes=y,s;case ve:return s=In(13,l,i,p),s.elementType=ve,s.lanes=y,s;case be:return s=In(19,l,i,p),s.elementType=be,s.lanes=y,s;case Ee:return sl(l,p,y,i);default:if(typeof s=="object"&&s!==null)switch(s.$$typeof){case oe:b=10;break e;case de:b=9;break e;case me:b=11;break e;case Ne:b=14;break e;case Ie:b=16,f=null;break e}throw Error(t(130,s==null?s:typeof s,""))}return i=In(b,l,i,p),i.elementType=s,i.type=f,i.lanes=y,i}function Is(s,i,l,f){return s=In(7,s,f,i),s.lanes=l,s}function sl(s,i,l,f){return s=In(22,s,f,i),s.elementType=Ee,s.lanes=l,s.stateNode={isHidden:!1},s}function th(s,i,l){return s=In(6,s,null,i),s.lanes=l,s}function nh(s,i,l){return i=In(4,s.children!==null?s.children:[],s.key,i),i.lanes=l,i.stateNode={containerInfo:s.containerInfo,pendingChildren:null,implementation:s.implementation},i}function Ox(s,i,l,f,p){this.tag=i,this.containerInfo=s,this.finishedWork=this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.pendingContext=this.context=null,this.callbackPriority=0,this.eventTimes=Cu(0),this.expirationTimes=Cu(-1),this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=Cu(0),this.identifierPrefix=f,this.onRecoverableError=p,this.mutableSourceEagerHydrationData=null}function rh(s,i,l,f,p,y,b,C,M){return s=new Ox(s,i,l,C,M),i===1?(i=1,y===!0&&(i|=8)):i=0,y=In(3,null,null,i),s.current=y,y.stateNode=s,y.memoizedState={element:f,isDehydrated:l,cache:null,transitions:null,pendingSuspenseBoundaries:null},gc(y),s}function Px(s,i,l){var f=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null;return{$$typeof:H,key:f==null?null:""+f,children:s,containerInfo:i,implementation:l}}function Ug(s){if(!s)return Pr;s=s._reactInternals;e:{if(ps(s)!==s||s.tag!==1)throw Error(t(170));var i=s;do{switch(i.tag){case 3:i=i.stateNode.context;break e;case 1:if(an(i.type)){i=i.stateNode.__reactInternalMemoizedMergedChildContext;break e}}i=i.return}while(i!==null);throw Error(t(171))}if(s.tag===1){var l=s.type;if(an(l))return pm(s,l,i)}return i}function jg(s,i,l,f,p,y,b,C,M){return s=rh(l,f,!0,s,p,y,b,C,M),s.context=Ug(null),l=s.current,f=Yt(),p=qr(l),y=Ar(f,p),y.callback=i??null,jr(l,y,p),s.current.lanes=p,Hi(s,p,f),cn(s,f),s}function il(s,i,l,f){var p=i.current,y=Yt(),b=qr(p);return l=Ug(l),i.context===null?i.context=l:i.pendingContext=l,i=Ar(y,b),i.payload={element:s},f=f===void 0?null:f,f!==null&&(i.callback=f),s=jr(p,i,b),s!==null&&(Wn(s,p,b,y),_a(s,p,b)),b}function ol(s){return s=s.current,s.child?(s.child.tag===5,s.child.stateNode):null}function Wg(s,i){if(s=s.memoizedState,s!==null&&s.dehydrated!==null){var l=s.retryLane;s.retryLane=l!==0&&l<i?l:i}}function sh(s,i){Wg(s,i),(s=s.alternate)&&Wg(s,i)}function Bx(){return null}var Vg=typeof reportError=="function"?reportError:function(s){console.error(s)};function ih(s){this._internalRoot=s}al.prototype.render=ih.prototype.render=function(s){var i=this._internalRoot;if(i===null)throw Error(t(409));il(s,i,null,null)},al.prototype.unmount=ih.prototype.unmount=function(){var s=this._internalRoot;if(s!==null){this._internalRoot=null;var i=s.containerInfo;xs(function(){il(null,s,null,null)}),i[br]=null}};function al(s){this._internalRoot=s}al.prototype.unstable_scheduleHydration=function(s){if(s){var i=Ip();s={blockedOn:null,target:s,priority:i};for(var l=0;l<Rr.length&&i!==0&&i<Rr[l].priority;l++);Rr.splice(l,0,s),l===0&&Cp(s)}};function oh(s){return!(!s||s.nodeType!==1&&s.nodeType!==9&&s.nodeType!==11)}function ll(s){return!(!s||s.nodeType!==1&&s.nodeType!==9&&s.nodeType!==11&&(s.nodeType!==8||s.nodeValue!==" react-mount-point-unstable "))}function Gg(){}function Ux(s,i,l,f,p){if(p){if(typeof f=="function"){var y=f;f=function(){var K=ol(b);y.call(K)}}var b=jg(i,f,s,0,null,!1,!1,"",Gg);return s._reactRootContainer=b,s[br]=b.current,ao(s.nodeType===8?s.parentNode:s),xs(),b}for(;p=s.lastChild;)s.removeChild(p);if(typeof f=="function"){var C=f;f=function(){var K=ol(M);C.call(K)}}var M=rh(s,0,!1,null,null,!1,!1,"",Gg);return s._reactRootContainer=M,s[br]=M.current,ao(s.nodeType===8?s.parentNode:s),xs(function(){il(i,M,l,f)}),M}function ul(s,i,l,f,p){var y=l._reactRootContainer;if(y){var b=y;if(typeof p=="function"){var C=p;p=function(){var M=ol(b);C.call(M)}}il(i,b,s,p)}else b=Ux(l,i,s,p,f);return ol(b)}Ep=function(s){switch(s.tag){case 3:var i=s.stateNode;if(i.current.memoizedState.isDehydrated){var l=qi(i.pendingLanes);l!==0&&(Du(i,l|1),cn(i,bt()),(Ge&6)===0&&(pi=bt()+500,Br()))}break;case 13:xs(function(){var f=Er(s,1);if(f!==null){var p=Yt();Wn(f,s,1,p)}}),sh(s,1)}},zu=function(s){if(s.tag===13){var i=Er(s,134217728);if(i!==null){var l=Yt();Wn(i,s,134217728,l)}sh(s,134217728)}},Ap=function(s){if(s.tag===13){var i=qr(s),l=Er(s,i);if(l!==null){var f=Yt();Wn(l,s,i,f)}sh(s,i)}},Ip=function(){return Ze},Tp=function(s,i){var l=Ze;try{return Ze=s,i()}finally{Ze=l}},xu=function(s,i,l){switch(i){case"input":if(wt(s,l),i=l.name,l.type==="radio"&&i!=null){for(l=s;l.parentNode;)l=l.parentNode;for(l=l.querySelectorAll("input[name="+JSON.stringify(""+i)+'][type="radio"]'),i=0;i<l.length;i++){var f=l[i];if(f!==s&&f.form===s.form){var p=Ia(f);if(!p)throw Error(t(90));ge(f),wt(f,p)}}}break;case"textarea":nr(s,l);break;case"select":i=l.value,i!=null&&Ct(s,!!l.multiple,i,!1)}},hp=Yc,fp=xs;var jx={usingClientEntryPoint:!1,Events:[co,ti,Ia,up,cp,Yc]},Ao={findFiberByHostInstance:ms,bundleType:0,version:"18.2.0",rendererPackageName:"react-dom"},Wx={bundleType:Ao.bundleType,version:Ao.version,rendererPackageName:Ao.rendererPackageName,rendererConfig:Ao.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setErrorHandler:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:$.ReactCurrentDispatcher,findHostInstanceByFiber:function(s){return s=gp(s),s===null?null:s.stateNode},findFiberByHostInstance:Ao.findFiberByHostInstance||Bx,findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null,reconcilerVersion:"18.2.0-next-9e3b772b8-20220608"};if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"){var cl=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!cl.isDisabled&&cl.supportsFiber)try{aa=cl.inject(Wx),rr=cl}catch{}}return hn.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=jx,hn.createPortal=function(s,i){var l=2<arguments.length&&arguments[2]!==void 0?arguments[2]:null;if(!oh(i))throw Error(t(200));return Px(s,i,null,l)},hn.createRoot=function(s,i){if(!oh(s))throw Error(t(299));var l=!1,f="",p=Vg;return i!=null&&(i.unstable_strictMode===!0&&(l=!0),i.identifierPrefix!==void 0&&(f=i.identifierPrefix),i.onRecoverableError!==void 0&&(p=i.onRecoverableError)),i=rh(s,1,!1,null,null,l,!1,f,p),s[br]=i.current,ao(s.nodeType===8?s.parentNode:s),new ih(i)},hn.findDOMNode=function(s){if(s==null)return null;if(s.nodeType===1)return s;var i=s._reactInternals;if(i===void 0)throw typeof s.render=="function"?Error(t(188)):(s=Object.keys(s).join(","),Error(t(268,s)));return s=gp(i),s=s===null?null:s.stateNode,s},hn.flushSync=function(s){return xs(s)},hn.hydrate=function(s,i,l){if(!ll(i))throw Error(t(200));return ul(null,s,i,!0,l)},hn.hydrateRoot=function(s,i,l){if(!oh(s))throw Error(t(405));var f=l!=null&&l.hydratedSources||null,p=!1,y="",b=Vg;if(l!=null&&(l.unstable_strictMode===!0&&(p=!0),l.identifierPrefix!==void 0&&(y=l.identifierPrefix),l.onRecoverableError!==void 0&&(b=l.onRecoverableError)),i=jg(i,null,s,1,l??null,p,!1,y,b),s[br]=i.current,ao(s),f)for(s=0;s<f.length;s++)l=f[s],p=l._getVersion,p=p(l._source),i.mutableSourceEagerHydrationData==null?i.mutableSourceEagerHydrationData=[l,p]:i.mutableSourceEagerHydrationData.push(l,p);return new al(i)},hn.render=function(s,i,l){if(!ll(i))throw Error(t(200));return ul(null,s,i,!1,l)},hn.unmountComponentAtNode=function(s){if(!ll(s))throw Error(t(40));return s._reactRootContainer?(xs(function(){ul(null,null,s,!1,function(){s._reactRootContainer=null,s[br]=null})}),!0):!1},hn.unstable_batchedUpdates=Yc,hn.unstable_renderSubtreeIntoContainer=function(s,i,l,f){if(!ll(l))throw Error(t(200));if(s==null||s._reactInternals===void 0)throw Error(t(38));return ul(s,i,l,!1,f)},hn.version="18.2.0-next-9e3b772b8-20220608",hn}var Qg;function Qx(){if(Qg)return uh.exports;Qg=1;function n(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(n)}catch(e){console.error(e)}}return n(),uh.exports=Zx(),uh.exports}var ey;function eE(){if(ey)return hl;ey=1;var n=Qx();return hl.createRoot=n.createRoot,hl.hydrateRoot=n.hydrateRoot,hl}var tE=eE();const nE=Xf(tE);const rE=1e-7,sE=1e-4;class iE{refCount(e){return wn("refCount")}incRef(e){return wn("incRef")}timerAvailable(){return!0}time(e){return wn("time")}read(e){return wn("read")}readSync(e){return wn("readSync")}readToGPU(e,t){return wn("readToGPU")}numDataIds(){return wn("numDataIds")}disposeData(e,t){return wn("disposeData")}write(e,t,r){return wn("write")}move(e,t,r,o,a){return wn("move")}memory(){return wn("memory")}floatPrecision(){return wn("floatPrecision")}epsilon(){return this.floatPrecision()===32?rE:sE}dispose(){return wn("dispose")}}function wn(n){throw new Error(`'${n}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}function _o(n){let e=n.length,t=0;for(;e>0;)t=Math.random()*e|0,e--,oE(n,e,t)}function oE(n,e,t){const r=n[e];n[e]=n[t],n[t]=r}function E(n,e){if(!n)throw new Error(typeof e=="string"?e:e())}function aE(n,e,t=""){E(nn(n,e),()=>t+` Shapes ${n} and ${e} must match`)}function Ql(n){E(n!=null,()=>"The input to the tensor constructor must be a non-null value.")}function eu(n,e=[],t=!1){if(e==null&&(e=[]),Array.isArray(n)||Xn(n)&&!t)for(let r=0;r<n.length;++r)eu(n[r],e,t);else e.push(n);return e}function tn(n){if(n.length===0)return 1;let e=n[0];for(let t=1;t<n.length;t++)e*=n[t];return e}function nn(n,e){if(n===e)return!0;if(n==null||e==null||n.length!==e.length)return!1;for(let t=0;t<n.length;t++)if(n[t]!==e[t])return!1;return!0}function Ml(n){return n%1===0}function bl(n,e){return e<=n.length?n:n+" ".repeat(e-n.length)}function vr(n,e){const t=e.length;return n=n==null?e.map((r,o)=>o):[].concat(n),E(n.every(r=>r>=-t&&r<t),()=>`All values in axis param must be in range [-${t}, ${t}) but got axis ${n}`),E(n.every(r=>Ml(r)),()=>`All values in axis param must be integers but got axis ${n}`),n.map(r=>r<0?t+r:r)}function lE(n,e){const t=[],r=[],o=e!=null&&Array.isArray(e)&&e.length===0,a=e==null||o?null:vr(e,n).sort();let u=0;for(let c=0;c<n.length;++c){if(a!=null){if(a[u]===c&&n[c]!==1)throw new Error(`Can't squeeze axis ${c} since its dim '${n[c]}' is not 1`);(a[u]==null||a[u]>c)&&n[c]===1&&(t.push(n[c]),r.push(c)),a[u]<=c&&u++}n[c]!==1&&(t.push(n[c]),r.push(c))}return{newShape:t,keptDims:r}}function uE(n,e){let t=null;if(n==null||n==="float32")t=new Float32Array(e);else if(n==="int32")t=new Int32Array(e);else if(n==="bool")t=new Uint8Array(e);else if(n==="string")t=new Array(e);else throw new Error(`Unknown data type ${n}`);return t}function cE(n,e){for(let t=0;t<n.length;t++){const r=n[t];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${e} being uploaded contains ${r}.`)}}function hE(n){return n==="bool"||n==="complex64"||n==="float32"||n==="int32"||n==="string"}function Xn(n){return n instanceof Float32Array||n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray}function ty(n){if(n==="float32"||n==="int32")return 4;if(n==="complex64")return 8;if(n==="bool")return 1;throw new Error(`Unknown dtype ${n}`)}function fE(n){if(n==null)return 0;let e=0;return n.forEach(t=>e+=t.length),e}function Zf(n){return typeof n=="string"||n instanceof String}function dE(n){return typeof n=="boolean"}function Ef(n){return typeof n=="number"}function Qf(n){return Array.isArray(n)?Qf(n[0]):n instanceof Float32Array?"float32":n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray?"int32":Ef(n)?"float32":Zf(n)?"string":dE(n)?"bool":"float32"}function Af(n){return!!(n&&n.constructor&&n.call&&n.apply)}function ed(n){const e=n.length;if(e<2)return[];const t=new Array(e-1);t[e-2]=n[e-1];for(let r=e-3;r>=0;--r)t[r]=t[r+1]*n[r+1];return t}function mw(n,e,t,r=!1){const o=new Array;if(e.length===1){const a=e[0]*(r?2:1);for(let u=0;u<a;u++)o[u]=t[n+u]}else{const a=e[0],u=e.slice(1),c=u.reduce((h,d)=>h*d)*(r?2:1);for(let h=0;h<a;h++)o[h]=mw(n+h*c,u,t,r)}return o}function ny(n,e,t=!1){if(n.length===0)return e[0];const r=n.reduce((o,a)=>o*a)*(t?2:1);if(r===0)return[];if(r!==e.length)throw new Error(`[${n}] does not match the input size ${e.length}${t?" for a complex tensor":""}.`);return mw(0,n,e,t)}function gw(n,e){const t=td(n,e);for(let r=0;r<t.length;r++)t[r]=1;return t}function td(n,e){if(e==null||e==="float32"||e==="complex64")return new Float32Array(n);if(e==="int32")return new Int32Array(n);if(e==="bool")return new Uint8Array(n);throw new Error(`Unknown data type ${e}`)}function yw(n){n.forEach(e=>{E(Number.isInteger(e)&&e>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${n}].`)})}function nd(n){return n&&n.then&&typeof n.then=="function"}const ry="tfjsflags";class pE{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=mE,this.populateURLFlags()}setPlatform(e,t){this.platform!=null&&(Ke().getBool("IS_TEST")||Ke().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=t}registerFlag(e,t,r){if(this.flagRegistry[e]={evaluationFn:t,setHook:r},this.urlFlags[e]!=null){const o=this.urlFlags[e];Ke().getBool("IS_TEST")||Ke().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${o}.`),this.set(e,o)}}async getAsync(e){return e in this.flags?this.flags[e]:(this.flags[e]=await this.evaluateFlag(e),this.flags[e])}get(e){if(e in this.flags)return this.flags[e];const t=this.evaluateFlag(e);if(nd(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(this.flagRegistry[e]==null)throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,this.flagRegistry[e].setHook!=null&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(this.flagRegistry[e]==null)throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const e=this.getQueryParams(this.global.location.search);ry in e&&e[ry].split(",").forEach(r=>{const[o,a]=r.split(":");this.urlFlags[o]=yE(o,a)})}}function mE(n){const e={};return n.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(t,...r)=>(gE(e,r[0],r[1]),r.join("="))),e}function gE(n,e,t){n[decodeURIComponent(e)]=decodeURIComponent(t||"")}function yE(n,e){if(e=e.toLowerCase(),e==="true"||e==="false")return e==="true";if(`${+e}`===e)return+e;throw new Error(`Could not parse value flag value ${e} for flag ${n}.`)}function Ke(){return vw}let vw=null;function vE(n){vw=n}let fh;function ww(){if(fh==null){let n;if(typeof window<"u")n=window;else if(typeof global<"u")n=global;else if(typeof process<"u")n=process;else if(typeof self<"u")n=self;else throw new Error("Could not find a global object");fh=n}return fh}function wE(){const n=ww();return n._tfGlobals==null&&(n._tfGlobals=new Map),n._tfGlobals}function rd(n,e){const t=wE();if(t.has(n))return t.get(n);{const r=e();return t.set(n,r),t.get(n)}}const bw="Abs",bE="Acos",kE="Acosh",sd="Add",SE="AddN",xE="All",EE="Any",kw="ArgMax",AE="ArgMin",IE="Asin",TE="Asinh",NE="Atan",CE="Atanh",DE="Atan2",Sw="AvgPool",zE="AvgPoolGrad",xw="AvgPool3D",$E="AvgPool3DGrad",Ew="BatchMatMul",Aw="BatchToSpaceND",ME="Bincount",RE="BroadcastTo",id="Cast",_E="Ceil",Iw="ClipByValue",FE="Complex",Tw="ComplexAbs",Nw="Concat",Cw="Conv2D",LE="Conv2DBackpropFilter",Dw="Conv2DBackpropInput",zw="Conv3D",OE="Conv3DBackpropFilterV2",PE="Conv3DBackpropInputV2",$w="Cos",Mw="Cosh",BE="Cumprod",Rw="Cumsum",UE="CropAndResize",_w="DepthwiseConv2dNative",jE="DepthwiseConv2dNativeBackpropFilter",WE="DepthwiseConv2dNativeBackpropInput",VE="Dilation2D",GE="Dilation2DBackpropInput",qE="Dilation2DBackpropFilter",Fw="RealDiv",Lw="Elu",HE="EluGrad",KE="Erf",JE="Equal",Ow="Exp",Pw="ExpandDims",XE="Expm1";const YE="Fill",ZE="FlipLeftRight",Bw="Floor",Uw="FloorDiv",jw="FusedBatchNorm",Ww="GatherV2",QE="Greater",Vw="GreaterEqual",od="Identity";const eA="Imag",tA="IsFinite",nA="IsInf",rA="IsNan",Gw="LeakyRelu",sA="Less",iA="LessEqual",qw="Log",Hw="Log1p",oA="LogicalAnd",aA="LogicalNot",lA="LogSoftmax",uA="LRN",cA="LRNGrad",Kw="Max",Jw="Maximum",Xw="MaxPool",hA="MaxPoolGrad",Yw="MaxPool3D",fA="MaxPool3DGrad",Zw="Mean",Qw="Min",e0="Minimum",dA="MirrorPad",pA="Mod",t0="Multiply",n0="Neg",mA="NotEqual",gA="NonMaxSuppressionV3",yA="NonMaxSuppressionV4",vA="NonMaxSuppressionV5",r0="OnesLike",s0="OneHot",i0="Pack",o0="PadV2",a0="Pow",l0="Prelu",wA="Prod",bA="Range",kA="Real",SA="Reciprocal",u0="Relu",c0="Reshape",h0="ResizeNearestNeighbor",xA="ResizeNearestNeighborGrad",f0="ResizeBilinear",EA="ResizeBilinearGrad",d0="Relu6",p0="Reverse",m0="Round",g0="Rsqrt",y0="Select",v0="Selu",w0="Slice",b0="Sin",k0="Sinh",AA="Sign",S0="Sigmoid",x0="Softplus",E0="Sqrt",A0="Sum",I0="SpaceToBatchND",T0="SplitV",N0="Softmax";const IA="SquaredDifference",TA="Square";const C0="Sub",NA="Tan",D0="Tanh",ad="Tile",CA="Transform",kl="Transpose",z0="Unpack",$0="UnsortedSegmentSum",M0="ZerosLike",R0="Step",DA="RotateWithOffset",sy="_FusedMatMul",iy="FusedConv2D";function wi(...n){Ke().getBool("IS_TEST")||Ke().getBool("PROD")||console.warn(...n)}const _0=rd("kernelRegistry",()=>new Map),If=rd("gradRegistry",()=>new Map);function oy(n,e){const t=$A(n,e);return _0.get(t)}function ay(n){return If.get(n)}function ly(n){const e=_0.entries(),t=[];for(;;){const{done:r,value:o}=e.next();if(r)break;const[a,u]=o,[c]=a.split("_");c===n&&t.push(u)}return t}function zA(n){const{kernelName:e}=n;If.has(e)&&Ke().getBool("DEBUG")&&wi(`Overriding the gradient for '${e}'`),If.set(e,n)}function $A(n,e){return`${e}_${n}`}function MA(n,e){return n instanceof Float32Array&&e==="float32"||n instanceof Int32Array&&e==="int32"||n instanceof Uint8Array&&e==="bool"}function F0(n,e){if(e==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(n)&&(n=eu(n)),Ke().getBool("DEBUG")&&cE(n,e),MA(n,e))return n;if(e==null||e==="float32"||e==="complex64")return new Float32Array(n);if(e==="int32")return new Int32Array(n);if(e==="bool"){const t=new Uint8Array(n.length);for(let r=0;r<t.length;++r)Math.round(n[r])!==0&&(t[r]=1);return t}else throw new Error(`Unknown data type ${e}`)}function zn(){return Ke().platform.now()}function RA(n,e="utf-8"){return e=e||"utf-8",Ke().platform.encode(n,e)}function uy(n,e="utf-8"){return e=e||"utf-8",Ke().platform.decode(n,e)}class _A{constructor(e,t){this.backendTimer=e,this.logger=t,t==null&&(this.logger=new LA)}profileKernel(e,t,r){let o;const a=()=>{o=r()};let u;const c=zn();if(this.backendTimer.timerAvailable())u=this.backendTimer.time(a);else{a();for(const d of o)d.dataSync();u=Promise.resolve({kernelMs:zn()-c})}if(Ke().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let d=0;d<o.length;d++){const m=o[d];m.data().then(g=>{FA(g,m.dtype,e)})}return{kernelName:e,outputs:o,inputs:t,timeMs:u.then(d=>d.kernelMs),extraInfo:u.then(d=>d.getExtraProfileInfo!=null?d.getExtraProfileInfo():"")}}logKernelProfile(e){const{kernelName:t,outputs:r,timeMs:o,inputs:a,extraInfo:u}=e;r.forEach(c=>{Promise.all([c.data(),o,u]).then(h=>{this.logger.logKernelProfile(t,c,h[0],h[1],a,h[2])})})}}function FA(n,e,t){if(e!=="float32")return!1;for(let r=0;r<n.length;r++){const o=n[r];if(isNaN(o)||!isFinite(o))return console.warn(`Found ${o} in the result of '${t}'`),!0}return!1}class LA{logKernelProfile(e,t,r,o,a,u){const c=typeof o=="number"?bl(`${o}ms`,9):o.error,h=bl(e,25),d=t.rank,m=t.size,g=bl(t.shape.toString(),14);let v="";for(const w in a){const k=a[w];if(k!=null){const S=k.shape||t.shape,x=S.length;v+=`${w}: ${x}D ${x>0?S:""} `}}console.log(`%c${h}	%c${c}	%c${d}D ${g}	%c${m}	%c${v}	%c${u}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}function OA(n,e,t){const r={},o={};for(let h=0;h<e.length;h++)r[e[h].id]=!0;for(let h=0;h<n.length;h++){const d=n[h],m=d.inputs;for(const g in m){const v=m[g];let w=!1;for(let k=0;k<e.length;k++)if(r[v.id]){d.outputs.forEach(S=>r[S.id]=!0),w=!0,o[d.id]=!0;break}if(w)break}}const a={};a[t.id]=!0;const u={};for(let h=n.length-1;h>=0;h--){const d=n[h],m=d.inputs;for(let g=0;g<d.outputs.length;g++)if(a[d.outputs[g].id]){for(const v in m)a[m[v].id]=!0,u[d.id]=!0;break}}const c=[];for(let h=0;h<n.length;h++){const d=n[h];if(o[d.id]&&u[d.id]){const m={};for(const v in d.inputs){const w=d.inputs[v];r[w.id]&&(m[v]=w)}const g=Object.assign({},d);g.inputs=m,g.outputs=d.outputs,c.push(g)}}return c}function PA(n,e,t,r){for(let o=e.length-1;o>=0;o--){const a=e[o],u=[];if(a.outputs.forEach(h=>{const d=n[h.id];d!=null?u.push(d):u.push(null)}),a.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${a.kernelName}.`);const c=a.gradient(u);for(const h in a.inputs){if(!(h in c))throw new Error(`Cannot backprop through input ${h}. Available gradients found: ${Object.keys(c)}.`);const d=t(()=>c[h]());if(d.dtype!=="float32")throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input ${h} must have 'float32' dtype, but has '${d.dtype}'`);const m=a.inputs[h];if(!nn(d.shape,m.shape))throw new Error(`Error in gradient for op ${a.kernelName}. The gradient of input '${h}' has shape '${d.shape}', which does not match the shape of the input '${m.shape}'`);if(n[m.id]==null)n[m.id]=d;else{const g=n[m.id];n[m.id]=r(g,d),g.dispose()}}}}const cy=20,To=3,dh=7;function BA(n,e,t,r){const o=ed(e),a=UA(n,e,t,o),u=e.length,c=Sl(n,e,t,o,a),h=["Tensor"];return r&&(h.push(`  dtype: ${t}`),h.push(`  rank: ${u}`),h.push(`  shape: [${e}]`),h.push("  values:")),h.push(c.map(d=>"    "+d).join(`
`)),h.join(`
`)}function UA(n,e,t,r){const o=tn(e),a=r[r.length-1],u=new Array(a).fill(0),c=e.length,h=t==="complex64"?Do(n):n;if(c>1)for(let d=0;d<o/a;d++){const m=d*a;for(let g=0;g<a;g++)u[g]=Math.max(u[g],Co(h[m+g],0,t).length)}return u}function Co(n,e,t){let r;return Array.isArray(n)?r=`${parseFloat(n[0].toFixed(dh))} + ${parseFloat(n[1].toFixed(dh))}j`:Zf(n)?r=`'${n}'`:t==="bool"?r=L0(n):r=parseFloat(n.toFixed(dh)).toString(),bl(r,e)}function L0(n){return n===0?"false":"true"}function Sl(n,e,t,r,o,a=!0){const u=t==="complex64"?2:1,c=e[0],h=e.length;if(h===0){if(t==="complex64"){const S=Do(n);return[Co(S[0],0,t)]}return t==="bool"?[L0(n[0])]:[n[0].toString()]}if(h===1){if(c>cy){const x=To*u;let T=Array.from(n.slice(0,x)),z=Array.from(n.slice((c-To)*u,c*u));return t==="complex64"&&(T=Do(T),z=Do(z)),["["+T.map((R,$)=>Co(R,o[$],t)).join(", ")+", ..., "+z.map((R,$)=>Co(R,o[c-To+$],t)).join(", ")+"]"]}return["["+(t==="complex64"?Do(n):Array.from(n)).map((x,T)=>Co(x,o[T],t)).join(", ")+"]"]}const d=e.slice(1),m=r.slice(1),g=r[0]*u,v=[];if(c>cy){for(let S=0;S<To;S++){const x=S*g,T=x+g;v.push(...Sl(n.slice(x,T),d,t,m,o,!1))}v.push("...");for(let S=c-To;S<c;S++){const x=S*g,T=x+g;v.push(...Sl(n.slice(x,T),d,t,m,o,S===c-1))}}else for(let S=0;S<c;S++){const x=S*g,T=x+g;v.push(...Sl(n.slice(x,T),d,t,m,o,S===c-1))}const w=h===2?",":"";v[0]="["+v[0]+w;for(let S=1;S<v.length-1;S++)v[S]=" "+v[S]+w;let k=`,
`;for(let S=2;S<h;S++)k+=`
`;return v[v.length-1]=" "+v[v.length-1]+"]"+(a?"":k),v}function Do(n){const e=[];for(let t=0;t<n.length;t+=2)e.push([n[t],n[t+1]]);return e}class jA{constructor(e,t,r){if(this.dtype=t,this.shape=e.slice(),this.size=tn(e),r!=null){const o=r.length;E(o===this.size,()=>`Length of values '${o}' does not match the size inferred by the shape '${this.size}'.`)}if(t==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=r||uE(t,this.size),this.strides=ed(e)}set(e,...t){t.length===0&&(t=[0]),E(t.length===this.rank,()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`);const r=this.locToIndex(t);this.values[r]=e}get(...e){e.length===0&&(e=[0]);let t=0;for(const o of e){if(o<0||o>=this.shape[t]){const a=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(a)}t++}let r=e[e.length-1];for(let o=0;o<e.length-1;++o)r+=this.strides[o]*e[o];return this.values[r]}locToIndex(e){if(this.rank===0)return 0;if(this.rank===1)return e[0];let t=e[e.length-1];for(let r=0;r<e.length-1;++r)t+=this.strides[r]*e[r];return t}indexToLoc(e){if(this.rank===0)return[];if(this.rank===1)return[e];const t=new Array(this.shape.length);for(let r=0;r<t.length-1;++r)t[r]=Math.floor(e/this.strides[r]),e-=t[r]*this.strides[r];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return Gn().makeTensor(this.values,this.shape,this.dtype)}}let Gn=null,bi=null;function WA(n){Gn=n}function VA(n){bi=n}class ot{constructor(e,t,r,o){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=tn(e),this.strides=ed(e),this.dataId=r,this.id=o,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return bi.buffer(this.shape,this.dtype,e)}bufferSync(){return bi.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return ny(this.shape,e,this.dtype==="complex64")}arraySync(){return ny(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const e=Gn().read(this.dataId);if(this.dtype==="string"){const t=await e;try{return t.map(r=>uy(r))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),Gn().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();const e=Gn().readSync(this.dataId);if(this.dtype==="string")try{return e.map(t=>uy(t))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await Gn().read(this.dataId);return this.dtype==="string"?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(Gn().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return bi.print(this,e)}clone(){return this.throwIfDisposed(),bi.clone(this)}toString(e=!1){const t=this.dataSync();return BA(t,this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),bi.cast(this,e)}variable(e=!0,t,r){return this.throwIfDisposed(),Gn().makeVariable(this,e,t,r)}}Object.defineProperty(ot,Symbol.hasInstance,{value:n=>!!n&&n.data!=null&&n.dataSync!=null&&n.throwIfDisposed!=null});function GA(){return rd("Tensor",()=>ot)}GA();class Rl extends ot{constructor(e,t,r,o){super(e.shape,e.dtype,e.dataId,o),this.trainable=t,this.name=r}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!nn(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);Gn().disposeTensor(this),this.dataId=e.dataId,Gn().incRef(this,null)}dispose(){Gn().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(Rl,Symbol.hasInstance,{value:n=>n instanceof ot&&n.assign!=null&&n.assign instanceof Function});var hy;(function(n){n.R0="R0",n.R1="R1",n.R2="R2",n.R3="R3",n.R4="R4",n.R5="R5",n.R6="R6"})(hy||(hy={}));var Tf;(function(n){n.float32="float32",n.int32="int32",n.bool="int32",n.complex64="complex64"})(Tf||(Tf={}));var Nf;(function(n){n.float32="float32",n.int32="int32",n.bool="bool",n.complex64="complex64"})(Nf||(Nf={}));var Cf;(function(n){n.float32="float32",n.int32="float32",n.bool="float32",n.complex64="complex64"})(Cf||(Cf={}));var Df;(function(n){n.float32="complex64",n.int32="complex64",n.bool="complex64",n.complex64="complex64"})(Df||(Df={}));const qA={float32:Cf,int32:Tf,bool:Nf,complex64:Df};function HA(n,e){if(n==="string"||e==="string"){if(n==="string"&&e==="string")return"string";throw new Error(`Can not upcast ${n} with ${e}`)}return qA[n][e]}function Pt(n,e){if(n.dtype===e.dtype)return[n,e];const t=HA(n.dtype,e.dtype);return[n.cast(t),e.cast(t)]}function ld(n,e){return e.some(t=>t.id===n.id)}function ts(n){const e=[];return O0(n,e,new Set),e}function O0(n,e,t){if(n==null)return;if(n instanceof ot){e.push(n);return}if(!KA(n))return;const r=n;for(const o in r){const a=r[o];t.has(a)||(t.add(a),O0(a,e,t))}}function KA(n){return Array.isArray(n)||typeof n=="object"}function ph(n){return n.kernelName!=null}class fy{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class Ti{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new fy}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const r=e[t];if(await this.initializeBackend(r).success){await this.setBackend(r);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){const{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry))if(e in this.registryFactory){const{asyncInit:t}=this.initializeBackend(e);if(t)return null}else return null;return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t,r=1){return e in this.registryFactory?(wi(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:r},!0)}async setBackend(e){if(this.registryFactory[e]==null)throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,this.registry[e]==null){this.backendInstance=null;const{success:t,asyncInit:r}=this.initializeBackend(e);if(!(r?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new _A(this.backendInstance),!0}setupRegisteredKernels(){ly(this.backendName).forEach(t=>{t.setupFunc!=null&&t.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){ly(e).forEach(r=>{r.disposeFunc!=null&&r.disposeFunc(this.registry[e])})}initializeBackend(e){const t=this.registryFactory[e];if(t==null)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const r=t.factory();if(r&&!(r instanceof iE)&&typeof r.then=="function"){const o=++this.pendingBackendInitId,a=r.then(u=>o<this.pendingBackendInitId?!1:(this.registry[e]=u,this.pendingBackendInit=null,!0)).catch(u=>(o<this.pendingBackendInitId||(this.pendingBackendInit=null,wi(`Initialization of backend ${e} failed`),wi(u.stack||u.message)),!1));return this.pendingBackendInit=a,{success:a,asyncInit:!0}}else return this.registry[e]=r,{success:!0,asyncInit:!1}}catch(r){return wi(`Initialization of backend ${e} failed`),wi(r.stack||r.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const r=e[t],{success:o,asyncInit:a}=this.initializeBackend(r);if(a||o)return{name:r,asyncInit:a}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){const r=this.state.tensorInfo.get(t),o=r.backend,a=this.readSync(t),u=o.refCount(t);o.disposeData(t,!0),r.backend=e,e.move(t,a,r.shape,r.dtype,u),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let r=null;if(t==null){if(typeof e!="function")throw new Error("Please provide a function to tidy()");t=e}else{if(typeof e!="string"&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof t!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=e}let o;return this.scopedRun(()=>this.startScope(r),()=>this.endScope(o),()=>(o=t(),o instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),o))}scopedRun(e,t,r){e();try{const o=r();return t(),o}catch(o){throw t(),o}}nextTensorId(){return Ti.nextTensorId++}nextVariableId(){return Ti.nextVariableId++}clone(e){const t=G.runKernel(od,{x:e}),r={x:e},o=u=>({x:()=>{const c="float32",h={x:u},d={dtype:c};return G.runKernel(id,h,d)}}),a=[];return this.addTapeNode(this.state.activeScope.name,r,[t],o,a,{}),t}runKernel(e,t,r){if(this.backendName==null&&this.backend,!(oy(e,this.backendName)!=null))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:r})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,r){const o=this.backend.numDataIds();let a=0;r.forEach(h=>{a+=h.dtype==="complex64"?3:1});const u=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],c=o-t-a-u;if(c>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${c} data ids) after running '${e}'`)}runKernelFunc(e){let t,r=[];const o=this.isTapeOn(),a=this.state.numBytes,u=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let c;this.backendName==null&&this.backend;let h;const d=ph(e)?e.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(ph(e)){const{kernelName:k,inputs:S,attrs:x}=e;this.backendName==null&&this.backend;const T=oy(k,this.backendName);E(T!=null,()=>`Cannot find registered kernel '${k}' for backend '${this.backendName}'`),c=()=>{const z=this.backend.numDataIds();h=T.kernelFunc({inputs:S,attrs:x,backend:this.backend});const R=Array.isArray(h)?h:[h];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(k,z,R);const $=R.map(B=>B.rank!=null?B:this.makeTensorFromTensorInfo(B));if(o){const B=this.getTensorsForGradient(k,S,$);r=this.saveTensorsForBackwardMode(B)}return $}}else{const{forwardFunc:k}=e,S=x=>{o&&(r=x.map(T=>this.keep(this.clone(T))))};c=()=>{const x=this.backend.numDataIds();h=this.tidy(()=>k(this.backend,S));const T=Array.isArray(h)?h:[h];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(d,x,T),T}}const{inputs:m,attrs:g}=e,v=ph(e)?null:e.backwardsFunc;let w;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?t=c():(w=this.profiler.profileKernel(d,m,()=>c()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(w),t=w.outputs)}),o&&this.addTapeNode(d,m,t,v,r,g),this.state.profiling&&this.state.activeProfile.kernels.push({name:d,bytesAdded:this.state.numBytes-a,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-u,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(m).map(k=>m[k]!=null?m[k].shape:null),outputShapes:t.map(k=>k.shape),kernelTimeMs:w.timeMs,extraInfo:w.extraInfo}),Array.isArray(h)?t:t[0]}saveTensorsForBackwardMode(e){return e.map(r=>this.keep(this.clone(r)))}getTensorsForGradient(e,t,r){const o=ay(e);if(o!=null){const a=o.inputsToSave||[],u=o.outputsToSave||[];let c;o.saveAllInputs?(E(Array.isArray(t),()=>"saveAllInputs is true, expected inputs to be an array."),c=Object.keys(t).map(d=>t[d])):c=a.map(d=>t[d]);const h=r.filter((d,m)=>u[m]);return c.concat(h)}return[]}makeTensor(e,t,r,o){if(e==null)throw new Error("Values passed to engine.makeTensor() are null");r=r||"float32",o=o||this.backend;let a=e;r==="string"&&Zf(e[0])&&(a=e.map(h=>RA(h)));const u=o.write(a,t,r),c=new ot(t,r,u,this.nextTensorId());if(this.trackTensor(c,o),r==="string"){const h=this.state.tensorInfo.get(u),d=fE(a);this.state.numBytes+=d-h.bytes,h.bytes=d}return c}makeTensorFromDataId(e,t,r,o){r=r||"float32";const a={dataId:e,shape:t,dtype:r};return this.makeTensorFromTensorInfo(a,o)}makeTensorFromTensorInfo(e,t){const{dataId:r,shape:o,dtype:a}=e,u=new ot(o,a,r,this.nextTensorId());return this.trackTensor(u,t),u}makeVariable(e,t=!0,r,o){r=r||this.nextVariableId().toString(),o!=null&&o!==e.dtype&&(e=e.cast(o));const a=new Rl(e,t,r,this.nextTensorId());if(this.state.registeredVariables[a.name]!=null)throw new Error(`Variable with name ${a.name} was already registered`);return this.state.registeredVariables[a.name]=a,this.incRef(a,this.backend),a}trackTensor(e,t){this.state.numTensors++,e.dtype==="string"&&this.state.numStringTensors++;let r=0;e.dtype!=="complex64"&&e.dtype!=="string"&&(r=e.size*ty(e.dtype)),this.state.numBytes+=r,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:r})),e instanceof Rl||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,e.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),e.dtype!=="complex64"&&e.dtype!=="string"){const r=e.size*ty(e.dtype);this.state.numBytes-=r}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),this.state.registeredVariables[e.name]!=null&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,e.reasons==null&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const t=this.state.numBytes,r=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(o=>o.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-r;for(const o of this.state.activeProfile.kernels)o.kernelTimeMs=await o.kernelTimeMs,o.extraInfo=await o.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(e,t,r,o,a,u){const c={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:r,saved:a},h=ay(e);h!=null&&(o=h.gradFunc),o!=null&&(c.gradient=d=>(d=d.map((m,g)=>{if(m==null){const v=r[g],w=td(v.size,v.dtype);return this.makeTensor(w,v.shape,v.dtype)}return m}),o(d.length>1?d:d[0],a,u))),this.state.activeTape.push(c)}keep(e){return e.kept=!0,e}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){const t=ts(e),r=new Set(t.map(a=>a.id));for(let a=0;a<this.state.activeScope.track.length;a++){const u=this.state.activeScope.track[a];!u.kept&&!r.has(u.id)&&u.dispose()}const o=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach(a=>{!a.kept&&a.scopeId===o.id&&this.track(a)})}gradients(e,t,r,o=!1){if(E(t.length>0,()=>"gradients() received an empty list of xs."),r!=null&&r.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${r.dtype}'`);const a=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));E(a instanceof ot,()=>"The result y returned by f() must be a tensor.");const u=OA(this.state.activeTape,t,a);if(!o&&u.length===0&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const c={};c[a.id]=r??JA(a.shape),PA(c,u,d=>this.tidy(d),XA);const h=t.map(d=>c[d.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(d=>{for(const m of d.saved)m.dispose()}),this.state.activeTape=null),{value:a,grads:h}})}customGrad(e){return E(Af(e),()=>"The f passed in customGrad(f) must be a function."),(...t)=>{E(t.every(c=>c instanceof ot),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let r;const o={};t.forEach((c,h)=>{o[h]=c});const a=(c,h)=>(r=e(...t,h),E(r.value instanceof ot,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),E(Af(r.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),r.value),u=(c,h)=>{const d=r.gradFunc(c,h),m=Array.isArray(d)?d:[d];E(m.length===t.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),E(m.every(v=>v instanceof ot),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const g={};return m.forEach((v,w)=>{g[w]=()=>v}),g};return this.runKernelFunc({forwardFunc:a,backwardsFunc:u,inputs:o})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,t){return this.state.tensorInfo.get(e).backend.readToGPU(e,t)}async time(e){const t=zn(),r=await this.backend.time(e);return r.wallMs=zn()-t,r}track(e){return this.state.activeScope!=null&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new fy;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}Ti.nextTensorId=0;Ti.nextVariableId=0;function JA(n){const e=gw(tn(n),"float32");return G.makeTensor(e,n,"float32")}function P0(){const n=ww();if(n._tfengine==null){const e=new pE(n);n._tfengine=new Ti(e)}return vE(n._tfengine.ENV),WA(()=>n._tfengine),n._tfengine}const G=P0();function XA(n,e){const t={a:n,b:e};return G.runKernel(sd,t)}function YA(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}const fn=Ke();fn.registerFlag("DEBUG",()=>!1,n=>{n&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});fn.registerFlag("IS_BROWSER",()=>YA());fn.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u");fn.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));fn.registerFlag("PROD",()=>!1);fn.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>fn.getBool("DEBUG"));fn.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);fn.registerFlag("IS_TEST",()=>!1);fn.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>!0);fn.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);fn.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);fn.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);fn.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);function Fi(n,e){let t=n;if(Xn(n))return e==="string"?[]:[n.length];if(!Array.isArray(n))return[];const r=[];for(;Array.isArray(t)||Xn(t)&&e!=="string";)r.push(t.length),t=t[0];return Array.isArray(n)&&Ke().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&B0(n,r,[]),r}function B0(n,e,t){if(t=t||[],!Array.isArray(n)&&!Xn(n)){E(e.length===0,()=>`Element arr[${t.join("][")}] is a primitive, but should be an array/TypedArray of ${e[0]} elements`);return}E(e.length>0,()=>`Element arr[${t.join("][")}] should be a primitive, but is an array of ${n.length} elements`),E(n.length===e[0],()=>`Element arr[${t.join("][")}] should have ${e[0]} elements, but has ${n.length} elements`);const r=e.slice(1);for(let o=0;o<n.length;++o)B0(n[o],r,t.concat(o))}function dy(n,e,t,r){if(n!=="string_or_numeric"){if(n==null)throw new Error("Expected dtype cannot be null.");if(n!=="numeric"&&n!==e||n==="numeric"&&e==="string")throw new Error(`Argument '${t}' passed to '${r}' must be ${n} tensor, but got ${e} tensor`)}}function O(n,e,t,r="numeric"){if(n instanceof ot)return dy(r,n.dtype,e,t),n;let o=Qf(n);if(o!=="string"&&["bool","int32","float32"].indexOf(r)>=0&&(o=r),dy(r,o,e,t),n==null||!Xn(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string"){const h=n==null?"null":n.constructor.name;throw new Error(`Argument '${e}' passed to '${t}' must be a Tensor or TensorLike, but got '${h}'`)}const a=Fi(n,o);!Xn(n)&&!Array.isArray(n)&&(n=[n]);const c=o!=="string"?F0(n,o):eu(n,[],!0);return G.makeTensor(c,a,o)}function U0(n,e,t,r="numeric"){if(!Array.isArray(n))throw new Error(`Argument ${e} passed to ${t} must be a \`Tensor[]\` or \`TensorLike[]\``);return n.map((a,u)=>O(a,`${e}[${u}]`,t,r))}const ZA="__op";function X(n){const e=Object.keys(n);if(e.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${e.length} keys.`);let t=e[0];const r=n[t];t.endsWith("_")&&(t=t.substring(0,t.length-1)),t=t+ZA;const o=(...a)=>{G.startScope(t);try{const u=r(...a);return nd(u)&&console.error("Cannot return a Promise inside of tidy."),G.endScope(u),u}catch(u){throw G.endScope(null),u}};return Object.defineProperty(o,"name",{value:t,configurable:!0}),o}function QA(n,e){const t=O(n,"real","complex"),r=O(e,"imag","complex");aE(t.shape,r.shape,`real and imag shapes, ${t.shape} and ${r.shape}, must match in call to tf.complex().`);const o={real:t,imag:r};return G.runKernel(FE,o)}const tu=X({complex_:QA});function Li(n,e,t,r){if(r==null&&(r=Qf(n)),r==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!Xn(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(e!=null){yw(e);const o=tn(e),a=tn(t);E(o===a,()=>`Based on the provided shape, [${e}], the tensor should have ${o} values but has ${a}`);for(let u=0;u<t.length;++u){const c=t[u],h=u===t.length-1?c!==tn(e.slice(u)):!0;E(t[u]===e[u]||!h,()=>`Error creating a new Tensor. Inferred shape (${t}) does not match the provided shape (${e}). `)}}return!Xn(n)&&!Array.isArray(n)&&(n=[n]),e=e||t,n=r!=="string"?F0(n,r):eu(n,[],!0),G.makeTensor(n,e,r)}function xi(n,e,t){const r=Fi(n,t);return Li(n,e,r,t)}const py={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};const _l=4;async function my(n,e){const t=[],r=[],o=Array.isArray(n)?n.map(u=>u.name):Object.keys(n);for(let u=0;u<o.length;++u){const c=o[u],h=Array.isArray(n)?n[u].tensor:n[c];if(h.dtype!=="float32"&&h.dtype!=="int32"&&h.dtype!=="bool"&&h.dtype!=="string"&&h.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${c}': ${h.dtype}`);const d={name:c,shape:h.shape,dtype:h.dtype};if(h.dtype==="string"){const m=new Promise(async g=>{const v=await h.bytes(),w=v.reduce((x,T)=>x+T.length,0)+_l*v.length,k=new Uint8Array(w);let S=0;for(let x=0;x<v.length;x++){const T=v[x],z=new Uint8Array(new Uint32Array([T.length]).buffer);k.set(z,S),S+=_l,k.set(T,S),S+=T.length}g(k)});r.push(m)}else r.push(h.data());e!=null&&(d.group=e),t.push(d)}const a=await Promise.all(r);return{data:t2(a),specs:t}}function e2(n,e){const t={};let r,o=0;for(const a of e){const u=a.name,c=a.dtype,h=a.shape,d=tn(h);let m;if("quantization"in a){const g=a.quantization;if(g.dtype==="uint8"||g.dtype==="uint16"){if(!("min"in g&&"scale"in g))throw new Error(`Weight ${a.name} with quantization ${g.dtype} doesn't have corresponding metadata min and scale.`)}else if(g.dtype==="float16"){if(c!=="float32")throw new Error(`Weight ${a.name} is quantized with ${g.dtype} which only supports weights of type float32 not ${c}.`)}else throw new Error(`Weight ${a.name} has unknown quantization dtype ${g.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);const v=py[g.dtype],w=n.slice(o,o+d*v),k=g.dtype==="uint8"?new Uint8Array(w):new Uint16Array(w);if(c==="float32")if(g.dtype==="uint8"||g.dtype==="uint16"){m=new Float32Array(k.length);for(let S=0;S<k.length;S++){const x=k[S];m[S]=x*g.scale+g.min}}else if(g.dtype==="float16")r===void 0&&(r=h2()),m=r(k);else throw new Error(`Unsupported quantization type ${g.dtype} for weight type float32.`);else if(c==="int32"){if(g.dtype!=="uint8"&&g.dtype!=="uint16")throw new Error(`Unsupported quantization type ${g.dtype} for weight type int32.`);m=new Int32Array(k.length);for(let S=0;S<k.length;S++){const x=k[S];m[S]=Math.round(x*g.scale+g.min)}}else throw new Error(`Unsupported dtype in weight '${u}': ${c}`);o+=d*v}else if(c==="string"){const g=tn(a.shape);m=[];for(let v=0;v<g;v++){const w=new Uint32Array(n.slice(o,o+_l))[0];o+=_l;const k=new Uint8Array(n.slice(o,o+w));m.push(k),o+=w}}else{const g=py[c],v=n.slice(o,o+d*g);if(c==="float32")m=new Float32Array(v);else if(c==="int32")m=new Int32Array(v);else if(c==="bool")m=new Uint8Array(v);else if(c==="complex64"){m=new Float32Array(v);const w=new Float32Array(m.length/2),k=new Float32Array(m.length/2);for(let T=0;T<w.length;T++)w[T]=m[T*2],k[T]=m[T*2+1];const S=xi(w,h,"float32"),x=xi(k,h,"float32");t[u]=tu(S,x),S.dispose(),x.dispose()}else throw new Error(`Unsupported dtype in weight '${u}': ${c}`);o+=d*g}c!=="complex64"&&(t[u]=xi(m,h,c))}return t}function t2(n){if(n===null)throw new Error(`Invalid input value: ${JSON.stringify(n)}`);let e=0;const t=[];n.forEach(a=>{if(e+=a.byteLength,t.push(a.byteLength===a.buffer.byteLength?a:new a.constructor(a)),!(a instanceof Float32Array||a instanceof Int32Array||a instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${a.constructor.name}`)});const r=new Uint8Array(e);let o=0;return t.forEach(a=>{r.set(new Uint8Array(a.buffer),o),o+=a.byteLength}),r.buffer}const ud=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function gy(n){return ud?Buffer.byteLength(n):new Blob([n]).size}function n2(n){if(ud)return Buffer.from(n).toString("base64");const e=new Uint8Array(n);let t="";for(let r=0,o=e.length;r<o;r++)t+=String.fromCharCode(e[r]);return btoa(t)}function r2(n){if(ud){const r=Buffer.from(n,"base64");return r.buffer.slice(r.byteOffset,r.byteOffset+r.byteLength)}const e=atob(n),t=new Uint8Array(e.length);for(let r=0;r<e.length;++r)t.set([e.charCodeAt(r)],r);return t.buffer}function j0(n){if(n.length===1)return n[0];let e=0;n.forEach(o=>{e+=o.byteLength});const t=new Uint8Array(e);let r=0;return n.forEach(o=>{t.set(new Uint8Array(o),r),r+=o.byteLength}),t.buffer}function s2(n,e){const t={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy,weightsManifest:e};return n.signature!=null&&(t.signature=n.signature),n.userDefinedMetadata!=null&&(t.userDefinedMetadata=n.userDefinedMetadata),n.modelInitializer!=null&&(t.modelInitializer=n.modelInitializer),n.trainingConfig!=null&&(t.trainingConfig=n.trainingConfig),t}function i2(n,e,t){const r={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy};if(n.trainingConfig!=null&&(r.trainingConfig=n.trainingConfig),n.weightsManifest!=null){if(!e)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!t)throw new Error("modelJSON has weightsManifest but weightData is null");r.weightSpecs=e,r.weightData=t}return n.signature!=null&&(r.signature=n.signature),n.userDefinedMetadata!=null&&(r.userDefinedMetadata=n.userDefinedMetadata),n.modelInitializer!=null&&(r.modelInitializer=n.modelInitializer),r}async function o2(n,e){let t,r;return n.weightsManifest!=null&&([t,r]=await e(n.weightsManifest)),i2(n,t,r)}function cd(n){if(n.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:n.modelTopology==null?0:gy(JSON.stringify(n.modelTopology)),weightSpecsBytes:n.weightSpecs==null?0:gy(JSON.stringify(n.weightSpecs)),weightDataBytes:n.weightData==null?0:n.weightData.byteLength}}function a2(n){const e=[];for(const t of n)e.push(...t.weights);return e}function l2(){const n=t=>{let r=t<<13,o=0;for(;(r&8388608)===0;)o-=8388608,r<<=1;return r&=-8388609,o+=947912704,r|o},e=new Uint32Array(2048);e[0]=0;for(let t=1;t<1024;t++)e[t]=n(t);for(let t=1024;t<2048;t++)e[t]=939524096+(t-1024<<13);return e}function u2(){const n=new Uint32Array(64);n[0]=0,n[31]=1199570944,n[32]=2147483648,n[63]=3347054592;for(let e=1;e<31;e++)n[e]=e<<23;for(let e=33;e<63;e++)n[e]=2147483648+(e-32<<23);return n}function c2(){const n=new Uint32Array(64);for(let e=0;e<64;e++)n[e]=1024;return n[0]=n[32]=0,n}function h2(){const n=l2(),e=u2(),t=c2();return r=>{const o=new ArrayBuffer(4*r.length),a=new Uint32Array(o);for(let u=0;u<r.length;u++){const c=r[u],h=n[t[c>>10]+(c&1023)]+e[c>>10];a[u]=h}return new Float32Array(o)}}class $t{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return $t.instance==null&&($t.instance=new $t),$t.instance}static registerSaveRouter(e){$t.getInstance().saveRouters.push(e)}static registerLoadRouter(e){$t.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return $t.getHandlers(e,"save")}static getLoadHandlers(e,t){return $t.getHandlers(e,"load",t)}static getHandlers(e,t,r){const o=[];return(t==="load"?$t.getInstance().loadRouters:$t.getInstance().saveRouters).forEach(u=>{const c=u(e,r);c!==null&&o.push(c)}),o}}const f2=n=>$t.getSaveHandlers(n),d2=(n,e)=>$t.getLoadHandlers(n,e);const zf="tensorflowjs",$f=1,Ds="models_store",Xr="model_info_store";function W0(){if(!Ke().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const n=typeof window>"u"?self:window,e=n.indexedDB||n.mozIndexedDB||n.webkitIndexedDB||n.msIndexedDB||n.shimIndexedDB;if(e==null)throw new Error("The current browser does not appear to support IndexedDB.");return e}function Mf(n){const e=n.result;e.createObjectStore(Ds,{keyPath:"modelPath"}),e.createObjectStore(Xr,{keyPath:"modelPath"})}class _s{constructor(e){if(this.indexedDB=W0(),e==null||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise((r,o)=>{const a=this.indexedDB.open(zf,$f);a.onupgradeneeded=()=>Mf(a),a.onsuccess=()=>{const u=a.result;if(t==null){const c=u.transaction(Ds,"readonly"),d=c.objectStore(Ds).get(this.modelPath);d.onsuccess=()=>{if(d.result==null)return u.close(),o(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));r(d.result.modelArtifacts)},d.onerror=m=>(u.close(),o(d.error)),c.oncomplete=()=>u.close()}else{const c=cd(t),h=u.transaction(Xr,"readwrite");let d=h.objectStore(Xr);const m=d.put({modelPath:this.modelPath,modelArtifactsInfo:c});let g;m.onsuccess=()=>{g=u.transaction(Ds,"readwrite");const w=g.objectStore(Ds).put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:c});w.onsuccess=()=>r({modelArtifactsInfo:c}),w.onerror=k=>{d=h.objectStore(Xr);const S=d.delete(this.modelPath);S.onsuccess=()=>(u.close(),o(w.error)),S.onerror=x=>(u.close(),o(w.error))}},m.onerror=v=>(u.close(),o(m.error)),h.oncomplete=()=>{g==null?u.close():g.oncomplete=()=>u.close()}}},a.onerror=u=>o(a.error)})}}_s.URL_SCHEME="indexeddb://";const V0=n=>Ke().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(_s.URL_SCHEME)?p2(n.slice(_s.URL_SCHEME.length)):null;$t.registerSaveRouter(V0);$t.registerLoadRouter(V0);function p2(n){return new _s(n)}function m2(n){return n.startsWith(_s.URL_SCHEME)?n.slice(_s.URL_SCHEME.length):n}class g2{constructor(){this.indexedDB=W0()}async listModels(){return new Promise((e,t)=>{const r=this.indexedDB.open(zf,$f);r.onupgradeneeded=()=>Mf(r),r.onsuccess=()=>{const o=r.result,a=o.transaction(Xr,"readonly"),c=a.objectStore(Xr).getAll();c.onsuccess=()=>{const h={};for(const d of c.result)h[d.modelPath]=d.modelArtifactsInfo;e(h)},c.onerror=h=>(o.close(),t(c.error)),a.oncomplete=()=>o.close()},r.onerror=o=>t(r.error)})}async removeModel(e){return e=m2(e),new Promise((t,r)=>{const o=this.indexedDB.open(zf,$f);o.onupgradeneeded=()=>Mf(o),o.onsuccess=()=>{const a=o.result,u=a.transaction(Xr,"readwrite"),c=u.objectStore(Xr),h=c.get(e);let d;h.onsuccess=()=>{if(h.result==null)return a.close(),r(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{const m=c.delete(e),g=()=>{d=a.transaction(Ds,"readwrite");const w=d.objectStore(Ds).delete(e);w.onsuccess=()=>t(h.result.modelArtifactsInfo),w.onerror=k=>r(h.error)};m.onsuccess=g,m.onerror=v=>(g(),a.close(),r(h.error))}},h.onerror=m=>(a.close(),r(h.error)),u.oncomplete=()=>{d==null?a.close():d.oncomplete=()=>a.close()}},o.onerror=a=>r(o.error)})}}const Cr="/",ki="tensorflowjs_models",G0="info",y2="model_topology",v2="weight_specs",w2="weight_data",b2="model_metadata";function q0(n){return{info:[ki,n,G0].join(Cr),topology:[ki,n,y2].join(Cr),weightSpecs:[ki,n,v2].join(Cr),weightData:[ki,n,w2].join(Cr),modelMetadata:[ki,n,b2].join(Cr)}}function H0(n){for(const e of Object.values(n))window.localStorage.removeItem(e)}function k2(n){const e=n.split(Cr);if(e.length<3)throw new Error(`Invalid key format: ${n}`);return e.slice(1,e.length-1).join(Cr)}function S2(n){return n.startsWith(Fs.URL_SCHEME)?n.slice(Fs.URL_SCHEME.length):n}class Fs{constructor(e){if(!Ke().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,e==null||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=q0(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const t=JSON.stringify(e.modelTopology),r=JSON.stringify(e.weightSpecs),o=cd(e);try{this.LS.setItem(this.keys.info,JSON.stringify(o)),this.LS.setItem(this.keys.topology,t),this.LS.setItem(this.keys.weightSpecs,r),this.LS.setItem(this.keys.weightData,n2(e.weightData));const a={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:e.signature!=null?e.signature:void 0,userDefinedMetadata:e.userDefinedMetadata!=null?e.userDefinedMetadata:void 0,modelInitializer:e.modelInitializer!=null?e.modelInitializer:void 0,trainingConfig:e.trainingConfig!=null?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(a)),{modelArtifactsInfo:o}}catch{throw H0(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${o.modelTopologyBytes}, weightSpecsBytes=${o.weightSpecsBytes}, weightDataBytes=${o.weightDataBytes}.`)}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(e==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(e.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const t={},r=JSON.parse(this.LS.getItem(this.keys.topology));if(r==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=r;const o=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(o==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=o;const a=this.LS.getItem(this.keys.modelMetadata);if(a!=null){const c=JSON.parse(a);t.format=c.format,t.generatedBy=c.generatedBy,t.convertedBy=c.convertedBy,c.signature!=null&&(t.signature=c.signature),c.userDefinedMetadata!=null&&(t.userDefinedMetadata=c.userDefinedMetadata),c.modelInitializer!=null&&(t.modelInitializer=c.modelInitializer),c.trainingConfig!=null&&(t.trainingConfig=c.trainingConfig)}const u=this.LS.getItem(this.keys.weightData);if(u==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=r2(u),t}}Fs.URL_SCHEME="localstorage://";const K0=n=>Ke().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(Fs.URL_SCHEME)?x2(n.slice(Fs.URL_SCHEME.length)):null;$t.registerSaveRouter(K0);$t.registerLoadRouter(K0);function x2(n){return new Fs(n)}class E2{constructor(){E(Ke().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),E(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const e={},t=ki+Cr,r=Cr+G0;for(let o=0;o<this.LS.length;++o){const a=this.LS.key(o);if(a.startsWith(t)&&a.endsWith(r)){const u=k2(a);e[u]=JSON.parse(this.LS.getItem(a))}}return e}async removeModel(e){e=S2(e);const t=q0(e);if(this.LS.getItem(t.info)==null)throw new Error(`Cannot find model at path '${e}'`);const r=JSON.parse(this.LS.getItem(t.info));return H0(t),r}}const yy="://";class lr{constructor(){this.managers={}}static getInstance(){return lr.instance==null&&(lr.instance=new lr),lr.instance}static registerManager(e,t){E(e!=null,()=>"scheme must not be undefined or null."),e.endsWith(yy)&&(e=e.slice(0,e.indexOf(yy))),E(e.length>0,()=>"scheme must not be an empty string.");const r=lr.getInstance();E(r.managers[e]==null,()=>`A model store manager is already registered for scheme '${e}'.`),r.managers[e]=t}static getManager(e){const t=lr.getInstance().managers[e];if(t==null)throw new Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys(lr.getInstance().managers)}}class A2{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){if(!window||!Ke().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(e,t);return}this.functionRefs.push(e),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",r=>{if(r.source===window&&r.data.name===this.messageName){r.stopPropagation();const o=this.functionRefs[r.data.index];o(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}}if(Ke().get("IS_BROWSER")){Ke().setPlatform("browser",new A2);try{lr.registerManager(Fs.URL_SCHEME,new E2)}catch{}try{lr.registerManager(_s.URL_SCHEME,new g2)}catch{}}const I2={importFetch:()=>require("node-fetch")};let mh;class T2{constructor(){this.util=require("util"),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return Ke().global.fetch!=null?Ke().global.fetch(e,t):(mh==null&&(mh=I2.importFetch()),mh(e,t))}now(){const e=process.hrtime();return e[0]*1e3+e[1]/1e6}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return e.length===0?"":new this.util.TextDecoder(t).decode(e)}}Ke().get("IS_NODE")&&!Ke().get("IS_BROWSER")&&Ke().setPlatform("node",new T2);function jo(n,e="float32",t){return e=e||"float32",yw(n),new jA(n,e,t)}function N2(n,e){const t=O(n,"x","cast");if(!hE(e))throw new Error(`Failed to cast to unknown dtype ${e}`);if(e==="string"&&t.dtype!=="string"||e!=="string"&&t.dtype==="string")throw new Error("Only strings can be casted to strings");const r={x:t},o={dtype:e};return G.runKernel(id,r,o)}const Se=X({cast_:N2});function C2(n){const t={x:O(n,"x","clone","string_or_numeric")};return G.runKernel(od,t)}const zs=X({clone_:C2});function D2(n,e=!1){console.log(n.toString(e))}P0();const z2={buffer:jo,cast:Se,clone:zs,print:D2};VA(z2);function vy(n,e,t,r){u(n),t=t??0,r=r??1,c(t,r);let o=0;const a=h=>(h.then(d=>{const m=t+ ++o/n.length*(r-t);return e(m),d}),h);function u(h){E(h!=null&&Array.isArray(h)&&h.length>0,()=>"promises must be a none empty array")}function c(h,d){E(h>=0&&h<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${h}`),E(d>=0&&d<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${d}`),E(d>=h,()=>`startFraction must be no more than endFraction, but got startFraction ${h} and endFraction ${d}`)}return Promise.all(n.map(a))}async function $2(n,e){e==null&&(e={});const t=e.fetchFunc==null?Ke().platform.fetch:e.fetchFunc,r=n.map(g=>t(g,e.requestInit,{isBinary:!0})),c=(e.onProgress==null?await Promise.all(r):await vy(r,e.onProgress,0,.5)).map(g=>g.arrayBuffer());return e.onProgress==null?await Promise.all(c):await vy(c,e.onProgress,.5,1)}const M2="application/octet-stream",R2="application/json";class hd{constructor(e,t){if(this.DEFAULT_METHOD="POST",t==null&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.onProgress=t.onProgress,this.weightUrlConverter=t.weightUrlConverter,t.fetchFunc!=null?(E(typeof t.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=t.fetchFunc):this.fetch=Ke().platform.fetch,E(e!=null&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&E(e.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,t.requestInit!=null&&t.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{}}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;const r=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],o=s2(e,r);t.body.append("model.json",new Blob([JSON.stringify(o)],{type:R2}),"model.json"),e.weightData!=null&&t.body.append("model.weights.bin",new Blob([e.weightData],{type:M2}),"model.weights.bin");const a=await this.fetch(this.path,t);if(a.ok)return{modelArtifactsInfo:cd(e),responses:[a]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${a.status}.`)}async load(){const e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let t;try{t=await e.json()}catch{let u=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?u+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":u+=" Please make sure the server is serving valid JSON for this request.",new Error(u)}const r=t.modelTopology,o=t.weightsManifest;if(r==null&&o==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return o2(t,a=>this.loadWeights(a))}async loadWeights(e){const t=Array.isArray(this.path)?this.path[1]:this.path,[r,o]=_2(t),a=this.weightPathPrefix||r,u=a2(e),c=[],h=[];for(const m of e)for(const g of m.paths)this.weightUrlConverter!=null?h.push(this.weightUrlConverter(g)):c.push(a+g+o);this.weightUrlConverter&&c.push(...await Promise.all(h));const d=await $2(c,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress});return[u,j0(d)]}}hd.URL_SCHEME_REGEX=/^https?:\/\//;function _2(n){const e=n.lastIndexOf("/"),t=n.lastIndexOf("?"),r=n.substring(0,e),o=t>e?n.substring(t):"";return[r+"/",o]}function wy(n){return n.match(hd.URL_SCHEME_REGEX)!=null}const J0=(n,e)=>{if(typeof fetch>"u"&&(e==null||e.fetchFunc==null))return null;{let t=!0;if(Array.isArray(n)?t=n.every(r=>wy(r)):t=wy(n),t)return X0(n,e)}return null};$t.registerSaveRouter(J0);$t.registerLoadRouter(J0);function X0(n,e){return new hd(n,e)}function F2(n,e){return X0(n,e)}class gh{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}}class L2{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=t=>Promise.resolve(e.save(t)))}}function O2(n,e,t,r){const o=arguments;return new L2(P2(...o))}function P2(n,e,t,r){return arguments.length===1?n.modelTopology!=null||n.weightSpecs!=null?new gh(n):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new gh({modelTopology:n})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new gh({modelTopology:n,weightSpecs:e,weightData:t,trainingConfig:r}))}function B2(n,e,t=!1,r=!1){let o=O(n,"a","matMul"),a=O(e,"b","matMul");[o,a]=Pt(o,a);const u={a:o,b:a},c={transposeA:t,transposeB:r};return G.runKernel(Ew,u,c)}const et=X({matMul_:B2});function U2(n,e,t=1,r=0,o="int32"){if(e<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${e}`);const u={indices:O(n,"indices","oneHot","int32")},c={dtype:o,depth:e,onValue:t,offValue:r};return G.runKernel(s0,u,c)}const xl=X({oneHot_:U2});function by(){return G.memory()}function V(n,e){return G.tidy(n,e)}function Me(n){ts(n).forEach(t=>t.dispose())}function yr(n){return G.keep(n)}function fd(){return G.backend}function j2(n){const t={input:O(n,"input","imag")};return G.runKernel(eA,t)}const W2=X({imag_:j2});function V2(n){const t={x:O(n,"x","neg")};return G.runKernel(n0,t)}const Wt=X({neg_:V2});function G2(n){const t={input:O(n,"input","real")};return G.runKernel(kA,t)}const q2=X({real_:G2});function H2(n,e,t){const r=O(n,"x","transpose");if(e==null&&(e=r.shape.map((u,c)=>c).reverse()),E(r.rank===e.length,()=>`Error in transpose: rank of input ${r.rank} must match length of perm ${e}.`),e.forEach(u=>{E(u>=0&&u<r.rank,()=>`All entries in 'perm' must be between 0 and ${r.rank-1} but got ${e}`)}),r.rank<=1)return r.clone();const o={x:r},a={perm:e};return r.dtype==="complex64"?V(()=>{let u=q2(r),c=W2(r);return u=G.runKernel(kl,{x:u},a),c=G.runKernel(kl,{x:c},a),t&&(c=Wt(c)),tu(u,c)}):G.runKernel(kl,o,a)}const We=X({transpose_:H2});function Rt(n,e){const t=[];for(let r=0;r<e.length;r++){const o=n[n.length-r-1],a=e.length-r-1,u=e[a];(o==null||o===1&&u>1)&&t.unshift(a)}return t}function gt(n,e){const t=[],r=Math.max(n.length,e.length);for(let o=0;o<r;o++){let a=n[n.length-o-1];a==null&&(a=1);let u=e[e.length-o-1];if(u==null&&(u=1),a===1)t.unshift(u);else if(u===1)t.unshift(a);else if(a!==u){const c=`Operands could not be broadcast together with shapes ${n} and ${e}.`;throw Error(c)}else t.unshift(a)}return t}function yh(n,e,t){if(Ql(n),e!=null&&e.length!==3)throw new Error("tensor3d() requires shape to have three numbers");const r=Fi(n,t);if(r.length!==3&&r.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return Li(n,e,r,t)}function K2(n,e,t){let r;const o=n.shape.length;typeof e=="number"?r=[e,...new Array(o-1).fill(0)]:e.length<o?r=e.concat(new Array(o-e.length).fill(0)):r=e.slice(),r.forEach(u=>{E(u!==-1,()=>"slice() does not support negative begin indexing.")});let a;return t==null?a=new Array(o).fill(-1):typeof t=="number"?a=[t,...new Array(o-1).fill(-1)]:t.length<o?a=t.concat(new Array(o-t.length).fill(-1)):a=t,a=a.map((u,c)=>u>=0?u:(E(u===-1,()=>`Negative size values should be exactly -1 but got ${u} for the slice() size at index ${c}.`),n.shape[c]-r[c])),[r,a]}class Oi{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}}class Dn{constructor(){this.classNameMap={}}static getMap(){return Dn.instance==null&&(Dn.instance=new Dn),Dn.instance}static register(e){Dn.getMap().classNameMap[e.className]=[e,e.fromConfig]}}function re(n){E(n.className!=null,()=>"Class being registered does not have the static className property defined."),E(typeof n.className=="string",()=>"className is required to be a string, but got type "+typeof n.className),E(n.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),Dn.register(n)}function J2(n,e){let t=O(n,"a","add"),r=O(e,"b","add");[t,r]=Pt(t,r);const o={a:t,b:r};return G.runKernel(sd,o)}const le=X({add_:J2});function X2(n,e){let t=O(n,"a","floorDiv"),r=O(e,"b","floorDiv");[t,r]=Pt(t,r);const o={a:t,b:r};return G.runKernel(Uw,o)}const Y2=X({floorDiv_:X2});function Z2(n,e){let t=O(n,"a","div"),r=O(e,"b","div");if([t,r]=Pt(t,r),t.dtype==="int32"&&r.dtype==="int32")return Y2(t,r);const o={a:t,b:r},a={};return G.runKernel(Fw,o,a)}const $e=X({div_:Z2});function Q2(n,e){let t=O(n,"a","mul"),r=O(e,"b","mul");[t,r]=Pt(t,r);const o={a:t,b:r};return G.runKernel(t0,o)}const P=X({mul_:Q2});function eI(n){const e=O(n,"x","abs");if(e.dtype==="complex64"){const t={x:e};return G.runKernel(Tw,t)}else{const t={x:e};return G.runKernel(bw,t)}}const Zt=X({abs_:eI});function tI(n,e=null,t=!1){const o={x:O(n,"x","all","bool")},a={axis:e,keepDims:t};return G.runKernel(xE,o,a)}const nI=X({all_:tI});function rI(n,e=null,t=!1){const o={x:O(n,"x","any","bool")},a={axis:e,keepDims:t};return G.runKernel(EE,o,a)}const ky=X({any_:rI});function sI(n,e=0){const r={x:O(n,"x","argMax")},o={axis:e};return G.runKernel(kw,r,o)}const Ni=X({argMax_:sI});function iI(n,e,t,r,o,a,u=!1,c="channelsLast"){let[h,d,m,g]=[-1,-1,-1,-1];if(c==="channelsLast")[h,d,m,g]=n;else if(c==="channelsFirst")[h,g,d,m]=n;else throw new Error(`Unknown dataFormat ${c}`);const[v,w,,k]=e,[S,x]=Rf(t),[T,z]=Rf(r),R=_f(v,T),$=_f(w,z),{padInfo:B,outHeight:H,outWidth:Y}=lI(o,d,m,S,x,R,$,a,c),Z=u?k*g:k;let ne;return c==="channelsFirst"?ne=[h,Z,H,Y]:c==="channelsLast"&&(ne=[h,H,Y,Z]),{batchSize:h,dataFormat:c,inHeight:d,inWidth:m,inChannels:g,outHeight:H,outWidth:Y,outChannels:Z,padInfo:B,strideHeight:S,strideWidth:x,filterHeight:v,filterWidth:w,effectiveFilterHeight:R,effectiveFilterWidth:$,dilationHeight:T,dilationWidth:z,inShape:n,outShape:ne,filterShape:e}}function oI(n,e,t,r,o){r==null&&(r=aI(n,e,t));const a=n[0],u=n[1],c=Fl((a-e+2*r)/t+1,o),h=Fl((u-e+2*r)/t+1,o);return[c,h]}function aI(n,e,t,r=1){const o=_f(e,r);return Math.floor((n[0]*(t-1)-t+o)/2)}function Rf(n){return typeof n=="number"?[n,n,n]:n.length===2?[n[0],n[1],1]:n}function _f(n,e){return e<=1?n:n+(n-1)*(e-1)}function lI(n,e,t,r,o,a,u,c,h){let d,m,g;if(typeof n=="number"){d={top:n,bottom:n,left:n,right:n,type:n===0?"VALID":"NUMBER"};const w=oI([e,t],a,r,n,c);m=w[0],g=w[1]}else if(n==="same"){m=Math.ceil(e/r),g=Math.ceil(t/o);const v=Math.max(0,(m-1)*r+a-e),w=Math.max(0,(g-1)*o+u-t),k=Math.floor(v/2),S=v-k,x=Math.floor(w/2),T=w-x;d={top:k,bottom:S,left:x,right:T,type:"SAME"}}else if(n==="valid")d={top:0,bottom:0,left:0,right:0,type:"VALID"},m=Math.ceil((e-a+1)/r),g=Math.ceil((t-u+1)/o);else if(typeof n=="object"){const v=h==="channelsLast"?n[1][0]:n[2][0],w=h==="channelsLast"?n[1][1]:n[2][1],k=h==="channelsLast"?n[2][0]:n[3][0],S=h==="channelsLast"?n[2][1]:n[3][1];d={top:v,bottom:w,left:k,right:S,type:v===0&&w===0&&k===0&&S===0?"VALID":"EXPLICIT"},m=Fl((e-a+v+w)/r+1,c),g=Fl((t-u+k+S)/o+1,c)}else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:d,outHeight:m,outWidth:g}}function Fl(n,e){if(!e)return Math.trunc(n);switch(e){case"round":return Math.round(n);case"ceil":return Math.ceil(n);case"floor":return Math.floor(n);default:throw new Error(`Unknown roundingMode ${e}`)}}function Ci(n){const[e,t,r]=Rf(n);return e===1&&t===1&&r===1}function Ps(n,e){return Ci(n)||Ci(e)}function pn(n,e,t){if(t!=null){if(typeof e=="string")throw Error(`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${e}.`);if(typeof e=="number")E(Ml(e),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${e}.`);else if(typeof e=="object")e.forEach(r=>{r.forEach(o=>{E(Ml(o),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${o}.`)})});else throw Error(`Error in ${n}: Unknown padding parameter: ${e}`)}}function uI(n,e){const r={x:O(n,"x","reshape","string_or_numeric")},o={shape:e};return G.runKernel(c0,r,o)}const J=X({reshape_:uI});function cI(n,e,t,r,o){const a=O(n,"x","avgPool","float32"),u=1;E(Ps(t,u),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${u}'`);let c=a,h=!1;a.rank===3&&(h=!0,c=J(a,[1,a.shape[0],a.shape[1],a.shape[2]])),E(c.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${c.rank}.`),pn("avgPool",r,o);const d={x:c},m={filterSize:e,strides:t,pad:r,dimRoundingMode:o};let g=G.runKernel(Sw,d,m);return g=Se(g,a.dtype),h?J(g,[g.shape[1],g.shape[2],g.shape[3]]):g}const hI=X({avgPool_:cI});function fI(n,e,t,r,o,a="NDHWC"){const u=O(n,"x","avgPool3d","float32");let c=u,h=!1;u.rank===4&&(h=!0,c=J(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]])),E(c.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${c.rank}.`),E(a==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${a}`),pn("avgPool3d",r,o);const d={x:c},m={filterSize:e,strides:t,pad:r,dimRoundingMode:o,dataFormat:a};let g=G.runKernel(xw,d,m);return g=Se(g,c.dtype),h?J(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}const dI=X({avgPool3d_:fI});function pI(n,e=0){E(n.length>=1,()=>"Pass at least one tensor to concat");const t=U0(n,"tensors","concat","string_or_numeric");if(t[0].dtype==="complex64"&&t.forEach(a=>{if(a.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${a.dtype}. `)}),t.length===1)return zs(t[0]);const r=t,o={axis:e};return G.runKernel(Nw,r,o)}const Kn=X({concat_:pI});function mI(n){const t={x:O(n,"x","sigmoid","float32")};return G.runKernel(S0,t)}const nu=X({sigmoid_:mI});function gI(n,e,t){const r=O(n,"x","slice","string_or_numeric");if(r.rank===0)throw new Error("Slicing scalar is not possible");const o={x:r},a={begin:e,size:t};return G.runKernel(w0,o,a)}const it=X({slice_:gI});function yI(n){const t={x:O(n,"x","tanh","float32")};return G.runKernel(D0,t)}const Y0=X({tanh_:yI});function vI(n,e,t){const r=O(n,"x","batchToSpaceND"),o=e.reduce((c,h)=>c*h);E(r.rank>=1+e.length,()=>`input rank is ${r.rank} but should be > than blockShape.length ${e.length}`),E(t.length===e.length,()=>`crops.length is ${t.length} but should be equal to blockShape.length  ${e.length}`),E(r.shape[0]%o===0,()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${e.join(" * ")} === ${o}`);const a={x:r},u={blockShape:e,crops:t};return G.runKernel(Aw,a,u)}const wI=X({batchToSpaceND_:vI});function bI(n){let e;return n.rank===0||n.rank===1?e=J(n,[1,1,1,n.size]):n.rank===2?e=J(n,[1,1,n.shape[0],n.shape[1]]):n.rank===3?e=J(n,[1,n.shape[0],n.shape[1],n.shape[2]]):e=n,e}function kI(n,e,t,r,o,a){a==null&&(a=.001);const u=O(n,"x","batchNorm"),c=O(e,"mean","batchNorm"),h=O(t,"variance","batchNorm");let d;o!=null&&(d=O(o,"scale","batchNorm"));let m;r!=null&&(m=O(r,"offset","batchNorm")),E(c.rank===h.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),E(m==null||c.rank===m.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),E(d==null||c.rank===d.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const v={x:bI(u),scale:d,offset:m,mean:c,variance:h},w={varianceEpsilon:a},k=G.runKernel(jw,v,w);return J(k,u.shape)}const dd=X({batchNorm_:kI});function SI(n,e,t,r,o,a){const u=O(n,"x","batchNorm"),c=O(e,"mean","batchNorm"),h=O(t,"variance","batchNorm");let d;o!=null&&(d=O(o,"scale","batchNorm"));let m;return r!=null&&(m=O(r,"offset","batchNorm")),E(u.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${u.rank}.`),E(c.rank===2||c.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${c.rank}.`),E(h.rank===2||h.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${h.rank}.`),d!=null&&E(d.rank===2||d.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${d.rank}.`),m!=null&&E(m.rank===2||m.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${m.rank}.`),dd(u,c,h,m,d,a)}const xI=X({batchNorm2d_:SI});function EI(n,e,t,r,o,a){const u=O(n,"x","batchNorm"),c=O(e,"mean","batchNorm"),h=O(t,"variance","batchNorm");let d;o!=null&&(d=O(o,"scale","batchNorm"));let m;return r!=null&&(m=O(r,"offset","batchNorm")),E(u.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${u.rank}.`),E(c.rank===3||c.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${c.rank}.`),E(h.rank===3||h.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${h.rank}.`),d!=null&&E(d.rank===3||d.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${d.rank}.`),m!=null&&E(m.rank===3||m.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${m.rank}.`),dd(u,c,h,m,d,a)}const AI=X({batchNorm3d_:EI});function II(n,e,t,r,o,a){const u=O(n,"x","batchNorm"),c=O(e,"mean","batchNorm"),h=O(t,"variance","batchNorm");let d;o!=null&&(d=O(o,"scale","batchNorm"));let m;return r!=null&&(m=O(r,"offset","batchNorm")),E(u.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${u.rank}.`),E(c.rank===4||c.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${c.rank}.`),E(h.rank===4||h.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${h.rank}.`),d!=null&&E(d.rank===4||d.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${d.rank}.`),m!=null&&E(m.rank===4||m.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${m.rank}.`),dd(u,c,h,m,d,a)}const TI=X({batchNorm4d_:II});function NI(n,e,t){const r=O(n,"x","bincount"),o=O(e,"weights","bincount");E(r.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`),E(t>=0,()=>`size must be non-negative, but got ${t}.`),E(o.size===r.size||o.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${o.shape}.`);const a={x:r,weights:o},u={size:t};return G.runKernel(ME,a,u)}const CI=X({bincount_:NI});function DI(n,e){let t=O(n,"broadcastTo","x");const r=t.shape;if(e.some(d=>!(d>0)||d%1!==0))throw new Error(`broadcastTo(): Invalid broadcast shape [${e}].`);if(e.length<t.rank)throw new Error(`broadcastTo(): shape.length=${e.length} < input.rank=${t.rank}.`);if(e.length>t.rank){const d=t.shape.slice();for(;d.length<e.length;)d.unshift(1);t=J(t,d)}const o=t.shape,a=Array.from(e);for(let d=e.length-1;d>=0;d--)if(o[d]===e[d])a[d]=1;else if(t.shape[d]!==1)throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${e}].`);if(a.map((d,m)=>d>1?m:-1).filter(d=>d>=0).length===0)return zs(t);const c={x:t},h={reps:a};return G.runKernel(ad,c,h)}const vh=X({broadcastTo_:DI});function ru(n,e,t){const r={shape:n,value:e,dtype:t};return G.runKernel(YE,{},r)}function zI(n,e,t){const r=O(n,"x","clipByValue");if(E(e<=t,()=>`Error in clip: min (${e}) must be less than or equal to max (${t}).`),e===t)return ru(r.shape,e,r.dtype);const o={x:r},a={clipValueMin:e,clipValueMax:t};return G.runKernel(Iw,o,a)}const Mn=X({clipByValue_:zI});function $I(n){return Kn(n,0)}const MI=X({concat1d_:$I});function RI(n,e){return Kn(n,e)}const _I=X({concat2d_:RI});function FI(n,e){return Kn(n,e)}const LI=X({concat3d_:FI});function OI(n,e){return Kn(n,e)}const PI=X({concat4d_:OI});function BI(n,e,t,r,o="NHWC",a=[1,1],u){const c=O(n,"x","conv2d","float32"),h=O(e,"filter","conv2d","float32");let d=c,m=!1;c.rank===3&&(m=!0,d=J(c,[1,c.shape[0],c.shape[1],c.shape[2]])),E(d.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${d.rank}.`),E(h.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${h.rank}.`),pn("conv2d",r,u);const g=o==="NHWC"?d.shape[3]:d.shape[1];E(g===h.shape[2],()=>`Error in conv2d: depth of input (${g}) must match input depth for filter ${h.shape[2]}.`),E(Ps(t,a),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${a}'`);const v={x:d,filter:h},w={strides:t,pad:r,dataFormat:o,dilations:a,dimRoundingMode:u},k=G.runKernel(Cw,v,w);return m?J(k,[k.shape[1],k.shape[2],k.shape[3]]):k}const Di=X({conv2d_:BI});function UI(n,e,t,r,o="NWC",a=1,u){const c=O(n,"x","conv1d"),h=O(e,"filter","conv1d");let d=c,m=!1;c.rank===2&&(m=!0,d=J(c,[1,c.shape[0],c.shape[1]])),E(d.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${d.rank}.`),E(h.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${h.rank}.`),pn("conv1d",r,u),E(d.shape[2]===h.shape[1],()=>`Error in conv1d: depth of input (${d.shape[2]}) must match input depth for filter ${h.shape[1]}.`),E(Ps(t,a),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${t} and dilation '${a}'`),E(o==="NWC",()=>`Error in conv1d: got dataFormat of ${o} but only NWC is currently supported.`);const g=J(h,[1,h.shape[0],h.shape[1],h.shape[2]]),v=J(d,[d.shape[0],1,d.shape[1],d.shape[2]]),x=Di(v,g,[1,t],r,"NHWC",[1,a],u);return m?J(x,[x.shape[2],x.shape[3]]):J(x,[x.shape[0],x.shape[2],x.shape[3]])}const jI=X({conv1d_:UI});function WI(n,e,t,r,o,a="NHWC",u){E(n.length===e.rank,()=>`Length of inShape (${n.length}) and rank of dy (${e.rank}) must match`);let c=n,h=e,d=!1;e.rank===3&&(d=!0,h=J(e,[1,e.shape[0],e.shape[1],e.shape[2]]),c=[1,n[0],n[1],n[2]]),E(c.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${c.length}.`),E(h.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${h.rank}`),E(t.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${t.rank}`);const m=a==="NHWC"?c[3]:c[1],g=a==="NHWC"?h.shape[3]:h.shape[1];E(m===t.shape[2],()=>`Error in conv2dDerInput: depth of input (${m}) must match input depth for filter ${t.shape[2]}.`),E(g===t.shape[3],()=>`Error in conv2dDerInput: depth of output (${g}) must match output depth for filter ${t.shape[3]}.`),pn("conv2dDerInput",o,u);const v={dy:h,filter:t},w={strides:r,pad:o,dataFormat:a,dimRoundingMode:u,inputShape:c},k=G.runKernel(Dw,v,w);return d?J(k,[k.shape[1],k.shape[2],k.shape[3]]):k}const pd=X({conv2DBackpropInput_:WI});function VI(n,e,t,r,o,a){const u=O(n,"x","conv2dTranspose"),c=O(e,"filter","conv2dTranspose");return pd(t,u,c,r,o,"NHWC",a)}const GI=X({conv2dTranspose_:VI});function qI(n,e,t,r,o="NDHWC",a=[1,1,1]){const u=O(n,"x","conv3d"),c=O(e,"filter","conv3d");let h=u,d=!1;u.rank===4&&(d=!0,h=J(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]])),E(h.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${h.rank}.`),E(c.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${c.rank}.`),E(h.shape[4]===c.shape[3],()=>`Error in conv3d: depth of input (${h.shape[4]}) must match input depth for filter ${c.shape[3]}.`),E(Ps(t,a),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${t} and dilations '${a}'`),E(o==="NDHWC",()=>`Error in conv3d: got dataFormat of ${o} but only NDHWC is currently supported.`);const m={x:h,filter:c},g={strides:t,pad:r,dataFormat:o,dilations:a},v=G.runKernel(zw,m,g);return d?J(v,[v.shape[1],v.shape[2],v.shape[3],v.shape[4]]):v}const HI=X({conv3d_:qI});function KI(n,e,t,r,o){E(n.length===e.rank,()=>`Length of inShape (${n.length}) and rank of dy (${e.rank}) must match`);let a=n,u=e,c=!1;e.rank===4&&(c=!0,u=J(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]),a=[1,n[0],n[1],n[2],n[3]]);const h=a[4],d=u.shape[4];E(a.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${a.length}.`),E(u.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${u.rank}`),E(t.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${t.rank}`),E(h===t.shape[3],()=>`Error in conv3dDerInput: depth of input (${h}) must match input depth for filter ${t.shape[3]}.`),E(d===t.shape[4],()=>`Error in conv3dDerInput: depth of output (${d}) must match output depth for filter ${t.shape[4]}.`);const m={dy:u,filter:t},g={pad:o,strides:r,inputShape:a},v=G.runKernel(PE,m,g);return c?J(v,[v.shape[1],v.shape[2],v.shape[3],v.shape[4]]):v}const Z0=X({conv3DBackpropInput_:KI});function JI(n,e,t,r,o){const a=O(n,"x","conv3dTranspose"),u=O(e,"filter","conv3dTranspose");return Z0(t,a,u,r,o)}const XI=X({conv3dTranspose_:JI});function YI(n){const t={x:O(n,"x","cos","float32")};return G.runKernel($w,t)}const Q0=X({cos_:YI});function ZI(n){const t={x:O(n,"x","cosh","float32")};return G.runKernel(Mw,t)}const QI=X({cosh_:ZI});function eT(n,e=0,t=!1,r=!1){const a={x:O(n,"x","cumprod")},u={axis:e,exclusive:t,reverse:r};return G.runKernel(BE,a,u)}const Sy=X({cumprod_:eT});function tT(n,e=0,t=!1,r=!1){const a={x:O(n,"x","cumsum")},u={axis:e,exclusive:t,reverse:r};return G.runKernel(Rw,a,u)}const nT=X({cumsum_:tT});function rT(n,e,t,r,o="NHWC",a=[1,1],u){const c=O(n,"x","depthwiseConv2d","float32"),h=O(e,"filter","depthwiseConv2d","float32");let d=c,m=!1;c.rank===3&&(m=!0,d=J(c,[1,c.shape[0],c.shape[1],c.shape[2]])),E(d.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${d.rank}.`),E(h.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${h.rank}.`);const g=o==="NHWC"?d.shape[3]:d.shape[1];E(g===h.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${g}) must match the inChannels dimension in filter ${h.shape[2]}.`),pn("depthwiseConv2d",r,u);const v={x:d,filter:h},w={strides:t,pad:r,dataFormat:o,dilations:a,dimRoundingMode:u},k=G.runKernel(_w,v,w);return m?J(k,[k.shape[1],k.shape[2],k.shape[3]]):k}const eb=X({depthwiseConv2d_:rT});function sT(n,e){let t=O(n,"a","equal","string_or_numeric"),r=O(e,"b","equal","string_or_numeric");[t,r]=Pt(t,r),gt(t.shape,r.shape);const o={a:t,b:r};return G.runKernel(JE,o)}const ns=X({equal_:sT});function iT(n,e,t){const r=O(e,"a","where"),o=O(t,"b","where"),a=O(n,"condition","where","bool"),u=gt(gt(a.shape,r.shape),o.shape),c=vh(a,u),h=vh(r,u),d=vh(o,u),m={condition:c,t:h,e:d};return G.runKernel(y0,m)}const Rn=X({where_:iT});function oT(n){const t={x:O(n,"x","zerosLike")};return G.runKernel(M0,t)}const He=X({zerosLike_:oT});function aT(n){const t={x:O(n,"x","elu","float32")};return G.runKernel(Lw,t)}const md=X({elu_:aT});function lT(n,e){for(let t=0;t<n.length;++t)if(n[n.length-t-1]!==e-1-t)return!1;return!0}function uT(n,e,t){const r=n.length+e.length,o=[];let a=0,u=0;for(let c=0;c<r;c++)t.indexOf(c)===-1?o.push(n[a++]):o.push(e[u++]);return o}function cT(n,e){const t=[],r=n.length;for(let a=0;a<r;a++)e.indexOf(a)===-1&&t.push(n[a]);const o=e.map(a=>n[a]);return[t,o]}function Ll(n,e){const t=e.map(r=>1);return uT(n,t,e)}function tb(n,e){if(lT(n,e))return null;const t=[];for(let r=0;r<e;++r)n.indexOf(r)===-1&&t.push(r);return n.forEach(r=>t.push(r)),t}function gd(n){return n.map((e,t)=>[t,e]).sort((e,t)=>e[1]-t[1]).map(e=>e[0])}function hT(n,e=null,t=!1){const o={x:O(n,"x","max")},a={reductionIndices:e,keepDims:t};return G.runKernel(Kw,o,a)}const Dr=X({max_:hT});function fT(n,e=null,t=!1){const o={x:O(n,"x","min")},a={axis:e,keepDims:t};return G.runKernel(Qw,o,a)}const xy=X({min_:fT});function dT(n,e){let t=O(n,"base","pow"),r=O(e,"exp","pow");[t,r]=Pt(t,r);const o={a:t,b:r};return G.runKernel(a0,o)}const Fo=X({pow_:dT});function Je(n,e){if((Xn(n)&&e!=="string"||Array.isArray(n))&&e!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(e==="string"&&Xn(n)&&!(n instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return Li(n,[],[],e)}function pT(n){const t={x:O(n,"x","sqrt","float32")};return G.runKernel(E0,t)}const Kt=X({sqrt_:pT});function mT(n){const e=O(n,"x","square"),t={};return G.runKernel("Square",{x:e},t)}const at=X({square_:mT});function gT(n,e=null,t=!1){let r=O(n,"x","sum");r.dtype==="bool"&&(r=Se(r,"int32"));const o={x:r},a={axis:e,keepDims:t};return G.runKernel(A0,o,a)}const Ce=X({sum_:gT});function yT(n,e="euclidean",t=null,r=!1){n=O(n,"x","norm");const o=nb(n,e,t);let a=o.shape;if(r){const u=vr(t,n.shape);a=Ll(o.shape,u)}return J(o,a)}function nb(n,e,t=null){if(n.rank===0)return Zt(n);if(n.rank!==1&&t===null)return nb(J(n,[-1]),e,t);if(n.rank===1||typeof t=="number"||Array.isArray(t)&&t.length===1){if(e===1)return Ce(Zt(n),t);if(e===1/0)return Dr(Zt(n),t);if(e===-1/0)return xy(Zt(n),t);if(e==="euclidean"||e===2)return Kt(Ce(Fo(Zt(n),Je(2,"int32")),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}if(Array.isArray(t)&&t.length===2){if(e===1)return Dr(Ce(Zt(n),t[0]),t[1]-1);if(e===1/0)return Dr(Ce(Zt(n),t[1]),t[0]);if(e===-1/0)return xy(Ce(Zt(n),t[1]),t[0]);if(e==="fro"||e==="euclidean")return Kt(Ce(at(n),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}throw new Error(`Error in norm: invalid axis: ${t}`)}const rb=X({norm_:yT});function vT(n){const t={x:O(n,"x","exp")};return G.runKernel(Ow,t)}const Ls=X({exp_:vT});function wT(n,e=0){const t=O(n,"x","expandDims","string_or_numeric");E(e<=t.rank,()=>"Axis must be <= rank of the tensor");const r={input:t},o={dim:e};return G.runKernel(Pw,r,o)}const qn=X({expandDims_:wT});function bT(n,e){const t=O(n,"x","tile","string_or_numeric");E(t.rank===e.length,()=>`Error in transpose: rank of input ${t.rank} must match length of reps ${e}.`);const r={x:t},o={reps:e};return G.runKernel(ad,r,o)}const fr=X({tile_:bT});function kT(n,e,t,r="float32"){e==null&&(e=n);const o=jo([n,e],r),a=n<=e?n:e;for(let c=0;c<a;++c)o.set(1,c,c);const u=J(o.toTensor(),[n,e]);if(t==null)return u;if(t.length===1)return fr(qn(u,0),[t[0],1,1]);if(t.length===2)return fr(qn(qn(u,0),0),[t[0],t[1],1,1]);if(t.length===3)return fr(qn(qn(qn(u,0),0),0),[t[0],t[1],t[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${t.length}D.`)}const sb=X({eye_:kT});function ST(n){const t={x:O(n,"x","floor","float32")};return G.runKernel(Bw,t)}const yd=X({floor_:ST});function xT(n,e,t=0,r=0){const o=O(n,"x","gather"),a=O(e,"indices","gather","int32"),u={x:o,indices:a},c={axis:t,batchDims:r};return G.runKernel(Ww,u,c)}const Si=X({gather_:xT});function ET(n,e){let t=O(n,"a","greater","string_or_numeric"),r=O(e,"b","greater","string_or_numeric");[t,r]=Pt(t,r),gt(t.shape,r.shape);const o={a:t,b:r};return G.runKernel(QE,o)}const er=X({greater_:ET});function AT(n,e){let t=O(n,"a","greaterEqual","string_or_numeric"),r=O(e,"b","greaterEqual","string_or_numeric");[t,r]=Pt(t,r),gt(t.shape,r.shape);const o={a:t,b:r};return G.runKernel(Vw,o)}const Wo=X({greaterEqual_:AT});function IT(n,e=.2){const r={x:O(n,"x","leakyRelu")},o={alpha:e};return G.runKernel(Gw,r,o)}const ib=X({leakyRelu_:IT});function TT(n,e){let t=O(n,"a","less","string_or_numeric"),r=O(e,"b","less","string_or_numeric");[t,r]=Pt(t,r),gt(t.shape,r.shape);const o={a:t,b:r};return G.runKernel(sA,o)}const NT=X({less_:TT});function CT(n,e){let t=O(n,"a","lessEqual","string_or_numeric"),r=O(e,"b","lessEqual","string_or_numeric");[t,r]=Pt(t,r),gt(t.shape,r.shape);const o={a:t,b:r};return G.runKernel(iA,o)}const Vo=X({lessEqual_:CT});function DT(n){const t={x:O(n,"x","log","float32")};return G.runKernel(qw,t)}const rs=X({log_:DT});function zT(n){const t={x:O(n,"x","log1p")};return G.runKernel(Hw,t)}const $T=X({log1p_:zT});function MT(n,e){E(Af(n),()=>"The f passed in variableGrads(f) must be a function"),E(e==null||Array.isArray(e)&&e.every(d=>d instanceof Rl),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const t=e!=null;if(!t){e=[];for(const d in G.registeredVariables)e.push(G.registeredVariables[d])}const r=t?e.filter(d=>!d.trainable):null,o=e.length;e=e.filter(d=>d.trainable),E(e.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${o} variables is trainable.`);const a=!0,{value:u,grads:c}=G.gradients(n,e,null,a);E(c.some(d=>d!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),E(u.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${u.rank} tensor`);const h={};return e.forEach((d,m)=>{c[m]!=null&&(h[d.name]=c[m])}),r?.forEach(d=>h[d.name]=null),{value:u,grads:h}}function Lo(n){return G.customGrad(n)}function RT(n){const t={x:O(n,"x","softplus")};return G.runKernel(x0,t)}const vd=X({softplus_:RT});function _T(n,e){let t=O(n,"a","sub"),r=O(e,"b","sub");[t,r]=Pt(t,r);const o={a:t,b:r};return G.runKernel(C0,o)}const Re=X({sub_:_T});function FT(n,e=-1){const t=O(n,"logits","logSoftmax");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and axis was ${e}`);return Lo((o,a)=>{const c=Dr(o,e,!0),h=Re(o,c),d=Re(Se(h,"float32"),rs(Ce(Ls(h),e,!0)));return a([d]),{value:d,gradFunc:(g,v)=>{const[w]=v,k=!0,S=Ls(w);return Re(g,P(Ce(g,e,k),S))}}})(t)}const LT=X({logSoftmax_:FT});function OT(n,e){const t=O(n,"a","logicalAnd","bool"),r=O(e,"b","logicalAnd","bool");gt(t.shape,r.shape);const o={a:t,b:r};return G.runKernel(oA,o)}const Pi=X({logicalAnd_:OT});function PT(n){const t={x:O(n,"x","logicalNot","bool")};return G.runKernel(aA,t)}const BT=X({logicalNot_:PT});function UT(n,e,t,r,o){const a=O(n,"x","maxPool"),u=1;let c=a,h=!1;a.rank===3&&(h=!0,c=J(a,[1,a.shape[0],a.shape[1],a.shape[2]])),E(c.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${c.rank}.`),E(Ps(t,u),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${u}'`),pn("maxPool",r,o);const d={x:c},m={filterSize:e,strides:t,pad:r,dimRoundingMode:o},g=G.runKernel(Xw,d,m);return h?J(g,[g.shape[1],g.shape[2],g.shape[3]]):g}const jT=X({maxPool_:UT});function WT(n,e=[1,1,1],t,r,o,a="NDHWC"){const u=O(n,"x","maxPool3d");let c=u,h=!1;u.rank===4&&(h=!0,c=J(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]])),E(c.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${c.rank}.`),E(a==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${a}`),pn("maxPool3d",r,o);const d={x:c},m={filterSize:e,strides:t,pad:r,dimRoundingMode:o,dataFormat:a},g=G.runKernel(Yw,d,m);return h?J(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}const VT=X({maxPool3d_:WT});function GT(n,e){let t=O(n,"a","maximum"),r=O(e,"b","maximum");[t,r]=Pt(t,r),t.dtype==="bool"&&(t=Se(t,"int32"),r=Se(r,"int32")),gt(t.shape,r.shape);const o={a:t,b:r};return G.runKernel(Jw,o)}const Bs=X({maximum_:GT});function qT(n,e=null,t=!1){const o={x:O(n,"x","mean")},a={axis:e,keepDims:t};return G.runKernel(Zw,o,a)}const St=X({mean_:qT});function Ot(n,e="float32"){if(e==="complex64"){const r=Ot(n,"float32"),o=Ot(n,"float32");return tu(r,o)}const t=td(tn(n),e);return G.makeTensor(t,n,e)}function Us(n,e="float32"){if(e==="complex64"){const r=Us(n,"float32"),o=Ot(n,"float32");return tu(r,o)}const t=gw(tn(n),e);return G.makeTensor(t,n,e)}function HT(n,e){let t=O(n,"a","minimum"),r=O(e,"b","minimum");[t,r]=Pt(t,r),t.dtype==="bool"&&(t=Se(t,"int32"),r=Se(r,"int32")),gt(t.shape,r.shape);const o={a:t,b:r};return G.runKernel(e0,o)}const ob=X({minimum_:HT});function KT(n,e=null,t=!1){n=O(n,"x","moments");const r=vr(e,n.shape),o=St(n,r,t);let a=o.shape;t||(a=Ll(o.shape,r));const u=at(Re(Se(n,"float32"),J(o,a))),c=St(u,r,t);return{mean:o,variance:c}}const Go=X({moments_:KT});function JT(n,e){let t=O(n,"a","notEqual","string_or_numeric"),r=O(e,"b","notEqual","string_or_numeric");[t,r]=Pt(t,r),gt(t.shape,r.shape);const o={a:t,b:r};return G.runKernel(mA,o)}const Ff=X({notEqual_:JT});function XT(n){const t={x:O(n,"x","onesLike")};return G.runKernel(r0,t)}const Yn=X({onesLike_:XT});function YT(n,e,t=0){const r=O(n,"x","pad");if(r.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const o={paddings:e,constantValue:t},a={x:r};return G.runKernel(o0,a,o)}const ab=X({pad_:YT});function ZT(n,e,t){const r=O(n,"x","spaceToBatchND");E(r.rank>=1+e.length,()=>`input rank ${r.rank} should be > than [blockShape] ${e.length}`),E(t.length===e.length,()=>`paddings.shape[0] ${t.length} must be equal to [blockShape] ${e.length}`),E(r.shape.reduce((u,c,h)=>h>0&&h<=e.length?u&&(c+t[h-1][0]+t[h-1][1])%e[h-1]===0:u,!0),()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${t.toString()} must be divisible by blockShapes ${e.toString()}`);const o={x:r},a={blockShape:e,paddings:t};return G.runKernel(I0,o,a)}const QT=X({spaceToBatchND_:ZT});function eN(n,e){const t=O(n,"x","prelu"),r=O(e,"alpha","prelu"),o={x:t,alpha:r};return G.runKernel(l0,o)}const lb=X({prelu_:eN});var El={exports:{}},tN=El.exports,Ey;function nN(){return Ey||(Ey=1,(function(n){(function(e,t,r){function o(h){var d=this,m=c();d.next=function(){var g=2091639*d.s0+d.c*23283064365386963e-26;return d.s0=d.s1,d.s1=d.s2,d.s2=g-(d.c=g|0)},d.c=1,d.s0=m(" "),d.s1=m(" "),d.s2=m(" "),d.s0-=m(h),d.s0<0&&(d.s0+=1),d.s1-=m(h),d.s1<0&&(d.s1+=1),d.s2-=m(h),d.s2<0&&(d.s2+=1),m=null}function a(h,d){return d.c=h.c,d.s0=h.s0,d.s1=h.s1,d.s2=h.s2,d}function u(h,d){var m=new o(h),g=d&&d.state,v=m.next;return v.int32=function(){return m.next()*4294967296|0},v.double=function(){return v()+(v()*2097152|0)*11102230246251565e-32},v.quick=v,g&&(typeof g=="object"&&a(g,m),v.state=function(){return a(m,{})}),v}function c(){var h=4022871197,d=function(m){m=String(m);for(var g=0;g<m.length;g++){h+=m.charCodeAt(g);var v=.02519603282416938*h;h=v>>>0,v-=h,v*=h,h=v>>>0,v-=h,h+=v*4294967296}return(h>>>0)*23283064365386963e-26};return d}t&&t.exports?t.exports=u:this.alea=u})(tN,n)})(El)),El.exports}var Al={exports:{}},rN=Al.exports,Ay;function sN(){return Ay||(Ay=1,(function(n){(function(e,t,r){function o(c){var h=this,d="";h.x=0,h.y=0,h.z=0,h.w=0,h.next=function(){var g=h.x^h.x<<11;return h.x=h.y,h.y=h.z,h.z=h.w,h.w^=h.w>>>19^g^g>>>8},c===(c|0)?h.x=c:d+=c;for(var m=0;m<d.length+64;m++)h.x^=d.charCodeAt(m)|0,h.next()}function a(c,h){return h.x=c.x,h.y=c.y,h.z=c.z,h.w=c.w,h}function u(c,h){var d=new o(c),m=h&&h.state,g=function(){return(d.next()>>>0)/4294967296};return g.double=function(){do var v=d.next()>>>11,w=(d.next()>>>0)/4294967296,k=(v+w)/(1<<21);while(k===0);return k},g.int32=d.next,g.quick=g,m&&(typeof m=="object"&&a(m,d),g.state=function(){return a(d,{})}),g}t&&t.exports?t.exports=u:this.xor128=u})(rN,n)})(Al)),Al.exports}var Il={exports:{}},iN=Il.exports,Iy;function oN(){return Iy||(Iy=1,(function(n){(function(e,t,r){function o(c){var h=this,d="";h.next=function(){var g=h.x^h.x>>>2;return h.x=h.y,h.y=h.z,h.z=h.w,h.w=h.v,(h.d=h.d+362437|0)+(h.v=h.v^h.v<<4^(g^g<<1))|0},h.x=0,h.y=0,h.z=0,h.w=0,h.v=0,c===(c|0)?h.x=c:d+=c;for(var m=0;m<d.length+64;m++)h.x^=d.charCodeAt(m)|0,m==d.length&&(h.d=h.x<<10^h.x>>>4),h.next()}function a(c,h){return h.x=c.x,h.y=c.y,h.z=c.z,h.w=c.w,h.v=c.v,h.d=c.d,h}function u(c,h){var d=new o(c),m=h&&h.state,g=function(){return(d.next()>>>0)/4294967296};return g.double=function(){do var v=d.next()>>>11,w=(d.next()>>>0)/4294967296,k=(v+w)/(1<<21);while(k===0);return k},g.int32=d.next,g.quick=g,m&&(typeof m=="object"&&a(m,d),g.state=function(){return a(d,{})}),g}t&&t.exports?t.exports=u:this.xorwow=u})(iN,n)})(Il)),Il.exports}var Tl={exports:{}},aN=Tl.exports,Ty;function lN(){return Ty||(Ty=1,(function(n){(function(e,t,r){function o(c){var h=this;h.next=function(){var m=h.x,g=h.i,v,w;return v=m[g],v^=v>>>7,w=v^v<<24,v=m[g+1&7],w^=v^v>>>10,v=m[g+3&7],w^=v^v>>>3,v=m[g+4&7],w^=v^v<<7,v=m[g+7&7],v=v^v<<13,w^=v^v<<9,m[g]=w,h.i=g+1&7,w};function d(m,g){var v,w=[];if(g===(g|0))w[0]=g;else for(g=""+g,v=0;v<g.length;++v)w[v&7]=w[v&7]<<15^g.charCodeAt(v)+w[v+1&7]<<13;for(;w.length<8;)w.push(0);for(v=0;v<8&&w[v]===0;++v);for(v==8?w[7]=-1:w[v],m.x=w,m.i=0,v=256;v>0;--v)m.next()}d(h,c)}function a(c,h){return h.x=c.x.slice(),h.i=c.i,h}function u(c,h){c==null&&(c=+new Date);var d=new o(c),m=h&&h.state,g=function(){return(d.next()>>>0)/4294967296};return g.double=function(){do var v=d.next()>>>11,w=(d.next()>>>0)/4294967296,k=(v+w)/(1<<21);while(k===0);return k},g.int32=d.next,g.quick=g,m&&(m.x&&a(m,d),g.state=function(){return a(d,{})}),g}t&&t.exports?t.exports=u:this.xorshift7=u})(aN,n)})(Tl)),Tl.exports}var Nl={exports:{}},uN=Nl.exports,Ny;function cN(){return Ny||(Ny=1,(function(n){(function(e,t,r){function o(c){var h=this;h.next=function(){var m=h.w,g=h.X,v=h.i,w,k;return h.w=m=m+1640531527|0,k=g[v+34&127],w=g[v=v+1&127],k^=k<<13,w^=w<<17,k^=k>>>15,w^=w>>>12,k=g[v]=k^w,h.i=v,k+(m^m>>>16)|0};function d(m,g){var v,w,k,S,x,T=[],z=128;for(g===(g|0)?(w=g,g=null):(g=g+"\0",w=0,z=Math.max(z,g.length)),k=0,S=-32;S<z;++S)g&&(w^=g.charCodeAt((S+32)%g.length)),S===0&&(x=w),w^=w<<10,w^=w>>>15,w^=w<<4,w^=w>>>13,S>=0&&(x=x+1640531527|0,v=T[S&127]^=w+x,k=v==0?k+1:0);for(k>=128&&(T[(g&&g.length||0)&127]=-1),k=127,S=512;S>0;--S)w=T[k+34&127],v=T[k=k+1&127],w^=w<<13,v^=v<<17,w^=w>>>15,v^=v>>>12,T[k]=w^v;m.w=x,m.X=T,m.i=k}d(h,c)}function a(c,h){return h.i=c.i,h.w=c.w,h.X=c.X.slice(),h}function u(c,h){c==null&&(c=+new Date);var d=new o(c),m=h&&h.state,g=function(){return(d.next()>>>0)/4294967296};return g.double=function(){do var v=d.next()>>>11,w=(d.next()>>>0)/4294967296,k=(v+w)/(1<<21);while(k===0);return k},g.int32=d.next,g.quick=g,m&&(m.X&&a(m,d),g.state=function(){return a(d,{})}),g}t&&t.exports?t.exports=u:this.xor4096=u})(uN,n)})(Nl)),Nl.exports}var Cl={exports:{}},hN=Cl.exports,Cy;function fN(){return Cy||(Cy=1,(function(n){(function(e,t,r){function o(c){var h=this,d="";h.next=function(){var g=h.b,v=h.c,w=h.d,k=h.a;return g=g<<25^g>>>7^v,v=v-w|0,w=w<<24^w>>>8^k,k=k-g|0,h.b=g=g<<20^g>>>12^v,h.c=v=v-w|0,h.d=w<<16^v>>>16^k,h.a=k-g|0},h.a=0,h.b=0,h.c=-1640531527,h.d=1367130551,c===Math.floor(c)?(h.a=c/4294967296|0,h.b=c|0):d+=c;for(var m=0;m<d.length+20;m++)h.b^=d.charCodeAt(m)|0,h.next()}function a(c,h){return h.a=c.a,h.b=c.b,h.c=c.c,h.d=c.d,h}function u(c,h){var d=new o(c),m=h&&h.state,g=function(){return(d.next()>>>0)/4294967296};return g.double=function(){do var v=d.next()>>>11,w=(d.next()>>>0)/4294967296,k=(v+w)/(1<<21);while(k===0);return k},g.int32=d.next,g.quick=g,m&&(typeof m=="object"&&a(m,d),g.state=function(){return a(d,{})}),g}t&&t.exports?t.exports=u:this.tychei=u})(hN,n)})(Cl)),Cl.exports}var Dl={exports:{}};const dN={},pN=Object.freeze(Object.defineProperty({__proto__:null,default:dN},Symbol.toStringTag,{value:"Module"})),mN=Gx(pN);var gN=Dl.exports,Dy;function yN(){return Dy||(Dy=1,(function(n){(function(e,t,r){var o=256,a=6,u=52,c="random",h=r.pow(o,a),d=r.pow(2,u),m=d*2,g=o-1,v;function w($,B,H){var Y=[];B=B==!0?{entropy:!0}:B||{};var Z=T(x(B.entropy?[$,R(t)]:$??z(),3),Y),ne=new k(Y),oe=function(){for(var de=ne.g(a),me=h,ve=0;de<d;)de=(de+ve)*o,me*=o,ve=ne.g(1);for(;de>=m;)de/=2,me/=2,ve>>>=1;return(de+ve)/me};return oe.int32=function(){return ne.g(4)|0},oe.quick=function(){return ne.g(4)/4294967296},oe.double=oe,T(R(ne.S),t),(B.pass||H||function(de,me,ve,be){return be&&(be.S&&S(be,ne),de.state=function(){return S(ne,{})}),ve?(r[c]=de,me):de})(oe,Z,"global"in B?B.global:this==r,B.state)}function k($){var B,H=$.length,Y=this,Z=0,ne=Y.i=Y.j=0,oe=Y.S=[];for(H||($=[H++]);Z<o;)oe[Z]=Z++;for(Z=0;Z<o;Z++)oe[Z]=oe[ne=g&ne+$[Z%H]+(B=oe[Z])],oe[ne]=B;(Y.g=function(de){for(var me,ve=0,be=Y.i,Ne=Y.j,Ie=Y.S;de--;)me=Ie[be=g&be+1],ve=ve*o+Ie[g&(Ie[be]=Ie[Ne=g&Ne+me])+(Ie[Ne]=me)];return Y.i=be,Y.j=Ne,ve})(o)}function S($,B){return B.i=$.i,B.j=$.j,B.S=$.S.slice(),B}function x($,B){var H=[],Y=typeof $,Z;if(B&&Y=="object")for(Z in $)try{H.push(x($[Z],B-1))}catch{}return H.length?H:Y=="string"?$:$+"\0"}function T($,B){for(var H=$+"",Y,Z=0;Z<H.length;)B[g&Z]=g&(Y^=B[g&Z]*19)+H.charCodeAt(Z++);return R(B)}function z(){try{var $;return v&&($=v.randomBytes)?$=$(o):($=new Uint8Array(o),(e.crypto||e.msCrypto).getRandomValues($)),R($)}catch{var B=e.navigator,H=B&&B.plugins;return[+new Date,e,H,e.screen,R(t)]}}function R($){return String.fromCharCode.apply(0,$)}if(T(r.random(),t),n.exports){n.exports=w;try{v=mN}catch{}}else r["seed"+c]=w})(typeof self<"u"?self:gN,[],Math)})(Dl)),Dl.exports}var wh,zy;function vN(){if(zy)return wh;zy=1;var n=nN(),e=sN(),t=oN(),r=lN(),o=cN(),a=fN(),u=yN();return u.alea=n,u.xor128=e,u.xorwow=t,u.xorshift7=r,u.xor4096=o,u.tychei=a,wh=u,wh}var su=vN();class ub{constructor(e,t,r,o,a){this.mean=e,this.stdDev=t,this.dtype=r,this.nextVal=NaN,this.truncated=o,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);const u=a||Math.random();this.random=su.alea(u.toString())}nextValue(){if(!isNaN(this.nextVal)){const o=this.nextVal;return this.nextVal=NaN,o}let e,t,r=!1;for(;!r;){let o,a,u;do o=2*this.random()-1,a=2*this.random()-1,u=o*o+a*a;while(u>=1||u===0);const c=Math.sqrt(-2*Math.log(u)/u);e=this.mean+this.stdDev*o*c,t=this.mean+this.stdDev*a*c,(!this.truncated||this.isValidTruncated(e))&&(r=!0)}return(!this.truncated||this.isValidTruncated(t))&&(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return this.dtype==null||this.dtype==="float32"?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class wN{constructor(e=0,t=1,r,o){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=e,this.range=t-e,this.dtype=r,o==null&&(o=Math.random()),typeof o=="number"&&(o=o.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=su.alea(o)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}function bN(n,e=0,t=1,r,o){if(r!=null&&r==="bool")throw new Error(`Unsupported data type ${r}`);const a=new ub(e,t,r,!1,o),u=jo(n,r);for(let c=0;c<u.values.length;c++)u.values[c]=a.nextValue();return u.toTensor()}const kN=X({randomNormal_:bN});function SN(n,e=0,t=1,r="float32",o){const a=jo(n,r),u=new wN(e,t,null,o);for(let c=0;c<a.values.length;c++)a.values[c]=u.nextValue();return a.toTensor()}const iu=X({randomUniform_:SN});function Ol(n,e,t=1,r="float32"){if(t===0)throw new Error("Cannot have a step of zero");const o={start:n,stop:e,step:t,dtype:r};return G.runKernel(bA,{},o)}function xN(n){const t={x:O(n,"x","relu")};return G.runKernel(u0,t)}const Bi=X({relu_:xN});function EN(n){const t={x:O(n,"x","relu6")};return G.runKernel(d0,t)}const AN=X({relu6_:EN});function IN(n,e){const r={x:O(n,"x","reverse")},o={dims:e};return G.runKernel(p0,r,o)}const Pl=X({reverse_:IN});function TN(n){const t={x:O(n,"x","round")};return G.runKernel(m0,t)}const NN=X({round_:TN});function CN(n){const t={x:O(n,"x","rsqrt","float32")};return G.runKernel(g0,t)}const DN=X({rsqrt_:CN});function zN(n){const t={x:O(n,"x","selu")};return G.runKernel(v0,t)}const $N=X({selu_:zN});function MN(n,e,t,r,o,a=[1,1],u="NHWC"){const c=O(n,"x","separableConv2d"),h=O(e,"depthwiseFilter","separableConv2d"),d=O(t,"pointwiseFilter","separableConv2d");let m=c,g=!1;if(c.rank===3&&(g=!0,m=J(c,[1,c.shape[0],c.shape[1],c.shape[2]])),u==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");E(m.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${m.rank}.`),E(h.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${h.rank}.`),E(d.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${h.rank}.`),E(d.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${d.shape[0]}.`),E(d.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${d.shape[1]}.`);const v=h.shape[2],w=h.shape[3];E(d.shape[2]===v*w,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${v*w}, but got ${d.shape[2]}.`);const k=eb(m,h,r,o,u,a),x=Di(k,d,1,"valid",u);return g?J(x,[x.shape[1],x.shape[2],x.shape[3]]):x}const RN=X({separableConv2d_:MN});function _N(n){const t={x:O(n,"x","sin","float32")};return G.runKernel(b0,t)}const FN=X({sin_:_N});function LN(n){const t={x:O(n,"x","sinh")};return G.runKernel(k0,t)}const ON=X({sinh_:LN});function PN(n,e,t){const r=O(n,"x","slice1d");return E(r.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`),it(r,[e],[t])}const wd=X({slice1d_:PN});function BN(n,e,t){const r=O(n,"x","slice2d");return E(r.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`),it(r,e,t)}const cb=X({slice2d_:BN});function UN(n,e,t){const r=O(n,"x","slice3d");return E(r.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`),it(r,e,t)}const bd=X({slice3d_:UN});function jN(n,e,t){const r=O(n,"x","slice4d");return E(r.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`),it(r,e,t)}const Bl=X({slice4d_:jN});function WN(n,e=-1){const t=O(n,"logits","softmax","float32");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and dim was ${e}`);const r={logits:t},o={dim:e};return G.runKernel(N0,r,o)}const hb=X({softmax_:WN});function VN(n,e,t=0){const o={x:O(n,"x","split")},a={numOrSizeSplits:e,axis:t};return G.runKernel(T0,o,a)}const pr=X({split_:VN});function GN(n,e){const t=O(n,"x","squeeze","string_or_numeric");return J(t,lE(t.shape,e).newShape)}const zi=X({squeeze_:GN});function qN(n,e=0){const t=U0(n,"tensors","stack","string_or_numeric");E(t.length>=1,()=>"Pass at least one tensor to tf.stack"),t.length>0&&E(e<=t[0].rank,()=>"Axis must be <= rank of the tensor");const r=t,o={axis:e};return G.runKernel(i0,r,o)}const ss=X({stack_:qN});function HN(n,e=0){const r={x:O(n,"x","step")},o={alpha:e};return G.runKernel(R0,r,o)}const ou=X({step_:HN});function jt(n,e){Ql(n);const t=Fi(n,e);if(t.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return Li(n,null,t,e)}function zl(n,e,t){if(Ql(n),e!=null&&e.length!==2)throw new Error("tensor2d() requires shape to have two numbers");const r=Fi(n,t);if(r.length!==2&&r.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return Li(n,e,r,t)}function KN(n,e,t){if(Ql(n),e!=null&&e.length!==4)throw new Error("tensor4d() requires shape to have four numbers");const r=Fi(n,t);if(r.length!==4&&r.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return Li(n,e,r,t)}function JN(n,e=0,t=1,r,o){if(r!=null&&r==="bool")throw new Error("Unsupported data type $ { dtype }");const a=new ub(e,t,r,!0,o),u=jo(n,r);for(let c=0;c<u.values.length;c++)u.values[c]=a.nextValue();return u.toTensor()}const fb=X({truncatedNormal_:JN});function XN(n,e,t){const r=O(n,"x","unsortedSegmentSum"),o=O(e,"segmentIds","unsortedSegmentSum","int32");E(Ml(t),()=>"numSegments must be of dtype int");const a={x:r,segmentIds:o},u={numSegments:t};return G.runKernel($0,a,u)}const YN=X({unsortedSegmentSum_:XN});function ZN(n,e=0){const t=O(n,"x","unstack","string_or_numeric");E(e>=-t.shape.length&&e<t.shape.length,()=>`Axis = ${e} is not in [-${t.shape.length}, ${t.shape.length})`);const r={value:t},o={axis:e};return G.runKernel(z0,r,o)}const $i=X({unstack_:ZN});function QN(n,e=!0,t,r){return G.makeVariable(n,e,t,r)}function eC(n,e){if(e==null)return n.shape.slice();if(nn(n.shape,e))return e;if(n.shape.length===e.length){const t=[];for(let r=0;r<n.shape.length;r++)e[r]==null&&n.shape[r]!=null?t.push(n.shape[r]):t.push(e[r]);return t}return e}function tC(n,e,t,r){const o=O(n,"x","dropout");if(E(o.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${o.dtype} tensor instead.`),E(e>=0&&e<1,()=>`rate must be a float in the range [0, 1), but got ${e}.`),e===0)return n instanceof ot?o.clone():o;const a=eC(o,t),u=1-e,c=$e(yd(le(iu(a,0,1,"float32",r),u)),u);return P(o,c)}const nC=X({dropout_:tC});function rC(n,e,t,r,o,a="NHWC",u){let c=n;n.rank===3&&(c=J(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let h=e;h.rank===3&&(h=J(e,[1,e.shape[0],e.shape[1],e.shape[2]])),E(c.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${c.shape}.`),E(h.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${h.shape}.`),E(t.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${t}.`);const d=a==="NHWC"?c.shape[3]:c.shape[1],m=a==="NHWC"?h.shape[3]:h.shape[1];E(d===t[2],()=>`Error in conv2dDerFilter: depth of input ${d}) must match input depth in filter (${t[2]}.`),E(m===t[3],()=>`Error in conv2dDerFilter: depth of dy (${m}) must match output depth for filter (${t[3]}).`),pn("conv2dDerFilter",o,u);const g={x:c,dy:h},v={strides:r,pad:o,dataFormat:a,dimRoundingMode:u,filterShape:t};return G.runKernel(LE,g,v)}const kd=X({conv2DBackpropFilter_:rC});function db(n,e,t){if(t==null||t==="linear")return n;if(t==="relu")return P(n,ou(e));throw new Error(`Cannot compute gradient for fused activation ${t}.`)}function pb(n,e){let t=e;const r=Rt(n.shape,e.shape);return r.length>0&&(t=Ce(t,r)),J(t,n.shape)}function mb(n,e,t,r){if(e==="linear")return n;if(e==="relu")return Bi(n);if(e==="elu")return md(n);if(e==="relu6")return AN(n);if(e==="prelu")return lb(n,t);if(e==="leakyrelu")return ib(n,r);if(e==="sigmoid")return nu(n);throw new Error(`Unknown fused activation ${e}.`)}const gb=(n,e)=>!(n>0)||e==="linear";function sC({x:n,filter:e,strides:t,pad:r,dataFormat:o="NHWC",dilations:a=[1,1],dimRoundingMode:u,bias:c,activation:h="linear",preluActivationWeights:d,leakyreluAlpha:m}){if(h=h||"linear",gb(G.state.gradientDepth,h)===!1){E(o==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${o} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let H=Di(n,e,t,r,o,a,u);return c!=null&&(H=le(H,c)),mb(H,h,d,m)}const g=O(n,"x","conv2d","float32"),v=O(e,"filter","conv2d","float32");let w=g,k=!1;g.rank===3&&(k=!0,w=J(g,[1,g.shape[0],g.shape[1],g.shape[2]])),E(w.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${w.rank}.`),E(v.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${v.rank}.`),pn("fused conv2d",r,u);const S=o==="NHWC"?w.shape[3]:w.shape[1];E(v.shape[2]===S,()=>`Error in conv2d: depth of input (${S}) must match input depth for filter ${v.shape[2]}.`),E(Ps(t,a),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${a}'`);const x=iI(w.shape,v.shape,t,a,r,u);let T;c!=null&&(T=O(c,"bias","fused conv2d"),[T]=Pt(T,g),o==="NHWC"?gt(x.outShape,T.shape):(E(T.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${T.shape.length}.`),E(T.shape.length===0||T.shape[0]===x.outChannels||T.shape[0]===1,()=>`Error in fused conv2d: bias shape (${T.shape}) is not compatible with the number of output channels (${x.outChannels})`)));let z;if(d!=null){const H=d.shape;if(E(H.length<=1||H.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${H.length}.`),H.length===1)E(H[0]===1||H[0]===x.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${H}) is not compatible with the number of output channels (${x.outChannels}).`);else if(H.length===3)try{gt(H,x.outShape)}catch{const Z=`Error in fused conv2d: PReLU activation weights (${H}) is not compatible with the output shape of the conv2d (${x.outShape}).`;throw Error(Z)}z=O(d,"prelu weights","fused conv2d")}const R=(H,Y)=>{E(o==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${o} but only NHWC is currently supported.`);const[Z,ne,oe,de]=Y,me=db(H,oe,h);E(Ci(a),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${a}'`);const ve=pd(ne.shape,me,Z,t,r),be=kd(ne,me,Z.shape,t,r),Ne=[ve,be];if(de!=null){const Ie=pb(de,me);Ne.push(Ie)}return Ne},$={x:w,filter:v,bias:T,preluActivationWeights:z},B={strides:t,pad:r,dataFormat:o,dilations:a,dimRoundingMode:u,activation:h,leakyreluAlpha:m};return c==null?Lo((Y,Z,ne)=>{let oe=G.runKernel(iy,$,B);return ne([Z,Y,oe]),k&&(oe=J(oe,[oe.shape[1],oe.shape[2],oe.shape[3]])),{value:oe,gradFunc:R}})(w,v):Lo((Y,Z,ne,oe)=>{let de=G.runKernel(iy,$,B);return oe([Z,Y,de,ne]),k&&(de=J(de,[de.shape[1],de.shape[2],de.shape[3]])),{value:de,gradFunc:R}})(w,v,T)}const iC=X({fusedConv2d_:sC});function oC(n,e,t,r,o,a=[1,1],u){let c=n;n.rank===3&&(c=J(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let h=e;h.rank===3&&(h=J(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const d={x:c,dy:h},m={strides:r,pad:o,dimRoundingMode:u,dilations:a,filterShape:t};return G.runKernel(jE,d,m)}const aC=X({depthwiseConv2dNativeBackpropFilter_:oC});function lC(n,e,t,r,o,a=[1,1],u){let c=e,h=!1;e.rank===3&&(h=!0,c=J(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const d={dy:c,filter:t},m={strides:r,pad:o,dimRoundingMode:u,dilations:a,inputShape:n},g=G.runKernel(WE,d,m);return h?J(g,[g.shape[1],g.shape[2],g.shape[3]]):g}const uC=X({depthwiseConv2dNativeBackpropInput_:lC});function cC({a:n,b:e,transposeA:t=!1,transposeB:r=!1,bias:o,activation:a="linear",preluActivationWeights:u,leakyreluAlpha:c=.2}){if(gb(G.state.gradientDepth,a)===!1){let de=et(n,e,t,r);return o!=null&&(de=le(de,o)),mb(de,a,u,c)}let h=O(n,"a","fused matMul"),d=O(e,"b","fused matMul");[h,d]=Pt(h,d);const m=t?h.shape[h.rank-2]:h.shape[h.rank-1],g=r?d.shape[d.rank-1]:d.shape[d.rank-2],v=t?h.shape[h.rank-1]:h.shape[h.rank-2],w=r?d.shape[d.rank-2]:d.shape[d.rank-1],k=h.shape.slice(0,-2),S=d.shape.slice(0,-2),x=tn(k),T=tn(S);E(m===g,()=>`Error in fused matMul: inner shapes (${m}) and (${g}) of Tensors with shapes ${h.shape} and ${d.shape} and transposeA=${t} and transposeB=${r} must match.`);const R=gt(h.shape.slice(0,-2),d.shape.slice(0,-2)).concat([v,w]),$=t?J(h,[x,m,v]):J(h,[x,v,m]),B=r?J(d,[T,w,g]):J(d,[T,g,w]);let H;o!=null&&(H=O(o,"bias","fused matMul"),[H]=Pt(H,h),gt(R,H.shape));let Y;u!=null&&(Y=O(u,"prelu weights","fused matMul"));const Z=(de,me)=>{const[ve,be,Ne,Ie]=me,Ee=db(J(de,Ne.shape),Ne,a);let D,I;if(!t&&!r?(D=et(Ee,be,!1,!0),I=et(ve,Ee,!0,!1)):!t&&r?(D=et(Ee,be,!1,!1),I=et(Ee,ve,!0,!1)):t&&!r?(D=et(be,Ee,!1,!0),I=et(ve,Ee,!1,!1)):(D=et(be,Ee,!0,!0),I=et(Ee,ve,!0,!0)),o!=null){const A=pb(Ie,Ee);return[D,I,A]}else return[D,I]},ne={a:$,b:B,bias:H,preluActivationWeights:Y},oe={transposeA:t,transposeB:r,activation:a,leakyreluAlpha:c};return o==null?Lo((me,ve,be)=>{const Ne=G.runKernel(sy,ne,oe);return be([me,ve,Ne]),{value:J(Ne,R),gradFunc:Z}})($,B):Lo((me,ve,be,Ne)=>{const Ie=G.runKernel(sy,ne,oe);return Ne([me,ve,Ie,be]),{value:J(Ie,R),gradFunc:Z}})($,B,H)}const $y=X({fusedMatMul_:cC});function hC(n,e,t,r,o="bilinear",a=0){const u=O(n,"image","cropAndResize"),c=O(e,"boxes","cropAndResize","float32"),h=O(t,"boxInd","cropAndResize","int32"),d=c.shape[0];E(u.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${u.rank}.`),E(c.rank===2&&c.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${d},4] but had shape ${c.shape}.`),E(h.rank===1&&h.shape[0]===d,()=>`Error in cropAndResize: boxInd must be have size [${d}] but had shape ${c.shape}.`),E(r.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`),E(r[0]>=1&&r[1]>=1,()=>`cropSize must be atleast [1,1], but was ${r}`),E(o==="bilinear"||o==="nearest",()=>`method must be bilinear or nearest, but was ${o}`);const m={image:u,boxes:c,boxInd:h},g={method:o,extrapolationValue:a,cropSize:r};return G.runKernel(UE,m,g)}const fC=X({cropAndResize_:hC});function dC(n){const e=O(n,"image","flipLeftRight","float32");E(e.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${e.rank}.`);const t={image:e};return G.runKernel(ZE,t,{})}const pC=X({flipLeftRight_:dC});function mC(n){const e=O(n,"image","grayscaleToRGB"),t=e.rank-1,r=e.shape[t];E(e.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${e.rank}.`),E(r===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`);const o=new Array(e.rank);return o.fill(1,0,t),o[t]=3,fr(e,o)}const gC=X({grayscaleToRGB_:mC});function yC(n,e,t=0,r=.5){const o=O(n,"image","rotateWithOffset","float32");E(o.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${o.rank}.`);const a={image:o},u={radians:e,fillValue:t,center:r};return G.runKernel(DA,a,u)}const vC=X({rotateWithOffset_:yC});function Ui(n,e,t,r,o,a){r==null&&(r=.5),o==null&&(o=Number.NEGATIVE_INFINITY),a==null&&(a=0);const u=n.shape[0];return t=Math.min(t,u),E(0<=r&&r<=1,()=>`iouThreshold must be in [0, 1], but was '${r}'`),E(n.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${n.rank}'`),E(n.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${n.shape[1]}`),E(e.rank===1,()=>"scores must be a 1D tensor"),E(e.shape[0]===u,()=>`scores has incompatible shape with boxes. Expected ${u}, but was ${e.shape[0]}`),E(0<=a&&a<=1,()=>`softNmsSigma must be in [0, 1], but was '${a}'`),{maxOutputSize:t,iouThreshold:r,scoreThreshold:o,softNmsSigma:a}}function wC(n,e,t,r=.5,o=Number.NEGATIVE_INFINITY){const a=O(n,"boxes","nonMaxSuppression","float32"),u=O(e,"scores","nonMaxSuppression","float32"),c=Ui(a,u,t,r,o);t=c.maxOutputSize,r=c.iouThreshold,o=c.scoreThreshold;const h={maxOutputSize:t,iouThreshold:r,scoreThreshold:o};return G.runKernel(gA,{boxes:a,scores:u},h)}const bC=X({nonMaxSuppression_:wC});function kC(n,e,t){const r=SC(n,e,t),o=r<0?-(r+1):r;n.splice(o,0,e)}function SC(n,e,t){return EC(n,e,t||xC)}function xC(n,e){return n>e?1:n<e?-1:0}function EC(n,e,t){let r=0,o=n.length,a=0,u=!1;for(;r<o;){a=r+(o-r>>>1);const c=t(e,n[a]);c>0?r=a+1:(o=a,u=!c)}return u?r:-r-1}function AC(n,e,t,r,o){return Sd(n,e,t,r,o,0)}function IC(n,e,t,r,o,a){return Sd(n,e,t,r,o,0,!1,a,!0)}function TC(n,e,t,r,o,a){return Sd(n,e,t,r,o,a,!0)}function Sd(n,e,t,r,o,a,u=!1,c=!1,h=!1){const d=[];for(let x=0;x<e.length;x++)e[x]>o&&d.push({score:e[x],boxIndex:x,suppressBeginIndex:0});d.sort(My);const m=a>0?-.5/a:0,g=[],v=[];for(;g.length<t&&d.length>0;){const x=d.pop(),{score:T,boxIndex:z,suppressBeginIndex:R}=x;if(T<o)break;let $=!1;for(let B=g.length-1;B>=R;--B){const H=NC(n,z,g[B]);if(H>=r){$=!0;break}if(x.score=x.score*CC(r,m,H),x.score<=o)break}x.suppressBeginIndex=g.length,$||(x.score===T?(g.push(z),v.push(x.score)):x.score>o&&kC(d,x,My))}const w=g.length,k=t-w;c&&k>0&&(g.push(...new Array(k).fill(0)),v.push(...new Array(k).fill(0)));const S={selectedIndices:g};return u&&(S.selectedScores=v),h&&(S.validOutputs=w),S}function NC(n,e,t){const r=n.subarray(e*4,e*4+4),o=n.subarray(t*4,t*4+4),a=Math.min(r[0],r[2]),u=Math.min(r[1],r[3]),c=Math.max(r[0],r[2]),h=Math.max(r[1],r[3]),d=Math.min(o[0],o[2]),m=Math.min(o[1],o[3]),g=Math.max(o[0],o[2]),v=Math.max(o[1],o[3]),w=(c-a)*(h-u),k=(g-d)*(v-m);if(w<=0||k<=0)return 0;const S=Math.max(a,d),x=Math.max(u,m),T=Math.min(c,g),z=Math.min(h,v),R=Math.max(T-S,0)*Math.max(z-x,0);return R/(w+k-R)}function CC(n,e,t){const r=Math.exp(e*t*t);return t<=n?r:0}function My(n,e){return n.score-e.score||n.score===e.score&&e.boxIndex-n.boxIndex}async function DC(n,e,t,r=.5,o=Number.NEGATIVE_INFINITY){const a=O(n,"boxes","nonMaxSuppressionAsync"),u=O(e,"scores","nonMaxSuppressionAsync"),c=Ui(a,u,t,r,o);t=c.maxOutputSize,r=c.iouThreshold,o=c.scoreThreshold;const h=await Promise.all([a.data(),u.data()]),d=h[0],m=h[1],{selectedIndices:g}=AC(d,m,t,r,o);return a!==n&&a.dispose(),u!==e&&u.dispose(),jt(g,"int32")}const zC=DC;function $C(n,e,t,r=.5,o=Number.NEGATIVE_INFINITY,a=0){const u=O(n,"boxes","nonMaxSuppression"),c=O(e,"scores","nonMaxSuppression"),h=Ui(u,c,t,r,o,a);t=h.maxOutputSize,r=h.iouThreshold,o=h.scoreThreshold,a=h.softNmsSigma;const d={boxes:u,scores:c},m={maxOutputSize:t,iouThreshold:r,scoreThreshold:o,softNmsSigma:a},g=G.runKernel(vA,d,m);return{selectedIndices:g[0],selectedScores:g[1]}}const MC=X({nonMaxSuppressionWithScore_:$C});async function RC(n,e,t,r=.5,o=Number.NEGATIVE_INFINITY,a=0){const u=O(n,"boxes","nonMaxSuppressionAsync"),c=O(e,"scores","nonMaxSuppressionAsync"),h=Ui(u,c,t,r,o,a);t=h.maxOutputSize,r=h.iouThreshold,o=h.scoreThreshold,a=h.softNmsSigma;const d=await Promise.all([u.data(),c.data()]),m=d[0],g=d[1],{selectedIndices:v,selectedScores:w}=TC(m,g,t,r,o,a);return u!==n&&u.dispose(),c!==e&&c.dispose(),{selectedIndices:jt(v,"int32"),selectedScores:jt(w)}}const _C=RC;function FC(n,e,t,r=.5,o=Number.NEGATIVE_INFINITY,a=!1){const u=O(n,"boxes","nonMaxSuppression"),c=O(e,"scores","nonMaxSuppression"),h=Ui(u,c,t,r,o,null),d=h.maxOutputSize,m=h.iouThreshold,g=h.scoreThreshold,v={boxes:u,scores:c},w={maxOutputSize:d,iouThreshold:m,scoreThreshold:g,padToMaxOutputSize:a},k=G.runKernel(yA,v,w);return{selectedIndices:k[0],validOutputs:k[1]}}const LC=X({nonMaxSuppressionPadded_:FC});async function OC(n,e,t,r=.5,o=Number.NEGATIVE_INFINITY,a=!1){const u=O(n,"boxes","nonMaxSuppressionAsync"),c=O(e,"scores","nonMaxSuppressionAsync"),h=Ui(u,c,t,r,o,null),d=h.maxOutputSize,m=h.iouThreshold,g=h.scoreThreshold,[v,w]=await Promise.all([u.data(),c.data()]),{selectedIndices:k,validOutputs:S}=IC(v,w,d,m,g,a);return u!==n&&u.dispose(),c!==e&&c.dispose(),{selectedIndices:jt(k,"int32"),validOutputs:Je(S,"int32")}}const PC=OC;function BC(n,e,t=!1,r=!1){const o=O(n,"images","resizeBilinear");E(o.rank===3||o.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${o.rank}.`),E(e.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${e}.`),E(r===!1||t===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let a=o,u=!1;o.rank===3&&(u=!0,a=J(o,[1,o.shape[0],o.shape[1],o.shape[2]]));const c={images:a},h={alignCorners:t,halfPixelCenters:r,size:e},d=G.runKernel(f0,c,h);return u?J(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const UC=X({resizeBilinear_:BC});function jC(n,e,t=!1,r=!1){const o=O(n,"images","resizeNearestNeighbor");E(o.rank===3||o.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${o.rank}.`),E(e.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${e}.`),E(o.dtype==="float32"||o.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),E(r===!1||t===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let a=o,u=!1;o.rank===3&&(u=!0,a=J(o,[1,o.shape[0],o.shape[1],o.shape[2]]));const c={images:a},h={alignCorners:t,halfPixelCenters:r,size:e},d=G.runKernel(h0,c,h);return u?J(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const WC=X({resizeNearestNeighbor_:jC});function VC(n,e="binary",t=!1,r=.5){const o=O(n,"image","threshold"),a=.2989,u=.587,c=.114,h=o.shape[0]*o.shape[1];let d=P(jt([r]),255),m,g,v,w;if(E(o.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${o.rank}.`),E(o.shape[2]===3||o.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${o.shape[2]}.`),E(o.dtype==="int32"||o.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${o.dtype}.`),E(e==="otsu"||e==="binary",()=>`Method must be binary or otsu, but was ${e}`),o.shape[2]===3){[m,g,v]=pr(o,[1,1,1],-1);const x=P(m,a),T=P(g,u),z=P(v,c);w=le(le(x,T),z)}else w=n;if(e==="otsu"){const x=CI(Se(NN(w),"int32"),xi([]),256);d=GC(x,h)}const k=t?Vo(w,d):er(w,d);return Se(P(k,255),"int32")}function GC(n,e){let t=jt([-1]),r=jt([0]),o=jt([0]),a,u,c,h,d,m;for(let g=0;g<n.size-1;g++){a=it(n,0,g+1),u=it(n,g+1),d=$e(Ce(a),e),m=$e(Ce(u),e);const v=Ce(P(a,Ol(0,a.size)));c=$e(v,Ce(a));const w=ru(u.shape,a.size),k=le(Ol(0,u.size),w),S=P(u,k);h=$e(Ce(S),Ce(u));const x=Re(c,h),T=Re(c,h),z=P(d,m);o=P(P(z,x),T);const R=er(o,r);r=Rn(R,o,r),t=Rn(R,jt([g]),t)}return t}const qC=X({threshold_:VC});function HC(n,e,t="nearest",r="constant",o=0,a){const u=O(n,"image","transform","float32"),c=O(e,"transforms","transform","float32");E(u.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${u.rank}.`),E(c.rank===2&&(c.shape[0]===u.shape[0]||c.shape[0]===1)&&c.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),E(a==null||a.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${a}.`);const h={image:u,transforms:c},d={interpolation:t,fillMode:r,fillValue:o,outputShape:a};return G.runKernel(CA,h,d)}const KC=X({transform_:HC});function JC(n,e,t){E(e%1===0,()=>`bandPart(): numLower must be an integer, got ${e}.`),E(t%1===0,()=>`bandPart(): numUpper must be an integer, got ${t}.`);const r=O(n,"a","bandPart");E(r.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`);const o=r.shape,[a,u]=r.shape.slice(-2);if(!(e<=a))throw new Error(`bandPart(): numLower (${e}) must not be greater than the number of rows (${a}).`);if(!(t<=u))throw new Error(`bandPart(): numUpper (${t}) must not be greater than the number of columns (${u}).`);e<0&&(e=a),t<0&&(t=u);const c=J(Ol(0,a,1,"int32"),[-1,1]),h=Ol(0,u,1,"int32"),d=Re(c,h),m=Pi(Vo(d,Je(+e,"int32")),Wo(d,Je(-t,"int32"))),g=Ot([a,u],r.dtype);return J(ss($i(J(r,[-1,a,u])).map(v=>Rn(m,v,g))),o)}const XC=X({bandPart_:JC});function YC(n){let e;if(Array.isArray(n)){e=!1,E(n!=null&&n.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const o=n[0].shape[0];for(let a=1;a<n.length;++a)E(n[a].shape[0]===o,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${n[a].shape[0]} vs. ${o})`)}else e=!0,n=pr(n,n.shape[0],0).map(o=>zi(o,[0]));E(n.length<=n[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${n.length}) exceeds number of dimensions (${n[0].shape[0]}).`);const t=[],r=n;for(let o=0;o<n.length;++o)t.push(G.tidy(()=>{let a=r[o];if(o>0)for(let u=0;u<o;++u){const c=P(Ce(P(t[u],a)),t[u]);a=Re(a,c)}return $e(a,rb(a,"euclidean"))}));return e?ss(t,0):t}const ZC=X({gramSchmidt_:YC});function QC(n,e=!1){if(E(n.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${n.rank}`),n.rank===2)return Ry(n,e);{const t=n.shape.slice(0,n.shape.length-2).reduce((h,d)=>h*d),r=$i(J(n,[t,n.shape[n.shape.length-2],n.shape[n.shape.length-1]]),0),o=[],a=[];r.forEach(h=>{const[d,m]=Ry(h,e);o.push(d),a.push(m)});const u=J(ss(o,0),n.shape),c=J(ss(a,0),n.shape);return[u,c]}}function Ry(n,e=!1){return G.tidy(()=>{E(n.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${n.shape.length}D Tensor.`);const t=n.shape[0],r=n.shape[1];let o=sb(t),a=zs(n);const u=zl([[1]],[1,1]);let c=zs(u);const h=t>=r?r:t;for(let d=0;d<h;++d){const m=a,g=c,v=o;[c,a,o]=G.tidy(()=>{const w=it(a,[d,d],[t-d,1]),k=rb(w),S=it(a,[d,d],[1,1]),x=Rn(er(S,0),zl([[-1]]),zl([[1]])),T=Re(S,P(x,k)),z=$e(w,T);z.shape[0]===1?c=zs(u):c=Kn([u,it(z,[1,0],[z.shape[0]-1,z.shape[1]])],0);const R=Wt($e(et(x,T),k)),$=it(a,[d,0],[t-d,r]),B=P(R,c),H=We(c);if(d===0)a=Re($,et(B,et(H,$)));else{const ne=Re($,et(B,et(H,$)));a=Kn([it(a,[0,0],[d,r]),ne],0)}const Y=We(B),Z=it(o,[0,d],[t,o.shape[1]-d]);if(d===0)o=Re(Z,et(et(Z,c),Y));else{const ne=Re(Z,et(et(Z,c),Y));o=Kn([it(o,[0,0],[t,d]),ne],1)}return[c,a,o]}),Me([m,g,v])}return!e&&t>r&&(o=it(o,[0,0],[t,r]),a=it(a,[0,0],[r,r])),[o,a]})}const eD=X({qr_:QC});const fl={flipLeftRight:pC,grayscaleToRGB:gC,resizeNearestNeighbor:WC,resizeBilinear:UC,rotateWithOffset:vC,cropAndResize:fC,nonMaxSuppression:bC,nonMaxSuppressionAsync:zC,nonMaxSuppressionWithScore:MC,nonMaxSuppressionWithScoreAsync:_C,nonMaxSuppressionPadded:LC,nonMaxSuppressionPaddedAsync:PC,threshold:qC,transform:KC},tD={bandPart:XC,gramSchmidt:ZC,qr:eD};class us extends Oi{minimize(e,t=!1,r){const{value:o,grads:a}=this.computeGradients(e,r);if(r!=null){const u=r.map(c=>({name:c.name,tensor:a[c.name]}));this.applyGradients(u)}else this.applyGradients(a);return Me(a),t?o:(o.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return MT(e,t)}dispose(){this.iterations_!=null&&Me(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:Je(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}}Object.defineProperty(us,Symbol.hasInstance,{value:n=>n.minimize!=null&&n.computeGradients!=null&&n.applyGradients!=null});class xd extends us{constructor(e,t,r=null){super(),this.learningRate=e,this.rho=t,this.epsilon=r,this.accumulatedGrads=[],this.accumulatedUpdates=[],r==null&&(this.epsilon=G.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,o)=>{const a=G.registeredVariables[r],u=!1;this.accumulatedGrads[o]==null&&(this.accumulatedGrads[o]={originalName:`${r}/accum_grad`,variable:V(()=>He(a).variable(u))}),this.accumulatedUpdates[o]==null&&(this.accumulatedUpdates[o]={originalName:`${r}/accum_var`,variable:V(()=>He(a).variable(u))});const c=Array.isArray(e)?e[o].tensor:e[r];if(c==null)return;const h=this.accumulatedGrads[o].variable,d=this.accumulatedUpdates[o].variable;V(()=>{const m=le(P(h,this.rho),P(at(c),1-this.rho)),g=P($e(Kt(le(d,this.epsilon)),Kt(le(h,this.epsilon))),c),v=le(P(d,this.rho),P(at(g),1-this.rho));h.assign(m),d.assign(v);const w=le(P(g,-this.learningRate),a);a.assign(w)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(Me(this.accumulatedGrads.map(e=>e.variable)),Me(this.accumulatedUpdates.map(e=>e.variable)))}async getWeights(){const e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=e.length/2,r=!1;this.accumulatedGrads=e.slice(0,t).map(o=>({originalName:o.name,variable:o.tensor.variable(r)})),this.accumulatedUpdates=e.slice(t,t*2).map(o=>({originalName:o.name,variable:o.tensor.variable(r)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}}xd.className="Adadelta";re(xd);class Ed extends us{constructor(e,t=.1){super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,o)=>{const a=G.registeredVariables[r];this.accumulatedGrads[o]==null&&(this.accumulatedGrads[o]={originalName:`${r}/accumulator`,variable:V(()=>ru(a.shape,this.initialAccumulatorValue).variable(!1))});const u=Array.isArray(e)?e[o].tensor:e[r];if(u==null)return;const c=this.accumulatedGrads[o].variable;V(()=>{const h=le(c,at(u));c.assign(h);const d=le(P($e(u,Kt(le(h,G.backend.epsilon()))),-this.learningRate),a);a.assign(d)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&Me(this.accumulatedGrads.map(e=>e.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=!1;this.accumulatedGrads=e.map(r=>({originalName:r.name,variable:r.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}}Ed.className="Adagrad";re(Ed);class Ad extends us{constructor(e,t,r,o=null){super(),this.learningRate=e,this.beta1=t,this.beta2=r,this.epsilon=o,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],V(()=>{this.accBeta1=Je(t).variable(),this.accBeta2=Je(r).variable()}),o==null&&(this.epsilon=G.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map(r=>r.name):Object.keys(e);V(()=>{const r=Re(1,this.accBeta1),o=Re(1,this.accBeta2);t.forEach((a,u)=>{const c=G.registeredVariables[a],h=!1;this.accumulatedFirstMoment[u]==null&&(this.accumulatedFirstMoment[u]={originalName:`${a}/m`,variable:V(()=>He(c).variable(h))}),this.accumulatedSecondMoment[u]==null&&(this.accumulatedSecondMoment[u]={originalName:`${a}/v`,variable:V(()=>He(c).variable(h))});const d=Array.isArray(e)?e[u].tensor:e[a];if(d==null)return;const m=this.accumulatedFirstMoment[u].variable,g=this.accumulatedSecondMoment[u].variable,v=le(P(m,this.beta1),P(d,1-this.beta1)),w=le(P(g,this.beta2),P(at(d),1-this.beta2)),k=$e(v,r),S=$e(w,o);m.assign(v),g.assign(w);const x=le(P($e(k,le(Kt(S),this.epsilon)),-this.learningRate),c);c.assign(x)}),this.accBeta1.assign(P(this.accBeta1,this.beta1)),this.accBeta2.assign(P(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&Me(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedSecondMoment!=null&&Me(this.accumulatedSecondMoment.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e),V(()=>{this.accBeta1.assign(Fo(this.beta1,this.iterations_+1)),this.accBeta2.assign(Fo(this.beta2,this.iterations_+1))});const t=e.length/2,r=!1;this.accumulatedFirstMoment=e.slice(0,t).map(o=>({originalName:o.name,variable:o.tensor.variable(r)})),this.accumulatedSecondMoment=e.slice(t,t*2).map(o=>({originalName:o.name,variable:o.tensor.variable(r)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}}Ad.className="Adam";re(Ad);class Id extends us{constructor(e,t,r,o=null,a=0){super(),this.learningRate=e,this.beta1=t,this.beta2=r,this.epsilon=o,this.decay=a,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],V(()=>{this.iteration=Je(0).variable(),this.accBeta1=Je(t).variable()}),o==null&&(this.epsilon=G.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map(r=>r.name):Object.keys(e);V(()=>{const r=Re(1,this.accBeta1),o=$e(-this.learningRate,le(P(this.iteration,this.decay),1));t.forEach((a,u)=>{const c=G.registeredVariables[a],h=!1;this.accumulatedFirstMoment[u]==null&&(this.accumulatedFirstMoment[u]={originalName:`${a}/m`,variable:He(c).variable(h)}),this.accumulatedWeightedInfNorm[u]==null&&(this.accumulatedWeightedInfNorm[u]={originalName:`${a}/v`,variable:He(c).variable(h)});const d=Array.isArray(e)?e[u].tensor:e[a];if(d==null)return;const m=this.accumulatedFirstMoment[u].variable,g=this.accumulatedWeightedInfNorm[u].variable,v=le(P(m,this.beta1),P(d,1-this.beta1)),w=P(g,this.beta2),k=Zt(d),S=Bs(w,k);m.assign(v),g.assign(S);const x=le(P($e(o,r),$e(v,le(S,this.epsilon))),c);c.assign(x)}),this.iteration.assign(le(this.iteration,1)),this.accBeta1.assign(P(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&Me(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedWeightedInfNorm!=null&&Me(this.accumulatedWeightedInfNorm.map(e=>e.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}}Id.className="Adamax";re(Id);class au extends us{constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,o)=>{const a=Array.isArray(e)?e[o].tensor:e[r];if(a==null)return;const u=G.registeredVariables[r];V(()=>{const c=le(P(this.c,a),u);u.assign(c)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,this.c!=null&&this.c.dispose(),this.c=yr(Je(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(e=await this.extractIterations(e),e.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}}au.className="SGD";re(au);class Td extends au{constructor(e,t,r=!1){super(e),this.learningRate=e,this.momentum=t,this.useNesterov=r,this.accumulations=[],this.m=Je(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,o)=>{const a=G.registeredVariables[r];this.accumulations[o]==null&&(this.accumulations[o]={originalName:`${r}/momentum`,variable:V(()=>He(a).variable(!1))});const u=this.accumulations[o].variable,c=Array.isArray(e)?e[o].tensor:e[r];c!=null&&V(()=>{let h;const d=le(P(this.m,u),c);this.useNesterov?h=le(P(this.c,le(c,P(d,this.m))),a):h=le(P(this.c,d),a),u.assign(d),a.assign(h)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&Me(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=!1;this.accumulations=e.map(r=>({originalName:r.name,variable:r.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}}Td.className="Momentum";re(Td);class Nd extends us{constructor(e,t=.9,r=0,o=null,a=!1){if(super(),this.learningRate=e,this.decay=t,this.momentum=r,this.epsilon=o,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=a,o==null&&(this.epsilon=G.backend.epsilon()),e==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,o)=>{const a=G.registeredVariables[r],u=!1;this.accumulatedMeanSquares[o]==null&&(this.accumulatedMeanSquares[o]={originalName:`${r}/rms`,variable:V(()=>He(a).variable(u))}),this.accumulatedMoments[o]==null&&(this.accumulatedMoments[o]={originalName:`${r}/momentum`,variable:V(()=>He(a).variable(u))}),this.accumulatedMeanGrads[o]==null&&this.centered&&(this.accumulatedMeanGrads[o]={originalName:`${r}/mg`,variable:V(()=>He(a).variable(u))});const c=Array.isArray(e)?e[o].tensor:e[r];if(c==null)return;const h=this.accumulatedMeanSquares[o].variable,d=this.accumulatedMoments[o].variable;V(()=>{const m=le(P(h,this.decay),P(at(c),1-this.decay));if(this.centered){const g=this.accumulatedMeanGrads[o].variable,v=le(P(g,this.decay),P(c,1-this.decay)),w=$e(P(c,this.learningRate),Kt(Re(m,le(at(v),this.epsilon)))),k=le(P(d,this.momentum),w);h.assign(m),g.assign(v),d.assign(k);const S=Re(a,k);a.assign(S)}else{const g=le(P(h,this.decay),P(at(c),1-this.decay)),v=le(P(d,this.momentum),$e(P(c,this.learningRate),Kt(le(g,this.epsilon))));h.assign(g),d.assign(v);const w=Re(a,v);a.assign(w)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&Me(this.accumulatedMeanSquares.map(e=>e.variable)),this.accumulatedMeanGrads!=null&&this.centered&&Me(this.accumulatedMeanGrads.map(e=>e.variable)),this.accumulatedMoments!=null&&Me(this.accumulatedMoments.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=this.centered?e.length/3:e.length/2,r=!1;this.accumulatedMeanSquares=e.slice(0,t).map(o=>({originalName:o.name,variable:o.tensor.variable(r)})),this.accumulatedMoments=e.slice(t,t*2).map(o=>({originalName:o.name,variable:o.tensor.variable(r)})),this.centered&&(this.accumulatedMeanGrads=e.slice(t*2,t*3).map(o=>({originalName:o.name,variable:o.tensor.variable(r)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}}Nd.className="RMSProp";re(Nd);class Ts{static sgd(e){return new au(e)}static momentum(e,t,r=!1){return new Td(e,t,r)}static rmsprop(e,t=.9,r=0,o=null,a=!1){return new Nd(e,t,r,o,a)}static adam(e=.001,t=.9,r=.999,o=null){return new Ad(e,t,r,o)}static adadelta(e=.001,t=.95,r=null){return new xd(e,t,r)}static adamax(e=.002,t=.9,r=.999,o=null,a=0){return new Id(e,t,r,o,a)}static adagrad(e,t=.1){return new Ed(e,t)}}const gi={sgd:Ts.sgd,momentum:Ts.momentum,adadelta:Ts.adadelta,adagrad:Ts.adagrad,rmsprop:Ts.rmsprop,adamax:Ts.adamax,adam:Ts.adam};const nD=typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:n=>n();function rD(){return new Promise(n=>nD(()=>n()))}const sD=1.7580993408473768,iD=1.0507009873554805;var bh={},kh={},Sh,_y;function yb(){return _y||(_y=1,Sh=function(){if(typeof Symbol!="function"||typeof Object.getOwnPropertySymbols!="function")return!1;if(typeof Symbol.iterator=="symbol")return!0;var e={},t=Symbol("test"),r=Object(t);if(typeof t=="string"||Object.prototype.toString.call(t)!=="[object Symbol]"||Object.prototype.toString.call(r)!=="[object Symbol]")return!1;var o=42;e[t]=o;for(var a in e)return!1;if(typeof Object.keys=="function"&&Object.keys(e).length!==0||typeof Object.getOwnPropertyNames=="function"&&Object.getOwnPropertyNames(e).length!==0)return!1;var u=Object.getOwnPropertySymbols(e);if(u.length!==1||u[0]!==t||!Object.prototype.propertyIsEnumerable.call(e,t))return!1;if(typeof Object.getOwnPropertyDescriptor=="function"){var c=Object.getOwnPropertyDescriptor(e,t);if(c.value!==o||c.enumerable!==!0)return!1}return!0}),Sh}var xh,Fy;function Cd(){if(Fy)return xh;Fy=1;var n=yb();return xh=function(){return n()&&!!Symbol.toStringTag},xh}var Eh,Ly;function vb(){return Ly||(Ly=1,Eh=Object),Eh}var Ah,Oy;function oD(){return Oy||(Oy=1,Ah=Error),Ah}var Ih,Py;function aD(){return Py||(Py=1,Ih=EvalError),Ih}var Th,By;function lD(){return By||(By=1,Th=RangeError),Th}var Nh,Uy;function uD(){return Uy||(Uy=1,Nh=ReferenceError),Nh}var Ch,jy;function cD(){return jy||(jy=1,Ch=SyntaxError),Ch}var Dh,Wy;function wb(){return Wy||(Wy=1,Dh=TypeError),Dh}var zh,Vy;function hD(){return Vy||(Vy=1,zh=URIError),zh}var $h,Gy;function fD(){return Gy||(Gy=1,$h=Math.abs),$h}var Mh,qy;function dD(){return qy||(qy=1,Mh=Math.floor),Mh}var Rh,Hy;function pD(){return Hy||(Hy=1,Rh=Math.max),Rh}var _h,Ky;function mD(){return Ky||(Ky=1,_h=Math.min),_h}var Fh,Jy;function gD(){return Jy||(Jy=1,Fh=Math.pow),Fh}var Lh,Xy;function yD(){return Xy||(Xy=1,Lh=Math.round),Lh}var Oh,Yy;function vD(){return Yy||(Yy=1,Oh=Number.isNaN||function(e){return e!==e}),Oh}var Ph,Zy;function wD(){if(Zy)return Ph;Zy=1;var n=vD();return Ph=function(t){return n(t)||t===0?t:t<0?-1:1},Ph}var Bh,Qy;function bD(){return Qy||(Qy=1,Bh=Object.getOwnPropertyDescriptor),Bh}var Uh,ev;function Dd(){if(ev)return Uh;ev=1;var n=bD();if(n)try{n([],"length")}catch{n=null}return Uh=n,Uh}var jh,tv;function kD(){if(tv)return jh;tv=1;var n=Object.defineProperty||!1;if(n)try{n({},"a",{value:1})}catch{n=!1}return jh=n,jh}var Wh,nv;function SD(){if(nv)return Wh;nv=1;var n=typeof Symbol<"u"&&Symbol,e=yb();return Wh=function(){return typeof n!="function"||typeof Symbol!="function"||typeof n("foo")!="symbol"||typeof Symbol("bar")!="symbol"?!1:e()},Wh}var Vh,rv;function bb(){return rv||(rv=1,Vh=typeof Reflect<"u"&&Reflect.getPrototypeOf||null),Vh}var Gh,sv;function kb(){if(sv)return Gh;sv=1;var n=vb();return Gh=n.getPrototypeOf||null,Gh}var qh,iv;function xD(){if(iv)return qh;iv=1;var n="Function.prototype.bind called on incompatible ",e=Object.prototype.toString,t=Math.max,r="[object Function]",o=function(h,d){for(var m=[],g=0;g<h.length;g+=1)m[g]=h[g];for(var v=0;v<d.length;v+=1)m[v+h.length]=d[v];return m},a=function(h,d){for(var m=[],g=d,v=0;g<h.length;g+=1,v+=1)m[v]=h[g];return m},u=function(c,h){for(var d="",m=0;m<c.length;m+=1)d+=c[m],m+1<c.length&&(d+=h);return d};return qh=function(h){var d=this;if(typeof d!="function"||e.apply(d)!==r)throw new TypeError(n+d);for(var m=a(arguments,1),g,v=function(){if(this instanceof g){var T=d.apply(this,o(m,arguments));return Object(T)===T?T:this}return d.apply(h,o(m,arguments))},w=t(0,d.length-m.length),k=[],S=0;S<w;S++)k[S]="$"+S;if(g=Function("binder","return function ("+u(k,",")+"){ return binder.apply(this,arguments); }")(v),d.prototype){var x=function(){};x.prototype=d.prototype,g.prototype=new x,x.prototype=null}return g},qh}var Hh,ov;function qo(){if(ov)return Hh;ov=1;var n=xD();return Hh=Function.prototype.bind||n,Hh}var Kh,av;function zd(){return av||(av=1,Kh=Function.prototype.call),Kh}var Jh,lv;function Sb(){return lv||(lv=1,Jh=Function.prototype.apply),Jh}var Xh,uv;function ED(){return uv||(uv=1,Xh=typeof Reflect<"u"&&Reflect&&Reflect.apply),Xh}var Yh,cv;function AD(){if(cv)return Yh;cv=1;var n=qo(),e=Sb(),t=zd(),r=ED();return Yh=r||n.call(t,e),Yh}var Zh,hv;function xb(){if(hv)return Zh;hv=1;var n=qo(),e=wb(),t=zd(),r=AD();return Zh=function(a){if(a.length<1||typeof a[0]!="function")throw new e("a function is required");return r(n,t,a)},Zh}var Qh,fv;function ID(){if(fv)return Qh;fv=1;var n=xb(),e=Dd(),t;try{t=[].__proto__===Array.prototype}catch(u){if(!u||typeof u!="object"||!("code"in u)||u.code!=="ERR_PROTO_ACCESS")throw u}var r=!!t&&e&&e(Object.prototype,"__proto__"),o=Object,a=o.getPrototypeOf;return Qh=r&&typeof r.get=="function"?n([r.get]):typeof a=="function"?function(c){return a(c==null?c:o(c))}:!1,Qh}var ef,dv;function TD(){if(dv)return ef;dv=1;var n=bb(),e=kb(),t=ID();return ef=n?function(o){return n(o)}:e?function(o){if(!o||typeof o!="object"&&typeof o!="function")throw new TypeError("getProto: not an object");return e(o)}:t?function(o){return t(o)}:null,ef}var tf,pv;function ND(){if(pv)return tf;pv=1;var n=Function.prototype.call,e=Object.prototype.hasOwnProperty,t=qo();return tf=t.call(n,e),tf}var nf,mv;function $d(){if(mv)return nf;mv=1;var n,e=vb(),t=oD(),r=aD(),o=lD(),a=uD(),u=cD(),c=wb(),h=hD(),d=fD(),m=dD(),g=pD(),v=mD(),w=gD(),k=yD(),S=wD(),x=Function,T=function(ce){try{return x('"use strict"; return ('+ce+").constructor;")()}catch{}},z=Dd(),R=kD(),$=function(){throw new c},B=z?(function(){try{return arguments.callee,$}catch{try{return z(arguments,"callee").get}catch{return $}}})():$,H=SD()(),Y=TD(),Z=kb(),ne=bb(),oe=Sb(),de=zd(),me={},ve=typeof Uint8Array>"u"||!Y?n:Y(Uint8Array),be={__proto__:null,"%AggregateError%":typeof AggregateError>"u"?n:AggregateError,"%Array%":Array,"%ArrayBuffer%":typeof ArrayBuffer>"u"?n:ArrayBuffer,"%ArrayIteratorPrototype%":H&&Y?Y([][Symbol.iterator]()):n,"%AsyncFromSyncIteratorPrototype%":n,"%AsyncFunction%":me,"%AsyncGenerator%":me,"%AsyncGeneratorFunction%":me,"%AsyncIteratorPrototype%":me,"%Atomics%":typeof Atomics>"u"?n:Atomics,"%BigInt%":typeof BigInt>"u"?n:BigInt,"%BigInt64Array%":typeof BigInt64Array>"u"?n:BigInt64Array,"%BigUint64Array%":typeof BigUint64Array>"u"?n:BigUint64Array,"%Boolean%":Boolean,"%DataView%":typeof DataView>"u"?n:DataView,"%Date%":Date,"%decodeURI%":decodeURI,"%decodeURIComponent%":decodeURIComponent,"%encodeURI%":encodeURI,"%encodeURIComponent%":encodeURIComponent,"%Error%":t,"%eval%":eval,"%EvalError%":r,"%Float32Array%":typeof Float32Array>"u"?n:Float32Array,"%Float64Array%":typeof Float64Array>"u"?n:Float64Array,"%FinalizationRegistry%":typeof FinalizationRegistry>"u"?n:FinalizationRegistry,"%Function%":x,"%GeneratorFunction%":me,"%Int8Array%":typeof Int8Array>"u"?n:Int8Array,"%Int16Array%":typeof Int16Array>"u"?n:Int16Array,"%Int32Array%":typeof Int32Array>"u"?n:Int32Array,"%isFinite%":isFinite,"%isNaN%":isNaN,"%IteratorPrototype%":H&&Y?Y(Y([][Symbol.iterator]())):n,"%JSON%":typeof JSON=="object"?JSON:n,"%Map%":typeof Map>"u"?n:Map,"%MapIteratorPrototype%":typeof Map>"u"||!H||!Y?n:Y(new Map()[Symbol.iterator]()),"%Math%":Math,"%Number%":Number,"%Object%":e,"%Object.getOwnPropertyDescriptor%":z,"%parseFloat%":parseFloat,"%parseInt%":parseInt,"%Promise%":typeof Promise>"u"?n:Promise,"%Proxy%":typeof Proxy>"u"?n:Proxy,"%RangeError%":o,"%ReferenceError%":a,"%Reflect%":typeof Reflect>"u"?n:Reflect,"%RegExp%":RegExp,"%Set%":typeof Set>"u"?n:Set,"%SetIteratorPrototype%":typeof Set>"u"||!H||!Y?n:Y(new Set()[Symbol.iterator]()),"%SharedArrayBuffer%":typeof SharedArrayBuffer>"u"?n:SharedArrayBuffer,"%String%":String,"%StringIteratorPrototype%":H&&Y?Y(""[Symbol.iterator]()):n,"%Symbol%":H?Symbol:n,"%SyntaxError%":u,"%ThrowTypeError%":B,"%TypedArray%":ve,"%TypeError%":c,"%Uint8Array%":typeof Uint8Array>"u"?n:Uint8Array,"%Uint8ClampedArray%":typeof Uint8ClampedArray>"u"?n:Uint8ClampedArray,"%Uint16Array%":typeof Uint16Array>"u"?n:Uint16Array,"%Uint32Array%":typeof Uint32Array>"u"?n:Uint32Array,"%URIError%":h,"%WeakMap%":typeof WeakMap>"u"?n:WeakMap,"%WeakRef%":typeof WeakRef>"u"?n:WeakRef,"%WeakSet%":typeof WeakSet>"u"?n:WeakSet,"%Function.prototype.call%":de,"%Function.prototype.apply%":oe,"%Object.defineProperty%":R,"%Object.getPrototypeOf%":Z,"%Math.abs%":d,"%Math.floor%":m,"%Math.max%":g,"%Math.min%":v,"%Math.pow%":w,"%Math.round%":k,"%Math.sign%":S,"%Reflect.getPrototypeOf%":ne};if(Y)try{null.error}catch(ce){var Ne=Y(Y(ce));be["%Error.prototype%"]=Ne}var Ie=function ce(pe){var we;if(pe==="%AsyncFunction%")we=T("async function () {}");else if(pe==="%GeneratorFunction%")we=T("function* () {}");else if(pe==="%AsyncGeneratorFunction%")we=T("async function* () {}");else if(pe==="%AsyncGenerator%"){var ge=ce("%AsyncGeneratorFunction%");ge&&(we=ge.prototype)}else if(pe==="%AsyncIteratorPrototype%"){var Le=ce("%AsyncGenerator%");Le&&Y&&(we=Y(Le.prototype))}return be[pe]=we,we},Ee={__proto__:null,"%ArrayBufferPrototype%":["ArrayBuffer","prototype"],"%ArrayPrototype%":["Array","prototype"],"%ArrayProto_entries%":["Array","prototype","entries"],"%ArrayProto_forEach%":["Array","prototype","forEach"],"%ArrayProto_keys%":["Array","prototype","keys"],"%ArrayProto_values%":["Array","prototype","values"],"%AsyncFunctionPrototype%":["AsyncFunction","prototype"],"%AsyncGenerator%":["AsyncGeneratorFunction","prototype"],"%AsyncGeneratorPrototype%":["AsyncGeneratorFunction","prototype","prototype"],"%BooleanPrototype%":["Boolean","prototype"],"%DataViewPrototype%":["DataView","prototype"],"%DatePrototype%":["Date","prototype"],"%ErrorPrototype%":["Error","prototype"],"%EvalErrorPrototype%":["EvalError","prototype"],"%Float32ArrayPrototype%":["Float32Array","prototype"],"%Float64ArrayPrototype%":["Float64Array","prototype"],"%FunctionPrototype%":["Function","prototype"],"%Generator%":["GeneratorFunction","prototype"],"%GeneratorPrototype%":["GeneratorFunction","prototype","prototype"],"%Int8ArrayPrototype%":["Int8Array","prototype"],"%Int16ArrayPrototype%":["Int16Array","prototype"],"%Int32ArrayPrototype%":["Int32Array","prototype"],"%JSONParse%":["JSON","parse"],"%JSONStringify%":["JSON","stringify"],"%MapPrototype%":["Map","prototype"],"%NumberPrototype%":["Number","prototype"],"%ObjectPrototype%":["Object","prototype"],"%ObjProto_toString%":["Object","prototype","toString"],"%ObjProto_valueOf%":["Object","prototype","valueOf"],"%PromisePrototype%":["Promise","prototype"],"%PromiseProto_then%":["Promise","prototype","then"],"%Promise_all%":["Promise","all"],"%Promise_reject%":["Promise","reject"],"%Promise_resolve%":["Promise","resolve"],"%RangeErrorPrototype%":["RangeError","prototype"],"%ReferenceErrorPrototype%":["ReferenceError","prototype"],"%RegExpPrototype%":["RegExp","prototype"],"%SetPrototype%":["Set","prototype"],"%SharedArrayBufferPrototype%":["SharedArrayBuffer","prototype"],"%StringPrototype%":["String","prototype"],"%SymbolPrototype%":["Symbol","prototype"],"%SyntaxErrorPrototype%":["SyntaxError","prototype"],"%TypedArrayPrototype%":["TypedArray","prototype"],"%TypeErrorPrototype%":["TypeError","prototype"],"%Uint8ArrayPrototype%":["Uint8Array","prototype"],"%Uint8ClampedArrayPrototype%":["Uint8ClampedArray","prototype"],"%Uint16ArrayPrototype%":["Uint16Array","prototype"],"%Uint32ArrayPrototype%":["Uint32Array","prototype"],"%URIErrorPrototype%":["URIError","prototype"],"%WeakMapPrototype%":["WeakMap","prototype"],"%WeakSetPrototype%":["WeakSet","prototype"]},D=qo(),I=ND(),A=D.call(de,Array.prototype.concat),W=D.call(oe,Array.prototype.splice),te=D.call(de,String.prototype.replace),N=D.call(de,String.prototype.slice),F=D.call(de,RegExp.prototype.exec),U=/[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g,Q=/\\(\\)?/g,ue=function(pe){var we=N(pe,0,1),ge=N(pe,-1);if(we==="%"&&ge!=="%")throw new u("invalid intrinsic syntax, expected closing `%`");if(ge==="%"&&we!=="%")throw new u("invalid intrinsic syntax, expected opening `%`");var Le=[];return te(pe,U,function(Pe,Ve,je,wt){Le[Le.length]=je?te(wt,Q,"$1"):Ve||Pe}),Le},fe=function(pe,we){var ge=pe,Le;if(I(Ee,ge)&&(Le=Ee[ge],ge="%"+Le[0]+"%"),I(be,ge)){var Pe=be[ge];if(Pe===me&&(Pe=Ie(ge)),typeof Pe>"u"&&!we)throw new c("intrinsic "+pe+" exists, but is not available. Please file an issue!");return{alias:Le,name:ge,value:Pe}}throw new u("intrinsic "+pe+" does not exist!")};return nf=function(pe,we){if(typeof pe!="string"||pe.length===0)throw new c("intrinsic name must be a non-empty string");if(arguments.length>1&&typeof we!="boolean")throw new c('"allowMissing" argument must be a boolean');if(F(/^%?[^%]*%?$/,pe)===null)throw new u("`%` may not be present anywhere but at the beginning and end of the intrinsic name");var ge=ue(pe),Le=ge.length>0?ge[0]:"",Pe=fe("%"+Le+"%",we),Ve=Pe.name,je=Pe.value,wt=!1,Nt=Pe.alias;Nt&&(Le=Nt[0],W(ge,A([0,1],Nt)));for(var ee=1,Jt=!0;ee<ge.length;ee+=1){var Ct=ge[ee],Fn=N(Ct,0,1),wr=N(Ct,-1);if((Fn==='"'||Fn==="'"||Fn==="`"||wr==='"'||wr==="'"||wr==="`")&&Fn!==wr)throw new u("property names with quotes must have matching quotes");if((Ct==="constructor"||!Jt)&&(wt=!0),Le+="."+Ct,Ve="%"+Le+"%",I(be,Ve))je=be[Ve];else if(je!=null){if(!(Ct in je)){if(!we)throw new c("base intrinsic for "+pe+" exists, but the property is not available.");return}if(z&&ee+1>=ge.length){var nr=z(je,Ct);Jt=!!nr,Jt&&"get"in nr&&!("originalValue"in nr.get)?je=nr.get:je=je[Ct]}else Jt=I(je,Ct),je=je[Ct];Jt&&!wt&&(be[Ve]=je)}}return je},nf}var rf,gv;function CD(){if(gv)return rf;gv=1;var n=$d(),e=xb(),t=e([n("%String.prototype.indexOf%")]);return rf=function(o,a){var u=n(o,!!a);return typeof u=="function"&&t(o,".prototype.")>-1?e([u]):u},rf}var sf,yv;function DD(){if(yv)return sf;yv=1;var n=Cd()(),e=CD(),t=e("Object.prototype.toString"),r=function(c){return n&&c&&typeof c=="object"&&Symbol.toStringTag in c?!1:t(c)==="[object Arguments]"},o=function(c){return r(c)?!0:c!==null&&typeof c=="object"&&"length"in c&&typeof c.length=="number"&&c.length>=0&&t(c)!=="[object Array]"&&"callee"in c&&t(c.callee)==="[object Function]"},a=(function(){return r(arguments)})();return r.isLegacyArguments=o,sf=a?r:o,sf}var of,vv;function zD(){if(vv)return of;vv=1;var n=Object.prototype.toString,e=Function.prototype.toString,t=/^\s*(?:function)?\*/,r=Cd()(),o=Object.getPrototypeOf,a=function(){if(!r)return!1;try{return Function("return function*() {}")()}catch{}},u;return of=function(h){if(typeof h!="function")return!1;if(t.test(e.call(h)))return!0;if(!r){var d=n.call(h);return d==="[object GeneratorFunction]"}if(!o)return!1;if(typeof u>"u"){var m=a();u=m?o(m):!1}return o(h)===u},of}var af,wv;function $D(){if(wv)return af;wv=1;var n=Function.prototype.toString,e=typeof Reflect=="object"&&Reflect!==null&&Reflect.apply,t,r;if(typeof e=="function"&&typeof Object.defineProperty=="function")try{t=Object.defineProperty({},"length",{get:function(){throw r}}),r={},e(function(){throw 42},null,t)}catch(z){z!==r&&(e=null)}else e=null;var o=/^\s*class\b/,a=function(R){try{var $=n.call(R);return o.test($)}catch{return!1}},u=function(R){try{return a(R)?!1:(n.call(R),!0)}catch{return!1}},c=Object.prototype.toString,h="[object Object]",d="[object Function]",m="[object GeneratorFunction]",g="[object HTMLAllCollection]",v="[object HTML document.all class]",w="[object HTMLCollection]",k=typeof Symbol=="function"&&!!Symbol.toStringTag,S=!(0 in[,]),x=function(){return!1};if(typeof document=="object"){var T=document.all;c.call(T)===c.call(document.all)&&(x=function(R){if((S||!R)&&(typeof R>"u"||typeof R=="object"))try{var $=c.call(R);return($===g||$===v||$===w||$===h)&&R("")==null}catch{}return!1})}return af=e?function(R){if(x(R))return!0;if(!R||typeof R!="function"&&typeof R!="object")return!1;try{e(R,null,t)}catch($){if($!==r)return!1}return!a(R)&&u(R)}:function(R){if(x(R))return!0;if(!R||typeof R!="function"&&typeof R!="object")return!1;if(k)return u(R);if(a(R))return!1;var $=c.call(R);return $!==d&&$!==m&&!/^\[object HTML/.test($)?!1:u(R)},af}var lf,bv;function MD(){if(bv)return lf;bv=1;var n=$D(),e=Object.prototype.toString,t=Object.prototype.hasOwnProperty,r=function(h,d,m){for(var g=0,v=h.length;g<v;g++)t.call(h,g)&&(m==null?d(h[g],g,h):d.call(m,h[g],g,h))},o=function(h,d,m){for(var g=0,v=h.length;g<v;g++)m==null?d(h.charAt(g),g,h):d.call(m,h.charAt(g),g,h)},a=function(h,d,m){for(var g in h)t.call(h,g)&&(m==null?d(h[g],g,h):d.call(m,h[g],g,h))},u=function(h,d,m){if(!n(d))throw new TypeError("iterator must be a function");var g;arguments.length>=3&&(g=m),e.call(h)==="[object Array]"?r(h,d,g):typeof h=="string"?o(h,d,g):a(h,d,g)};return lf=u,lf}var uf,kv;function RD(){if(kv)return uf;kv=1;var n=["BigInt64Array","BigUint64Array","Float32Array","Float64Array","Int16Array","Int32Array","Int8Array","Uint16Array","Uint32Array","Uint8Array","Uint8ClampedArray"],e=typeof globalThis>"u"?pw:globalThis;return uf=function(){for(var r=[],o=0;o<n.length;o++)typeof e[n[o]]=="function"&&(r[r.length]=n[o]);return r},uf}var cf={exports:{}},Sv;function Eb(){return Sv||(Sv=1,(function(n){var e=qo(),t=$d(),r=t("%Function.prototype.apply%"),o=t("%Function.prototype.call%"),a=t("%Reflect.apply%",!0)||e.call(o,r),u=t("%Object.getOwnPropertyDescriptor%",!0),c=t("%Object.defineProperty%",!0),h=t("%Math.max%");if(c)try{c({},"a",{value:1})}catch{c=null}n.exports=function(g){var v=a(e,o,arguments);if(u&&c){var w=u(v,"length");w.configurable&&c(v,"length",{value:1+h(0,g.length-(arguments.length-1))})}return v};var d=function(){return a(e,r,arguments)};c?c(n.exports,"apply",{value:d}):n.exports.apply=d})(cf)),cf.exports}var hf,xv;function _D(){if(xv)return hf;xv=1;var n=$d(),e=Eb(),t=e(n("String.prototype.indexOf"));return hf=function(o,a){var u=n(o,!!a);return typeof u=="function"&&t(o,".prototype.")>-1?e(u):u},hf}var ff,Ev;function Ab(){if(Ev)return ff;Ev=1;var n=MD(),e=RD(),t=Eb(),r=_D(),o=Dd(),a=r("Object.prototype.toString"),u=Cd()(),c=typeof globalThis>"u"?pw:globalThis,h=e(),d=r("String.prototype.slice"),m=Object.getPrototypeOf,g=r("Array.prototype.indexOf",!0)||function(x,T){for(var z=0;z<x.length;z+=1)if(x[z]===T)return z;return-1},v={__proto__:null};u&&o&&m?n(h,function(S){var x=new c[S];if(Symbol.toStringTag in x){var T=m(x),z=o(T,Symbol.toStringTag);if(!z){var R=m(T);z=o(R,Symbol.toStringTag)}v["$"+S]=t(z.get)}}):n(h,function(S){var x=new c[S];v["$"+S]=t(x.slice)});var w=function(x){var T=!1;return n(v,function(z,R){if(!T)try{"$"+z(x)===R&&(T=d(R,1))}catch{}}),T},k=function(x){var T=!1;return n(v,function(z,R){if(!T)try{z(x),T=d(R,1)}catch{}}),T};return ff=function(x){if(!x||typeof x!="object")return!1;if(!u){var T=d(a(x),8,-1);return g(h,T)>-1?T:T!=="Object"?!1:k(x)}return o?w(x):null},ff}var df,Av;function FD(){if(Av)return df;Av=1;var n=Ab();return df=function(t){return!!n(t)},df}var Iv;function LD(){return Iv||(Iv=1,(function(n){var e=DD(),t=zD(),r=Ab(),o=FD();function a(ee){return ee.call.bind(ee)}var u=typeof BigInt<"u",c=typeof Symbol<"u",h=a(Object.prototype.toString),d=a(Number.prototype.valueOf),m=a(String.prototype.valueOf),g=a(Boolean.prototype.valueOf);if(u)var v=a(BigInt.prototype.valueOf);if(c)var w=a(Symbol.prototype.valueOf);function k(ee,Jt){if(typeof ee!="object")return!1;try{return Jt(ee),!0}catch{return!1}}n.isArgumentsObject=e,n.isGeneratorFunction=t,n.isTypedArray=o;function S(ee){return typeof Promise<"u"&&ee instanceof Promise||ee!==null&&typeof ee=="object"&&typeof ee.then=="function"&&typeof ee.catch=="function"}n.isPromise=S;function x(ee){return typeof ArrayBuffer<"u"&&ArrayBuffer.isView?ArrayBuffer.isView(ee):o(ee)||N(ee)}n.isArrayBufferView=x;function T(ee){return r(ee)==="Uint8Array"}n.isUint8Array=T;function z(ee){return r(ee)==="Uint8ClampedArray"}n.isUint8ClampedArray=z;function R(ee){return r(ee)==="Uint16Array"}n.isUint16Array=R;function $(ee){return r(ee)==="Uint32Array"}n.isUint32Array=$;function B(ee){return r(ee)==="Int8Array"}n.isInt8Array=B;function H(ee){return r(ee)==="Int16Array"}n.isInt16Array=H;function Y(ee){return r(ee)==="Int32Array"}n.isInt32Array=Y;function Z(ee){return r(ee)==="Float32Array"}n.isFloat32Array=Z;function ne(ee){return r(ee)==="Float64Array"}n.isFloat64Array=ne;function oe(ee){return r(ee)==="BigInt64Array"}n.isBigInt64Array=oe;function de(ee){return r(ee)==="BigUint64Array"}n.isBigUint64Array=de;function me(ee){return h(ee)==="[object Map]"}me.working=typeof Map<"u"&&me(new Map);function ve(ee){return typeof Map>"u"?!1:me.working?me(ee):ee instanceof Map}n.isMap=ve;function be(ee){return h(ee)==="[object Set]"}be.working=typeof Set<"u"&&be(new Set);function Ne(ee){return typeof Set>"u"?!1:be.working?be(ee):ee instanceof Set}n.isSet=Ne;function Ie(ee){return h(ee)==="[object WeakMap]"}Ie.working=typeof WeakMap<"u"&&Ie(new WeakMap);function Ee(ee){return typeof WeakMap>"u"?!1:Ie.working?Ie(ee):ee instanceof WeakMap}n.isWeakMap=Ee;function D(ee){return h(ee)==="[object WeakSet]"}D.working=typeof WeakSet<"u"&&D(new WeakSet);function I(ee){return D(ee)}n.isWeakSet=I;function A(ee){return h(ee)==="[object ArrayBuffer]"}A.working=typeof ArrayBuffer<"u"&&A(new ArrayBuffer);function W(ee){return typeof ArrayBuffer>"u"?!1:A.working?A(ee):ee instanceof ArrayBuffer}n.isArrayBuffer=W;function te(ee){return h(ee)==="[object DataView]"}te.working=typeof ArrayBuffer<"u"&&typeof DataView<"u"&&te(new DataView(new ArrayBuffer(1),0,1));function N(ee){return typeof DataView>"u"?!1:te.working?te(ee):ee instanceof DataView}n.isDataView=N;var F=typeof SharedArrayBuffer<"u"?SharedArrayBuffer:void 0;function U(ee){return h(ee)==="[object SharedArrayBuffer]"}function Q(ee){return typeof F>"u"?!1:(typeof U.working>"u"&&(U.working=U(new F)),U.working?U(ee):ee instanceof F)}n.isSharedArrayBuffer=Q;function ue(ee){return h(ee)==="[object AsyncFunction]"}n.isAsyncFunction=ue;function fe(ee){return h(ee)==="[object Map Iterator]"}n.isMapIterator=fe;function ce(ee){return h(ee)==="[object Set Iterator]"}n.isSetIterator=ce;function pe(ee){return h(ee)==="[object Generator]"}n.isGeneratorObject=pe;function we(ee){return h(ee)==="[object WebAssembly.Module]"}n.isWebAssemblyCompiledModule=we;function ge(ee){return k(ee,d)}n.isNumberObject=ge;function Le(ee){return k(ee,m)}n.isStringObject=Le;function Pe(ee){return k(ee,g)}n.isBooleanObject=Pe;function Ve(ee){return u&&k(ee,v)}n.isBigIntObject=Ve;function je(ee){return c&&k(ee,w)}n.isSymbolObject=je;function wt(ee){return ge(ee)||Le(ee)||Pe(ee)||Ve(ee)||je(ee)}n.isBoxedPrimitive=wt;function Nt(ee){return typeof Uint8Array<"u"&&(W(ee)||Q(ee))}n.isAnyArrayBuffer=Nt,["isProxy","isExternal","isModuleNamespaceObject"].forEach(function(ee){Object.defineProperty(n,ee,{enumerable:!1,value:function(){throw new Error(ee+" is not supported in userland")}})})})(kh)),kh}var pf,Tv;function OD(){return Tv||(Tv=1,pf=function(e){return e&&typeof e=="object"&&typeof e.copy=="function"&&typeof e.fill=="function"&&typeof e.readUInt8=="function"}),pf}var dl={exports:{}},Nv;function PD(){return Nv||(Nv=1,typeof Object.create=="function"?dl.exports=function(e,t){t&&(e.super_=t,e.prototype=Object.create(t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}))}:dl.exports=function(e,t){if(t){e.super_=t;var r=function(){};r.prototype=t.prototype,e.prototype=new r,e.prototype.constructor=e}}),dl.exports}var Cv;function BD(){return Cv||(Cv=1,(function(n){var e={},t=Object.getOwnPropertyDescriptors||function(F){for(var U=Object.keys(F),Q={},ue=0;ue<U.length;ue++)Q[U[ue]]=Object.getOwnPropertyDescriptor(F,U[ue]);return Q},r=/%[sdj%]/g;n.format=function(N){if(!H(N)){for(var F=[],U=0;U<arguments.length;U++)F.push(c(arguments[U]));return F.join(" ")}for(var U=1,Q=arguments,ue=Q.length,fe=String(N).replace(r,function(pe){if(pe==="%%")return"%";if(U>=ue)return pe;switch(pe){case"%s":return String(Q[U++]);case"%d":return Number(Q[U++]);case"%j":try{return JSON.stringify(Q[U++])}catch{return"[Circular]"}default:return pe}}),ce=Q[U];U<ue;ce=Q[++U])R(ce)||!oe(ce)?fe+=" "+ce:fe+=" "+c(ce);return fe},n.deprecate=function(N,F){if(typeof process<"u"&&process.noDeprecation===!0)return N;if(typeof process>"u")return function(){return n.deprecate(N,F).apply(this,arguments)};var U=!1;function Q(){if(!U){if(process.throwDeprecation)throw new Error(F);process.traceDeprecation?console.trace(F):console.error(F),U=!0}return N.apply(this,arguments)}return Q};var o={},a=/^$/;if(e.NODE_DEBUG){var u=e.NODE_DEBUG;u=u.replace(/[|\\{}()[\]^$+?.]/g,"\\$&").replace(/\*/g,".*").replace(/,/g,"$|^").toUpperCase(),a=new RegExp("^"+u+"$","i")}n.debuglog=function(N){if(N=N.toUpperCase(),!o[N])if(a.test(N)){var F=process.pid;o[N]=function(){var U=n.format.apply(n,arguments);console.error("%s %d: %s",N,F,U)}}else o[N]=function(){};return o[N]};function c(N,F){var U={seen:[],stylize:d};return arguments.length>=3&&(U.depth=arguments[2]),arguments.length>=4&&(U.colors=arguments[3]),z(F)?U.showHidden=F:F&&n._extend(U,F),Z(U.showHidden)&&(U.showHidden=!1),Z(U.depth)&&(U.depth=2),Z(U.colors)&&(U.colors=!1),Z(U.customInspect)&&(U.customInspect=!0),U.colors&&(U.stylize=h),g(U,N,U.depth)}n.inspect=c,c.colors={bold:[1,22],italic:[3,23],underline:[4,24],inverse:[7,27],white:[37,39],grey:[90,39],black:[30,39],blue:[34,39],cyan:[36,39],green:[32,39],magenta:[35,39],red:[31,39],yellow:[33,39]},c.styles={special:"cyan",number:"yellow",boolean:"yellow",undefined:"grey",null:"bold",string:"green",date:"magenta",regexp:"red"};function h(N,F){var U=c.styles[F];return U?"\x1B["+c.colors[U][0]+"m"+N+"\x1B["+c.colors[U][1]+"m":N}function d(N,F){return N}function m(N){var F={};return N.forEach(function(U,Q){F[U]=!0}),F}function g(N,F,U){if(N.customInspect&&F&&ve(F.inspect)&&F.inspect!==n.inspect&&!(F.constructor&&F.constructor.prototype===F)){var Q=F.inspect(U,N);return H(Q)||(Q=g(N,Q,U)),Q}var ue=v(N,F);if(ue)return ue;var fe=Object.keys(F),ce=m(fe);if(N.showHidden&&(fe=Object.getOwnPropertyNames(F)),me(F)&&(fe.indexOf("message")>=0||fe.indexOf("description")>=0))return w(F);if(fe.length===0){if(ve(F)){var pe=F.name?": "+F.name:"";return N.stylize("[Function"+pe+"]","special")}if(ne(F))return N.stylize(RegExp.prototype.toString.call(F),"regexp");if(de(F))return N.stylize(Date.prototype.toString.call(F),"date");if(me(F))return w(F)}var we="",ge=!1,Le=["{","}"];if(T(F)&&(ge=!0,Le=["[","]"]),ve(F)){var Pe=F.name?": "+F.name:"";we=" [Function"+Pe+"]"}if(ne(F)&&(we=" "+RegExp.prototype.toString.call(F)),de(F)&&(we=" "+Date.prototype.toUTCString.call(F)),me(F)&&(we=" "+w(F)),fe.length===0&&(!ge||F.length==0))return Le[0]+we+Le[1];if(U<0)return ne(F)?N.stylize(RegExp.prototype.toString.call(F),"regexp"):N.stylize("[Object]","special");N.seen.push(F);var Ve;return ge?Ve=k(N,F,U,ce,fe):Ve=fe.map(function(je){return S(N,F,U,ce,je,ge)}),N.seen.pop(),x(Ve,we,Le)}function v(N,F){if(Z(F))return N.stylize("undefined","undefined");if(H(F)){var U="'"+JSON.stringify(F).replace(/^"|"$/g,"").replace(/'/g,"\\'").replace(/\\"/g,'"')+"'";return N.stylize(U,"string")}if(B(F))return N.stylize(""+F,"number");if(z(F))return N.stylize(""+F,"boolean");if(R(F))return N.stylize("null","null")}function w(N){return"["+Error.prototype.toString.call(N)+"]"}function k(N,F,U,Q,ue){for(var fe=[],ce=0,pe=F.length;ce<pe;++ce)I(F,String(ce))?fe.push(S(N,F,U,Q,String(ce),!0)):fe.push("");return ue.forEach(function(we){we.match(/^\d+$/)||fe.push(S(N,F,U,Q,we,!0))}),fe}function S(N,F,U,Q,ue,fe){var ce,pe,we;if(we=Object.getOwnPropertyDescriptor(F,ue)||{value:F[ue]},we.get?we.set?pe=N.stylize("[Getter/Setter]","special"):pe=N.stylize("[Getter]","special"):we.set&&(pe=N.stylize("[Setter]","special")),I(Q,ue)||(ce="["+ue+"]"),pe||(N.seen.indexOf(we.value)<0?(R(U)?pe=g(N,we.value,null):pe=g(N,we.value,U-1),pe.indexOf(`
`)>-1&&(fe?pe=pe.split(`
`).map(function(ge){return"  "+ge}).join(`
`).slice(2):pe=`
`+pe.split(`
`).map(function(ge){return"   "+ge}).join(`
`))):pe=N.stylize("[Circular]","special")),Z(ce)){if(fe&&ue.match(/^\d+$/))return pe;ce=JSON.stringify(""+ue),ce.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)?(ce=ce.slice(1,-1),ce=N.stylize(ce,"name")):(ce=ce.replace(/'/g,"\\'").replace(/\\"/g,'"').replace(/(^"|"$)/g,"'"),ce=N.stylize(ce,"string"))}return ce+": "+pe}function x(N,F,U){var Q=N.reduce(function(ue,fe){return fe.indexOf(`
`)>=0,ue+fe.replace(/\u001b\[\d\d?m/g,"").length+1},0);return Q>60?U[0]+(F===""?"":F+`
 `)+" "+N.join(`,
  `)+" "+U[1]:U[0]+F+" "+N.join(", ")+" "+U[1]}n.types=LD();function T(N){return Array.isArray(N)}n.isArray=T;function z(N){return typeof N=="boolean"}n.isBoolean=z;function R(N){return N===null}n.isNull=R;function $(N){return N==null}n.isNullOrUndefined=$;function B(N){return typeof N=="number"}n.isNumber=B;function H(N){return typeof N=="string"}n.isString=H;function Y(N){return typeof N=="symbol"}n.isSymbol=Y;function Z(N){return N===void 0}n.isUndefined=Z;function ne(N){return oe(N)&&Ne(N)==="[object RegExp]"}n.isRegExp=ne,n.types.isRegExp=ne;function oe(N){return typeof N=="object"&&N!==null}n.isObject=oe;function de(N){return oe(N)&&Ne(N)==="[object Date]"}n.isDate=de,n.types.isDate=de;function me(N){return oe(N)&&(Ne(N)==="[object Error]"||N instanceof Error)}n.isError=me,n.types.isNativeError=me;function ve(N){return typeof N=="function"}n.isFunction=ve;function be(N){return N===null||typeof N=="boolean"||typeof N=="number"||typeof N=="string"||typeof N=="symbol"||typeof N>"u"}n.isPrimitive=be,n.isBuffer=OD();function Ne(N){return Object.prototype.toString.call(N)}function Ie(N){return N<10?"0"+N.toString(10):N.toString(10)}var Ee=["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];function D(){var N=new Date,F=[Ie(N.getHours()),Ie(N.getMinutes()),Ie(N.getSeconds())].join(":");return[N.getDate(),Ee[N.getMonth()],F].join(" ")}n.log=function(){console.log("%s - %s",D(),n.format.apply(n,arguments))},n.inherits=PD(),n._extend=function(N,F){if(!F||!oe(F))return N;for(var U=Object.keys(F),Q=U.length;Q--;)N[U[Q]]=F[U[Q]];return N};function I(N,F){return Object.prototype.hasOwnProperty.call(N,F)}var A=typeof Symbol<"u"?Symbol("util.promisify.custom"):void 0;n.promisify=function(F){if(typeof F!="function")throw new TypeError('The "original" argument must be of type Function');if(A&&F[A]){var U=F[A];if(typeof U!="function")throw new TypeError('The "util.promisify.custom" argument must be of type Function');return Object.defineProperty(U,A,{value:U,enumerable:!1,writable:!1,configurable:!0}),U}function U(){for(var Q,ue,fe=new Promise(function(we,ge){Q=we,ue=ge}),ce=[],pe=0;pe<arguments.length;pe++)ce.push(arguments[pe]);ce.push(function(we,ge){we?ue(we):Q(ge)});try{F.apply(this,ce)}catch(we){ue(we)}return fe}return Object.setPrototypeOf(U,Object.getPrototypeOf(F)),A&&Object.defineProperty(U,A,{value:U,enumerable:!1,writable:!1,configurable:!0}),Object.defineProperties(U,t(F))},n.promisify.custom=A;function W(N,F){if(!N){var U=new Error("Promise was rejected with a falsy value");U.reason=N,N=U}return F(N)}function te(N){if(typeof N!="function")throw new TypeError('The "original" argument must be of type Function');function F(){for(var U=[],Q=0;Q<arguments.length;Q++)U.push(arguments[Q]);var ue=U.pop();if(typeof ue!="function")throw new TypeError("The last argument must be of type Function");var fe=this,ce=function(){return ue.apply(fe,arguments)};N.apply(this,U).then(function(pe){process.nextTick(ce.bind(null,null,pe))},function(pe){process.nextTick(W.bind(null,pe,ce))})}return Object.setPrototypeOf(F,Object.getPrototypeOf(N)),Object.defineProperties(F,t(N)),F}n.callbackify=te})(bh)),bh}var UD=BD();function jD(n,e){return Ul(n,e)}function Ul(n,e,t=new Map,r=new Set){if(n==null)return null;if(typeof Blob=="function"&&n instanceof Blob)return n.slice();if(r.has(n))throw new Error("Circular references are not supported.");if(t.has(n))return t.get(n);const o=e(n);if(o.recurse&&o.value!==null)throw new Error("A deep map function may not return both a value and recurse=true.");if(o.recurse)if(Mi(n)){const a=Array.isArray(n)?[]:{};r.add(n);for(const u in n){const c=n[u],h=Ul(c,e,t,r);a[u]=h}return r.delete(n),n.__proto__&&(a.__proto__=n.__proto__),a}else throw new Error(`Can't recurse into non-iterable type: ${n}`);else return t.set(n,o.value),o.value}function WD(n,e=Tb){return Ib(n,e)}function Ib(n,e,t=new Set){const r=n[0];if(t.has(r))throw new Error("Circular references are not supported.");const o=e(n);if(o.recurse&&o.value!==null)throw new Error("A deep zip function may not return both a value and recurse=true.");if(o.recurse)if(Mi(r)){const a=Array.isArray(r)?[]:{};t.add(r);for(const u in r){const c=n.map(d=>d[u]),h=Ib(c,e,t);a[u]=h}return t.delete(r),a}else throw new Error(`Can't recurse into non-iterable type: ${r}`);else return o.value}function Tb(n){return n===null?null:Mi(n[0])?{value:null,recurse:!0}:{value:n,recurse:!1}}async function Nb(n,e){const t=new Map;Ul(n,e,t);for(const o of Array.from(t.keys())){const a=t.get(o);if(nd(a)){const u=await a;t.set(o,u)}}return Ul(n,e,t)}function Mi(n){let e=!1;if(Ke().get("IS_BROWSER"))e=n instanceof TextDecoder;else{const{StringDecoder:t}=require("string_decoder");e=n instanceof t}return n!=null&&!ArrayBuffer.isView(n)&&(Array.isArray(n)||typeof n=="object"&&!(n instanceof ot)&&!(n instanceof Promise)&&!e)}function VD(n){return n==null||GD(n)||Array.isArray(n)||typeof n=="object"&&n instanceof ot||Xn(n)}function GD(n){return n===null||typeof n!="object"&&typeof n!="function"}function qD(n){return jD(n,HD)}function HD(n){return n instanceof ot?{value:n.clone(),recurse:!1}:Mi(n)?{value:null,recurse:!0}:{value:n,recurse:!1}}class Cb{constructor(e){if(this.capacity=e,this.begin=0,this.end=0,e==null)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(e<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(e),this.doubledCapacity=2*e}wrap(e){for(;e<0;)e+=this.doubledCapacity;return e%this.doubledCapacity}get(e){if(e<0)throw new RangeError("Can't get item at a negative index.");return this.data[e%this.capacity]}set(e,t){if(e<0)throw new RangeError("Can't set item at a negative index.");this.data[e%this.capacity]=t}length(){let e=this.end-this.begin;return e<0&&(e=this.doubledCapacity+e),e}isFull(){return this.length()===this.capacity}isEmpty(){return this.length()===0}push(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,e),this.end=this.wrap(this.end+1)}pushAll(e){for(const t of e)this.push(t)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);const e=this.get(this.end);return this.set(this.end,void 0),e}unshift(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,e)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const e=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),e}shuffleExcise(e){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const t=this.wrap(this.begin+e),r=this.get(t);return this.set(t,this.pop()),r}}class lu extends Cb{constructor(){super(lu.INITIAL_CAPACITY)}isFull(){return!1}push(e){super.isFull()&&this.expand(),super.push(e)}unshift(e){super.isFull()&&this.expand(),super.unshift(e)}expand(){const e=this.capacity*2,t=new Array(e),r=this.length();for(let o=0;o<r;o++)t[o]=this.get(this.wrap(this.begin+o));this.data=t,this.capacity=e,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=r}}lu.INITIAL_CAPACITY=32;function Db(n){return new YD(n)}function KD(n){return new ZD(n)}function JD(n,e){return new zb(n,e)}function XD(n,e=Yr.FAIL){return new lz(n,e)}class rn{async toArray(){const e=[];let t=await this.next();for(;!t.done;)e.push(t.value),t=await this.next();return e}async toArrayForTest(){const e=this.prefetch(100),t=[];let r=await e.next();for(;!r.done;)t.push(r.value),r=await e.next();return t}async resolveFully(){let e=await this.next();for(;!e.done;)e=await this.next()}async resolveWhile(e){let t=await this.next(),r=e(t.value);for(;!t.done&&r;)t=await this.next(),r=e(t.value)}handleErrors(e){return new iz(this,e)}filter(e){return new rz(this,e)}map(e){return new sz(this,e)}mapAsync(e){return new Dv(this,e)}serialMapAsync(e){return new Dv(this,e).serial()}flatmap(e){return new az(this,e)}async forEachAsync(e){return this.map(e).resolveFully()}async serialForEach(e){return this.serialMapAsync(e).resolveWhile(t=>t===!0)}rowMajorBatch(e,t=!0){return new nz(this,e,t)}columnMajorBatch(e,t=!0,r=Tb){return this.rowMajorBatch(e,t).map(a=>WD(a,r))}concatenate(e,t){return new zb(Db([this,e]),t)}take(e){return e<0||e==null?this:new tz(this,e)}skip(e){return e<0||e==null?this:new ez(this,e)}prefetch(e){return new $b(this,e)}shuffle(e,t){return new uz(this,e,t)}serial(){return new QD(this)}}class YD extends rn{constructor(e){super(),this.items=e,this.trav=0}summary(){return`Array of ${this.items.length} items`}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};const e=this.items[this.trav];return this.trav++,{value:qD(e),done:!1}}}class ZD extends rn{constructor(e){super(),this.nextFn=e}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(e){throw e.message=`Error thrown while iterating through a dataset: ${e.message}`,e}}}class QD extends rn{constructor(e){super(),this.upstream=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){return this.upstream.next()}}class ez extends rn{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){const e=await this.upstream.next();if(e.done)return e;Me(e.value)}return this.upstream.next()}}class tz extends rn{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0}summary(){return`${this.upstream.summary()} -> Take`}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}}class nz extends rn{constructor(e,t,r=!0){super(),this.upstream=e,this.batchSize=t,this.enableSmallLastBatch=r,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){const e=[];for(;e.length<this.batchSize;){const t=await this.upstream.next();if(t.done)return this.enableSmallLastBatch&&e.length>0?{value:e,done:!1}:{value:null,done:!0};e.push(t.value)}return{value:e,done:!1}}}class rz extends rn{constructor(e,t){super(),this.upstream=e,this.predicate=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;){const e=await this.upstream.next();if(e.done||this.predicate(e.value))return e;Me(e.value)}}}class sz extends rn{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Map`}async next(){const e=await this.upstream.next();if(e.done)return{value:null,done:!0};const t=ts(e.value),r=this.transform(e.value),o=ts(r);for(const a of t)ld(a,o)||a.dispose();return{value:r,done:!1}}}class iz extends rn{constructor(e,t){super(),this.upstream=e,this.handler=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(e){if(!this.handler(e))return{value:null,done:!0}}}}class Dv extends rn{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> AsyncMap`}async next(){const e=await this.upstream.next();if(e.done)return{value:null,done:!0};const t=ts(e.value),r=await this.transform(e.value),o=ts(r);for(const a of t)ld(a,o)||a.dispose();return{value:r,done:!1}}}class oz extends rn{constructor(){super(),this.outputQueue=new lu,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.outputQueue.length()===0;)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}}class az extends oz{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Flatmap`}async pump(){const e=await this.upstream.next();if(e.done)return!1;const t=ts(e.value),r=this.transform(e.value),o=ts(r);this.outputQueue.pushAll(r);for(const a of t)ld(a,o)||a.dispose();return!0}}class zb extends rn{constructor(e,t){super(),this.baseErrorHandler=t,this.lastRead=null,this.iterator=null,this.moreIterators=e}summary(){return"TODO: fill in upstream of chained summaries -> Chained"}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(e){if(await e,this.iterator==null){const r=await this.moreIterators.next();if(r.done)return{value:null,done:!0};this.iterator=r.value,this.baseErrorHandler!=null&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}const t=await this.iterator.next();return t.done?(this.iterator=null,this.readFromChain(e)):t}}var Yr;(function(n){n[n.FAIL=0]="FAIL",n[n.SHORTEST=1]="SHORTEST",n[n.LONGEST=2]="LONGEST"})(Yr||(Yr={}));class lz extends rn{constructor(e,t=Yr.FAIL){super(),this.iterators=e,this.mismatchMode=t,this.count=0,this.currentPromise=null}summary(){return"{TODO: fill in upstream of zip summaries} -> Zip"}async nextState(e){await e;let t=0,r=0;function o(u){return u instanceof rn?{value:u.next().then(h=>(t++,h.done&&r++,h.value)),recurse:!1}:{value:null,recurse:!0}}const a=await Nb(this.iterators,o);if(t===r)return{value:null,done:!0};if(r>0)switch(this.mismatchMode){case Yr.FAIL:throw new Error(`Zipped streams should have the same length. Mismatched at element ${this.count}.`);case Yr.SHORTEST:return{value:null,done:!0};case Yr.LONGEST:}return this.count++,{value:a,done:!1}}async next(){return this.currentPromise=this.nextState(this.currentPromise),this.currentPromise}}class $b extends rn{constructor(e,t){super(),this.upstream=e,this.bufferSize=t,this.buffer=new Cb(t)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){const e=this.upstream.next();this.buffer.push(e)}}next(){return this.refill(),this.buffer.shift()}}class uz extends $b{constructor(e,t,r){super(e,t),this.upstream=e,this.windowSize=t,this.upstreamExhausted=!1,this.random=su.alea(r||zn().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}randomInt(e){return Math.floor(this.random()*e)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){const e=this.chooseIndex(),t=await this.buffer.shuffleExcise(e);if(t.done)this.upstreamExhausted=!0;else return this.refill(),t}return{value:null,done:!0}}}let Md=class{constructor(){this.size=null}batch(e,t=!0){const r=this;E(e>0,()=>`batchSize needs to be positive, but it is
      ${e}`);let o;return this.size===1/0||this.size==null?o=this.size:t?o=Math.ceil(this.size/e):o=Math.floor(this.size/e),Nn(async()=>(await r.iterator()).columnMajorBatch(e,t,cz),o)}concatenate(e){const t=this;let r;return this.size===1/0||e.size===1/0?r=1/0:this.size!=null&&e.size!=null?r=this.size+e.size:r=null,Nn(async()=>(await t.iterator()).concatenate(await e.iterator()),r)}filter(e){const t=this;let r;return this.size===1/0?r=1/0:r=null,Nn(async()=>(await t.iterator()).filter(o=>V(()=>e(o))),r)}async forEachAsync(e){return(await this.iterator()).forEachAsync(e)}map(e){const t=this;return Nn(async()=>(await t.iterator()).map(r=>V(()=>e(r))),this.size)}mapAsync(e){const t=this;return Nn(async()=>(await t.iterator()).mapAsync(e),this.size)}prefetch(e){if(e==null)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");const t=this;return Nn(async()=>(await t.iterator()).prefetch(e),this.size)}repeat(e){const t=this;let r;return this.size!=null&&e>0?r=this.size*e:e===0?r=0:this.size!=null&&(e===void 0||e<0)?r=1/0:r=null,Nn(async()=>{const o=KD(async()=>({value:await t.iterator(),done:!1}));return JD(o.take(e))},r)}skip(e){const t=this;let r;return this.size!=null&&e>=0&&this.size>=e?r=this.size-e:this.size!=null&&(this.size<e||e===void 0||e<0)?r=0:r=null,Nn(async()=>(await t.iterator()).skip(e),r)}shuffle(e,t,r=!0){if(e==null||e<0)throw this.size==null?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);const o=this,a=su.alea(t||zn().toString());return Nn(async()=>{let u=a.int32();return r&&(u+=a.int32()),(await o.iterator()).shuffle(e,u.toString())},this.size)}take(e){const t=this;let r;return this.size!=null&&this.size>e?r=e:this.size!=null&&this.size<=e?r=this.size:r=null,Nn(async()=>(await t.iterator()).take(e),r)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}};Md.MAX_BUFFER_SIZE=1e4;function Nn(n,e=null){return new class extends Md{constructor(){super(...arguments),this.size=e}async iterator(){return n()}}}function pl(n){return Nn(async()=>Db(n),n.length)}function zv(n){if(!Mi(n))throw new Error("The argument to zip() must be an object or array.");let e;if(Array.isArray(n))for(let t=0;t<n.length;t++)e=e==null?n[t].size:Math.min(e,n[t].size);else if(n instanceof Object)for(const t in n)e=e==null?n[t].size:Math.min(e,n[t].size);return Nn(async()=>{const t=await Nb(n,r=>{if(r instanceof Md)return{value:r.iterator(),recurse:!1};if(Mi(r))return{value:null,recurse:!0};throw new Error("Leaves of the structure passed to zip() must be Datasets, not primitives.")});return XD(t,Yr.SHORTEST)},e)}function cz(n){if(n===null)return null;const e=n[0];return VD(e)?{value:hz(n),recurse:!1}:{value:null,recurse:!0}}function hz(n){if(n.length===0)throw new Error("Can't make a batch of zero elements.");return n[0]instanceof ot?ss(n):xi(n)}class ur extends Error{constructor(e){super(e),Object.setPrototypeOf(this,ur.prototype)}}class $n extends Error{constructor(e){super(e),Object.setPrototypeOf(this,$n.prototype)}}class _ extends Error{constructor(e){super(e),Object.setPrototypeOf(this,_.prototype)}}class Oe extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Oe.prototype)}}class Rd extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Rd.prototype)}}class Mb{constructor(e){this.maxEntries=e||100,this.cache=new Map}get(e){let t;return this.cache.has(e)&&(t=this.cache.get(e),this.cache.delete(e),this.cache.set(e,t)),t}put(e,t){if(this.cache.has(e))this.cache.delete(e);else if(this.cache.size>=this.maxEntries){const r=this.cache.keys().next().value;this.cache.delete(r)}this.cache.set(e,t)}getMaxEntries(){return this.maxEntries}setMaxEntries(e){if(e<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${e}.`);if(this.maxEntries>e)for(let t=0;t<this.maxEntries-e;t++){const r=this.cache.keys().next().value;this.cache.delete(r)}this.maxEntries=e}}function Os(n,e){if(Array.isArray(n)){let t=[];for(let r=0;r<e;r++)t=t.concat(n);return t}else{const t=new Array(e);return t.fill(n),t}}function cr(n,e){if(!n)throw new Rd(e)}function $v(n,e){let t=0;for(const r of n)r===e&&t++;return t}function en(n){return n.length===1?n[0]:n}function nt(n){return Array.isArray(n)?n:[n]}function Nr(n){const t=n.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return t[0]!=="_"?t:"private"+t}function Cs(n){return n.length<=1||n.indexOf("_")===-1?n:n.replace(/[_]+(\w|$)/g,(e,t)=>t.toUpperCase())}let Tn={};function _d(n){if(n==null)return null;const e={};return e.className=n.getClassName(),e.config=n.getConfig(),e}function Lf(n){if(!(n==null||typeof n!="object"))if(Array.isArray(n))n.forEach(e=>Lf(e));else{const e=Object.keys(n);for(const t of e){const r=n[t];r!=null&&typeof r=="object"&&(!Array.isArray(r)&&r.type==="ndarray"&&typeof r.value=="number"?n[t]=r.value:Lf(r))}}}function Ho(n,e={},t={},r="object",o=!1){if(typeof n=="string"){const a=n;let u;if(a in t)u=t[a];else if(a in Tn)u=Tn[a];else if(u=e[a],u==null)throw new _(`Unknown ${r}: ${n}. This may be due to one of the following reasons:
1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return u}else{const a=n;if(a.className==null||a.config==null)throw new _(`${r}: Improper config format: ${JSON.stringify(a)}.
'className' and 'config' must set.`);const u=a.className;let c,h;if(u in t?[c,h]=t[u]:u in Tn?[c,h]=Tn.className:u in e&&([c,h]=e[u]),c==null)throw new _(`Unknown ${r}: ${u}. This may be due to one of the following reasons:
1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(h!=null){const d={};for(const w of Object.keys(Tn))d[w]=Tn[w];for(const w of Object.keys(t))d[w]=t[w];const m=a.config;m.customObjects=d;const g=Object.assign({},Tn);for(const w of Object.keys(t))Tn[w]=t[w];Lf(a.config);const v=h(c,a.config,t,o);return Tn=Object.assign({},g),v}else{const d=Object.assign({},Tn);for(const g of Object.keys(t))Tn[g]=t[g];const m=new c(a.config);return Tn=Object.assign({},d),m}}}function fz(n,e){return n<e?-1:n>e?1:0}function ml(n,e){return-1*fz(n,e)}function Qr(n){if(n==null)return n;const e=[];for(const t of n)e.indexOf(t)===-1&&e.push(t);return e}function dz(n){if(n==null)throw new _(`Invalid value in obj: ${JSON.stringify(n)}`);for(const e in n)if(n.hasOwnProperty(e))return!1;return!0}function js(n,e,t){if(t!=null&&n.indexOf(t)<0)throw new _(`${t} is not a valid ${e}.  Valid values are ${n} or null/undefined.`)}function Fd(n,e,t=0,r=1/0){return cr(t>=0),cr(r>=t),Array.isArray(n)&&n.length>=t&&n.length<=r&&n.every(o=>typeof o===e)}function Mt(n,e){Array.isArray(n)?(E(n.length>0,()=>`${e} is unexpectedly an empty array.`),n.forEach((t,r)=>Mt(t,`element ${r+1} of ${e}`))):E(Number.isInteger(n)&&n>0,()=>`Expected ${e} to be a positive integer, but got ${Rb(n)}.`)}function Rb(n){return n===null?"null":Array.isArray(n)?"["+n.map(e=>Rb(e)).join(",")+"]":typeof n=="string"?`"${n}"`:`${n}`}function pz(n,e,t){let r=t!=null?t():zn(),o;return(...u)=>{const c=t!=null?t():zn();return c-r<e||(r=c,o=n(...u)),o}}function _b(n){return n==="relu"?"relu":n==="linear"?"linear":n==="elu"?"elu":null}let mz=0;function Fb(){return mz++}const gl={};function uu(n=""){return n in gl||(gl[n]=0),gl[n]+=1,n+gl[n].toString()}const gz=["channelsFirst","channelsLast"],yz=["nearest","bilinear"],vz=["valid","same","causal"],wz=["max","avg"],bz=["sum","mul","concat","ave"];const yi=new Map;function vt(n){js(gz,"DataFormat",n)}function kz(n){js(yz,"InterpolationFormat",n)}function bn(n){js(vz,"PaddingMode",n)}function Lb(n){js(wz,"PoolMode",n)}const Mo=[],Mv="/";function $s(n,e){Mo.push(n);try{const t=e();return Mo.pop(),t}catch(t){throw Mo.pop(),t}}function Sz(){return Mo.length===0?"":Mo.join(Mv)+Mv}function Ob(n){if(!Bb(n))throw new Error("Not a valid tensor name: '"+n+"'");return Sz()+n}function Pb(n){if(!Bb(n))throw new Error("Not a valid tensor name: '"+n+"'");yi.has(n)||yi.set(n,0);const e=yi.get(n);if(yi.set(n,yi.get(n)+1),e>0){const t=`${n}_${e}`;return yi.set(t,1),t}else return n}const xz=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function Bb(n){return!!n.match(xz)}function Ez(n){return n===parseInt(n.toString(),10)}function es(n,e,t){e==null&&(e=0),t==null&&(t=n.length);let r=1;for(let o=e;o<t;++o)r*=n[o];return r}function Ri(n){if(n.length===0)return Number.NaN;let e=Number.POSITIVE_INFINITY;for(let t=0;t<n.length;t++){const r=n[t];r<e&&(e=r)}return e}function is(n){if(n.length===0)return Number.NaN;let e=Number.NEGATIVE_INFINITY;for(let t=0;t<n.length;t++){const r=n[t];r>e&&(e=r)}return e}function Zn(n,e){if(e<n)throw new _(`end (${e}) < begin (${n}) is forbidden.`);const t=[];for(let r=n;r<e;++r)t.push(r);return t}let mf;function Et(){return mf==null&&(mf=fd().epsilon()),mf}function Qn(){return"channelsLast"}function Ko(n,e){return Se(n,e)}function Jo(n,e=-1){const t=n.shape.slice();return e<0&&(e=t.length+e+1),t.splice(e,0,1),J(n,t)}function Az(n,e){return V(()=>{if(n.shape.length!==2)throw new _(`repeat() expects a rank-2 tensor, but received a rank-${n.shape.length} tensor.`);const t=Jo(n,1);return Of(t,[1,e,1])})}function Iz(n){const e=[es(n.shape)];return J(n,e)}function Tz(n){if(n.rank<=1)throw new _(`batchFlatten requires a minimum rank of 2. Got rank: ${n.rank}.`);const e=[n.shape[0],es(n.shape,1)];return J(n,e)}function Ms(n,e,t){return V(()=>{switch(n.rank){case 1:return wd(n,e,t);case 2:return cb(n,[e,0],[t,n.shape[1]]);case 3:return bd(n,[e,0,0],[t,n.shape[1],n.shape[2]]);case 4:return Bl(n,[e,0,0,0],[t,n.shape[1],n.shape[2],n.shape[3]]);case 5:return it(n,[e,0,0,0,0],[t,n.shape[1],n.shape[2],n.shape[3],n.shape[4]]);case 6:return it(n,[e,0,0,0,0,0],[t,n.shape[1],n.shape[2],n.shape[3],n.shape[4],n.shape[5]]);default:throw new _(`sliceAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}})}function gf(n,e,t){return V(()=>{switch(n.rank){case 1:return wd(n,e,t);case 2:return cb(n,[0,e],[n.shape[0],t]);case 3:return bd(n,[0,0,e],[n.shape[0],n.shape[1],t]);case 4:return Bl(n,[0,0,0,e],[n.shape[0],n.shape[1],n.shape[2],t]);default:throw new _(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function yl(n,e,t,r){return V(()=>{switch(n.rank){case 1:return wd(n,e,t);case 2:switch(r){case 1:return Ms(n,e,t);case 2:return gf(n,e,t);default:throw new _(`The axis is not within the rank of the tensor ${r}`)}case 3:switch(r){case 1:return Ms(n,e,t);case 2:return bd(n,[0,e,0],[n.shape[0],t,n.shape[2]]);case 3:return gf(n,e,t);default:throw new _(`The axis is not within the rank of the tensor ${r}`)}case 4:switch(r){case 1:return Ms(n,e,t);case 2:return Bl(n,[0,e,0,0],[n.shape[0],t,n.shape[2],n.shape[3]]);case 3:return Bl(n,[0,0,e,0],[n.shape[0],n.shape[1],t,n.shape[3]]);case 4:return gf(n,e,t);default:throw new _(`The axis is not within the rank of the tensor ${r}`)}default:throw new _(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function Ld(n,e=-1){let t;return e<0&&(t=n[0].rank,t!==0?e=t:e=0),e===n[0].rank&&(e=-1),Kn(n,e)}function Rv(n,e){switch(n.rank){case 1:return MI([n,e]);case 2:return _I([n,e],0);case 3:return LI([n,e],0);case 4:return PI([n,e],0);default:throw new _(`concatAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}}function Of(n,e){if(Array.isArray(e)||(e=[e]),n.rank!==e.length)throw new _(`The length of input n (${e.length}) does not match the number of dimensions in input x (${n.rank})`);return fr(n,e)}function cu(n,e=0,t=1,r,o){return kN(n,e,t,r,o)}function mr(n,e,t,r){if(n.rank<2||e.rank<2)throw new Oe(`dot requires both inputs to be rank >= 2 but got x shape = ${n.shape} and y shape = ${e.shape}`);if(e.rank>=3){const o=n.shape.slice(-1)[0],a=e.shape.slice(-2)[0];if(o!==a)throw new Oe(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${n.shape} and  y shape = ${e.shape}`)}if(n.rank===2&&e.rank===2)return $y({a:n,b:e,transposeA:!1,transposeB:!1,bias:r?Pf(n.rank,r,Qn()):null,activation:t});{const o=n.shape.slice(),a=o.pop();n=J(n,[-1,a]);const u=e.shape.slice(),c=u.pop(),h=u.pop(),d=[...u,c],m=Array.from({length:e.rank},(k,S)=>S===0?e.rank-2:S<=e.rank-2?S-1:S);e=J(We(e,m),[h,-1]);const g=[...o,...d];return J($y({a:n,b:e,transposeA:!1,transposeB:!1,bias:r?Pf(n.rank,r,Qn()):null,activation:t}),g)}}function Ub(n,e,t){return V(()=>(Array.isArray(e)?e=jt(e,"int32"):e=Se(e,"int32"),Si(n,e,t)))}function Xo(n){return P(n,n)}function Pf(n,e,t){const r=e.shape;if(e.rank!==1&&e.rank!==n)throw new _(`Unexpected bias dimensions: ${e.rank}; expected it to be 1 or ${n}`);if(n===5){if(t==="channelsFirst")return r.length===1?J(e,[1,r[0],1,1,1]):J(e,[1,r[3],r[0],r[1],r[2]]);if(t==="channelsLast")return r.length===1?J(e,[1,1,1,1,r[0]]):J(e,[1].concat(r))}else if(n===4){if(t==="channelsFirst")return r.length===1?J(e,[1,r[0],1,1]):J(e,[1,r[2],r[0],r[1]]);if(t==="channelsLast")return r.length===1?J(e,[1,1,1,r[0]]):J(e,[1].concat(r))}else if(n===3){if(t==="channelsFirst")return r.length===1?J(e,[1,r[0],1]):J(e,[1,r[1],r[0]]);if(t==="channelsLast")return r.length===1?J(e,[1,1,r[0]]):J(e,[1].concat(r))}else if(n<3)return e;throw new _(`Unsupported input rank by biasAdd: ${e.rank}`)}function tr(n,e,t){return V(()=>(t==null&&(t=Qn()),vt(t),le(n,Pf(n.rank,e,t))))}function Nz(n,e=1){if(e!==1)throw new Oe(`Support for alpha values other than 1 (${e}) is not implemented yet.`);return md(n)}function Cz(n){return V(()=>$e(n,le(Zt(n),1)))}function jb(n,e,t,r){return V(()=>nC(n,e,t,r))}function Dz(n){return V(()=>{const e=le(.5,P(.2,n));return Mn(e,0,1)})}function Yo(n,e,t=!1){return t?n():e()}const zz=["fanIn","fanOut","fanAvg"],$z=["normal","uniform","truncatedNormal"];function Mz(n){js(zz,"FanMode",n)}function Rz(n){js($z,"Distribution",n)}class _n extends Oi{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class Wb extends _n{apply(e,t){return Ot(e,t)}}Wb.className="Zeros";re(Wb);class Od extends _n{apply(e,t){return Us(e,t)}}Od.className="Ones";re(Od);class Vb extends _n{constructor(e){if(super(),typeof e!="object")throw new _(`Expected argument of type ConstantConfig but got ${e}`);if(e.value===void 0)throw new _(`config must have value set but got ${e}`);this.value=e.value}apply(e,t){return V(()=>P(Je(this.value),Us(e,t)))}getConfig(){return{value:this.value}}}Vb.className="Constant";re(Vb);class Gb extends _n{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,t){return iu(e,this.minval,this.maxval,t)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}Gb.className="RandomUniform";re(Gb);class qb extends _n{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32",t!=="float32"&&t!=="int32")throw new Oe(`randomNormal does not support dType ${t}.`);return cu(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}qb.className="RandomNormal";re(qb);class Hb extends _n{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32",t!=="float32"&&t!=="int32")throw new Oe(`truncatedNormal does not support dType ${t}.`);return fb(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}Hb.className="TruncatedNormal";re(Hb);class Kb extends _n{constructor(e){super(),this.gain=e.gain!=null?e.gain:1}apply(e,t){return V(()=>{if(e.length!==2||e[0]!==e[1])throw new _("Identity matrix initializer can only be used for 2D square matrices.");return P(this.gain,sb(e[0]))})}getConfig(){return{gain:this.gain}}}Kb.className="Identity";re(Kb);function _z(n,e="channelsLast"){let t,r;if(vt(e),n.length===2)t=n[0],r=n[1];else if([3,4,5].indexOf(n.length)!==-1){if(e==="channelsFirst"){const o=es(n,2);t=n[1]*o,r=n[0]*o}else if(e==="channelsLast"){const o=es(n,0,n.length-2);t=n[n.length-2]*o,r=n[n.length-1]*o}}else{const o=es(n);t=Math.sqrt(o),r=Math.sqrt(o)}return[t,r]}class dn extends _n{constructor(e){if(super(),e.scale<0)throw new _(`scale must be a positive float. Got: ${e.scale}`);this.scale=e.scale==null?1:e.scale,this.mode=e.mode==null?"fanIn":e.mode,Mz(this.mode),this.distribution=e.distribution==null?"normal":e.distribution,Rz(this.distribution),this.seed=e.seed}apply(e,t){const r=_z(e),o=r[0],a=r[1];let u=this.scale;if(this.mode==="fanIn"?u/=Math.max(1,o):this.mode==="fanOut"?u/=Math.max(1,a):u/=Math.max(1,(o+a)/2),this.distribution==="normal"){const c=Math.sqrt(u);if(t=t||"float32",t!=="float32"&&t!=="int32")throw new Oe(`${this.getClassName()} does not support dType ${t}.`);return fb(e,0,c,t,this.seed)}else{const c=Math.sqrt(3*u);return iu(e,-c,c,t)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}dn.className="VarianceScaling";re(dn);class Pd extends dn{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return dn.className}}Pd.className="GlorotUniform";re(Pd);class Bd extends dn{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return dn.className}}Bd.className="GlorotNormal";re(Bd);class Ud extends dn{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return dn.className}}Ud.className="HeNormal";re(Ud);class jd extends dn{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return dn.className}}jd.className="HeUniform";re(jd);class Wd extends dn{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return dn.className}}Wd.className="LeCunNormal";re(Wd);class Vd extends dn{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return dn.className}}Vd.className="LeCunNormal";re(Vd);class Jb extends _n{constructor(e){if(super(),this.DEFAULT_GAIN=1,this.gain=e.gain==null?this.DEFAULT_GAIN:e.gain,this.seed=e.seed,this.seed!=null)throw new Oe("Random seed is not implemented for Orthogonal Initializer yet.")}apply(e,t){return V(()=>{if(e.length<2)throw new Oe("Shape must be at least 2D.");e[0]*e[1]>2e3&&console.warn(`Orthogonal initializer is being called on a matrix with more than 2000 (${e[0]*e[1]}) elements: Slowness may result.`);const r=e[0]>e[1]?[e[1],e[0]]:e,o=cu(r,0,1,"float32");let a=tD.gramSchmidt(o);return e[0]>e[1]&&(a=We(a)),P(this.gain,a)})}getConfig(){return{gain:this.gain,seed:this.seed}}}Jb.className="Orthogonal";re(Jb);const _v={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function Fv(n,e={}){return Ho(n,Dn.getMap().classNameMap,e,"initializer")}function dt(n){return _d(n)}function lt(n){if(typeof n=="string"){const e=n in _v?_v[n]:n;if(e==="GlorotNormal")return new Bd;if(e==="GlorotUniform")return new Pd;if(e==="HeNormal")return new Ud;if(e==="HeUniform")return new jd;if(e==="LeCunNormal")return new Wd;if(e==="LeCunUniform")return new Vd;{const t={};return t.className=e,t.config={},Fv(t)}}else return n instanceof _n?n:Fv(n)}function Bf(n){return Array.isArray(n)&&Array.isArray(n[0])}function jl(n){return n.length===0?[]:Array.isArray(n[0])?n:[n]}function Fe(n){let e;if(Array.isArray(n)){if(n.length!==1)throw new _(`Expected Tensor length to be 1; got ${n.length}`);e=n[0]}else e=n;return e}function Ye(n){if(Array.isArray(n)&&Array.isArray(n[0])){if(n.length===1)return n=n,n[0];throw new _(`Expected exactly 1 Shape; got ${n.length}`)}else return n}function Wl(n){let e=0;for(const t of n)t.shape.length===0?e+=1:e+=t.shape.reduce((r,o)=>r*o);return e}const Lv="Variable";class Fz{constructor(e,t="float32",r=Lv,o=!0,a=null){this.dtype=t??"float32",this.shape=e.shape,this.id=Fb(),r=r??Lv,this.originalName=Ob(r),this.name=Pb(this.originalName),this.trainable_=o,this.constraint=a,this.val=QN(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),Lz(this.val,e),this.val.id!==e.id&&(this.val.assign(e),this.constraint!=null&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}}function Lz(n,e){if(n.shape.toString()!==e.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(n.shape)+" vs. "+JSON.stringify(e.shape))}function Uf(n){return n.map(e=>e.read())}function Gd(n){n.forEach(e=>{e[0].write(e[1])})}class At{constructor(e){this.dtype=e.dtype,this.shape=e.shape,e.shape!=null?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}}class dr{constructor(e,t,r,o,a,u,c){this.dtype=e,this.shape=t,this.sourceLayer=r,this.inputs=o,this.callArgs=a,this.outputTensorIndex=c,this.id=Fb(),u!=null&&(this.originalName=Ob(u),this.name=Pb(this.originalName)),this.rank=t.length}}let Oz=0;class hu{constructor(e,t){this.callArgs=t,this.id=Oz++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(const r of e.inboundLayers)r?.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){const e=[];for(const t of this.inboundLayers)t!=null?e.push(t.name):e.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let Pz=0;class Ue extends Oi{constructor(e={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=Pz++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let t=e.name;if(!t){const r=this.getClassName();t=Nr(r)+"_"+uu(r)}if(this.name=t,this.trainable_=e.trainable==null?!0:e.trainable,e.inputShape!=null||e.batchInputShape!=null){let r;if(e.batchInputShape!=null)r=e.batchInputShape;else if(e.inputShape!=null){let a=null;e.batchSize!=null&&(a=e.batchSize),r=[a].concat(e.inputShape)}this.batchInputShape=r;let o=e.dtype;o==null&&(o=e.inputDType),o==null&&(o="float32"),this.dtype=o}e.weights!=null?this.initialWeights=e.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,t){return e.name+"_ib-"+t.toString()}getNodeAtIndex(e,t){if(this.inboundNodes.length===0)throw new $n(`The layer has never been called and thus has no defined ${t}.`);if(this.inboundNodes.length<=e)throw new _(`Asked to get ${t} at node ${e}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[e]}getInputAt(e){return en(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return en(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new ur(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(this.inboundNodes.length===0)throw new ur(`Layer ${this.name} is not connected, no input to return.`);return en(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(this.inboundNodes.length===0)throw new ur(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new ur(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return en(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(e=>e())}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach(t=>t.trainable=e),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(e=>e.trainable):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(e=>!e.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){if(e=nt(e),this.inputSpec==null||this.inputSpec.length===0)return;const t=nt(this.inputSpec);if(e.length!==t.length)throw new _(`Layer ${this.name} expects ${t.length} inputs, but it received ${e.length} input tensors. Input received: ${e}`);for(let r=0;r<e.length;r++){const o=e[r],a=t[r];if(a==null)continue;const u=o.rank;if(a.ndim!=null&&u!==a.ndim)throw new _(`Input ${r} is incompatible with layer ${this.name}: expected ndim=${a.ndim}, found ndim=${u}`);if(a.maxNDim!=null&&u>a.maxNDim)throw new _(`Input ${r} is incompatible with layer ${this.name}: expected max_ndim=${a.maxNDim}, found ndim=${u}`);if(a.minNDim!=null&&u<a.minNDim)throw new _(`Input ${r} is incompatible with layer ${this.name}: expected min_ndim=${a.minNDim}, found ndim=${u}.`);if(a.dtype!=null&&o.dtype!==a.dtype)throw new _(`Input ${r} is incompatible with layer ${this.name} : expected dtype=${a.dtype}, found dtype=${o.dtype}.`);if(a.axes){const c=o.shape;for(const h in a.axes){const d=Number(h),m=a.axes[h],g=d>=0?c[d]:c[c.length+d];if(m!=null&&[m,null].indexOf(g)===-1)throw new _(`Input ${r} is incompatible with layer ${this.name}: expected axis ${d} of input shape to have value ${m} but got shape ${c}.`)}}if(a.shape!=null)for(let c=0;c<a.shape.length;++c){const h=a.shape[c],d=o.shape[c];if(h!=null&&d!=null&&h!==d)throw new _(`Input ${r} is incompatible with layer ${this.name}: expected shape=${a.shape}, found shape=${o.shape}.`)}}}call(e,t){return e}invokeCallHook(e,t){this._callHook!=null&&this._callHook(e,t)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,t){t=t||{},this.assertNotDisposed();const r=nt(e);let o=!0;for(const u of r)if(!(u instanceof dr)){o=!1;break}let a=!0;for(const u of r)if(u instanceof dr){a=!1;break}if(o===a)throw new _("Arguments to apply() must be all SymbolicTensors or all Tensors");return $s(this.name,()=>{if(!this.built){this.assertInputCompatibility(e);const u=[];for(const c of nt(e))u.push(c.shape);this.build(en(u)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),this._refCount===null&&a&&(this._refCount=1)}if(this.assertInputCompatibility(e),a){let u=this.call(e,t);const c=nt(u),h=[];for(let d of c)r.indexOf(d)!==-1&&(d=d.clone()),h.push(d);if(u=en(h),this.activityRegularizer!=null)throw new Oe("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return u}else{const u=Bz(e),c=this.computeOutputShape(u);let h;const d=Uz(e);if(this.warnOnIncompatibleInputShape(Array.isArray(e)?u[0]:u),c!=null&&c.length>0&&Array.isArray(c[0])?h=c.map((m,g)=>new dr(d,m,this,nt(e),t,this.name,g)):h=new dr(d,c,this,nt(e),t,this.name),this.addInboundNode(e,h,null,null,u,c,t),this._refCount++,this.activityRegularizer!=null)throw new Oe("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return h}})}warnOnIncompatibleInputShape(e){if(this.batchInputShape!=null)if(e.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(e)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let t=!1;this.batchInputShape.forEach((r,o)=>{r!=null&&e[o]!=null&&e[o]!==r&&(t=!0)}),t&&console.warn(`The shape of the input tensor (${JSON.stringify(e)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(this.inboundNodes==null||this.inboundNodes.length===0)throw new ur(`The layer ${this.name} has never been called and thus has no defined output shape.`);const e=[];for(const t of this.inboundNodes){const r=JSON.stringify(t.outputShapes);e.indexOf(r)===-1&&e.push(r)}if(e.length===1){const t=this.inboundNodes[0].outputShapes;return Array.isArray(t)&&Array.isArray(t[0])&&t.length===1?t[0]:t}else throw new ur(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new $n(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return Wl(this.weights)}build(e){this.built=!0}getWeights(e=!1){return Uf(e?this.trainableWeights:this.weights)}setWeights(e){V(()=>{const t=this.weights;if(t.length!==e.length)throw new _(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${e.length}, but the layer was expecting ${t.length} weights. Provided weights: ${e}...`);if(t.length===0)return;const r=[],o=Uf(t);for(let a=0;a<o.length;++a){const u=o[a],c=t[a],h=e[a];if(!nn(u.shape,h.shape))throw new _(`Layer weight shape ${u.shape} not compatible with provided weight shape ${h.shape}`);r.push([c,h])}Gd(r)})}addWeight(e,t,r,o,a,u,c,h){if(this._addedWeightNames.indexOf(e)!==-1)throw new _(`Duplicate weight name ${e} for layer ${this.name}`);this._addedWeightNames.push(e),r==null&&(r="float32"),this.fastWeightInitDuringBuild&&(o=h!=null?h():lt("zeros"));const d=o.apply(t,r),m=new Fz(d,r,e,u,c);return d.dispose(),a!=null&&this.addLoss(()=>a.apply(m.read())),u==null&&(u=!0),u?this._trainableWeights.push(m):this._nonTrainableWeights.push(m),m}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){e==null||Array.isArray(e)&&e.length===0||(e=nt(e),this._losses!==void 0&&this._losses!==null&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,t){if(!this.supportsMasking){if(t!=null)if(Array.isArray(t))t.forEach(r=>{if(r!=null)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)});else throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);return null}return t}addInboundNode(e,t,r,o,a,u,c=null){const h=nt(e);t=nt(t),r=nt(r),o=nt(o),a=jl(a),u=jl(u);const d=[],m=[],g=[];for(const v of h)d.push(v.sourceLayer),m.push(v.nodeIndex),g.push(v.tensorIndex);new hu({outboundLayer:this,inboundLayers:d,nodeIndices:m,tensorIndices:g,inputTensors:h,outputTensors:t,inputMasks:r,outputMasks:o,inputShapes:a,outputShapes:u},c);for(let v=0;v<t.length;v++)t[v].sourceLayer=this,t[v].nodeIndex=this.inboundNodes.length-1,t[v].tensorIndex=v}getConfig(){const e={name:this.name,trainable:this.trainable};return this.batchInputShape!=null&&(e.batchInputShape=this.batchInputShape),this.dtype!=null&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach(e=>e.dispose()),this.weights.length}assertNotDisposed(){if(this._refCount===0)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(this._refCount===null)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let e=0;return--this._refCount===0&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}}function Bz(n){n=nt(n);const e=[];for(const t of n)e.push(t.shape);return en(e)}function Uz(n){return"float32"}function Xb(n,e,t){if((e==null||t!=null&&t>0)&&(e=n.sourceLayer,t=n.nodeIndex),e.inboundNodes.length===0)return[n];{const r=e.inboundNodes[t];if(r.inboundLayers.length===0)return r.inputTensors;{const o=[];for(let a=0;a<r.inboundLayers.length;a++){const u=r.inputTensors[a],c=r.inboundLayers[a],h=r.nodeIndices[a],d=Xb(u,c,h);for(const m of d)o.indexOf(m)===-1&&o.push(m)}return o}}}class Zo extends Ue{constructor(e){if(super({dtype:e.dtype,name:e.name!=null?e.name:uu("input").toString()}),e.batchSize==null&&(e.batchSize=null),e.sparse==null&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,e.inputShape!=null&&e.batchInputShape!=null)throw new _("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let t=e.batchInputShape;if(t==null){if(e.inputShape==null)throw new _("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");t=[e.batchSize].concat(e.inputShape)}else if(e.batchSize!=null)throw new _("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const r=e.dtype||"float32";this.batchInputShape=t,this.dtype=r,this.inputSpec=[{shape:t}];const o=new dr(this.dtype,this.batchInputShape,this,[],{},this.name);o.nodeIndex=0,o.tensorIndex=0,new hu({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[o],outputTensors:[o],inputMasks:[null],outputMasks:[null],inputShapes:[t],outputShapes:[t]})}apply(e,t){throw new _(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}Zo.className="InputLayer";re(Zo);function jz(n){if(n.batchShape==null&&n.shape==null)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(n.batchShape!=null&&n.shape!=null)throw new _("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let e=n.batchShape;n.shape!=null&&e==null&&(e=[null].concat(n.shape));let t=n.dtype;return t==null&&(t="float32"),new Zo({batchInputShape:e,name:n.name,dtype:t,sparse:n.sparse}).inboundNodes[0].outputTensors[0]}function Wz(n,e){if(n.dtype==null||n.dtype===e.dtype)return e;try{return Se(e,n.dtype)}catch{throw new _(`The dtype of the feed (${e.dtype}) can not be cast to the dtype of the key '${n.name}' (${n.dtype}).`)}}class Zr{constructor(e){if(this.id2Value={},this.id2Mask={},this.name2Id={},e instanceof Zr)for(const t in e.id2Value)this.id2Value[t]=e.id2Value[t],t in e.id2Mask&&(this.id2Mask[t]=e.id2Mask[t]);else{if(e==null)return;for(const t of e)this.add(t.key,t.value)}}add(e,t,r){if(this.id2Value[e.id]==null)this.id2Value[e.id]=Wz(e,t),this.name2Id[e.name]=e.id,r!=null&&(this.id2Mask[e.id]=r);else throw new _(`Duplicate key: name=${e.name}, id=${e.id}`);return this}addFeed(e){this.add(e.key,e.value)}hasKey(e){return this.id2Value[e.id]!=null}names(){return Object.keys(this.name2Id)}getValue(e){if(e instanceof dr){if(this.id2Value[e.id]==null)throw new _(`Nonexistent key: ${e.name}`);return this.id2Value[e.id]}else{const t=this.name2Id[e];if(t==null)throw new _(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Value[t]}}getMask(e){if(e instanceof dr){if(this.id2Value[e.id]==null)throw new _(`Nonexistent key: ${e.name}`);return this.id2Mask[e.id]}else{const t=this.name2Id[e];if(t==null)throw new _(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Mask[t]}}disposeMasks(){this.id2Mask!=null&&Me(this.id2Mask)}}const Vl=new Mb,Gl=new Mb;function Vz(n){Vl?.setMaxEntries(n),Gl?.setMaxEntries(n)}function zo(n,e,t,r){const o=t==null?!1:t.training,a=Array.isArray(n),u=a?n:[n],c=u.map(k=>k.name),h=[],d=e.names();for(const k of c)d.indexOf(k)!==-1?h.push(e.getValue(k)):h.push(null);const m=c.join(",")+"|"+e.names().sort().join(",");let g=Vl.get(m),v;if(g==null){const k=Gz(u,e);g=k.sorted,v=k.recipientCounts,Vl.put(m,g),Gl.put(m,v)}v={},o||Object.assign(v,Gl.get(m));const w=new Zr(e);for(let k=0;k<g.length;++k){const S=g[k],x=S.sourceLayer;if(x instanceof Zo)continue;const T=[],z=[],R=[];let $=!1;for(const ne of S.inputs){const oe=w.getValue(ne),de=w.getMask(ne);T.push(oe),z.push(de),de!=null&&($=!0),o||(v[ne.name]--,v[ne.name]===0&&!e.hasKey(ne)&&c.indexOf(ne.name)===-1&&!oe.isDisposed&&ne.sourceLayer.stateful!==!0&&R.push(oe))}$&&(t=t||{},t.mask=z[0]);const B=nt(x.apply(T,t));let H=null;x.supportsMasking&&(H=x.computeMask(T,z));const Y=Hz(S),Z=Array.isArray(Y)?Y:[Y];for(let ne=0;ne<Z.length;++ne){w.hasKey(Z[ne])||w.add(Z[ne],B[ne],Array.isArray(H)?H[0]:H);const oe=c.indexOf(Z[ne].name);oe!==-1&&(h[oe]=B[ne])}o||Me(R)}return w.disposeMasks(),a?h:h[0]}function Gz(n,e){E(n!=null&&n.length>0,()=>"Expected at least one fetch, got none");let t=[],r={};if(n.length===1){const o=Ov(n[0],e);t=o.sorted,r=o.recipientMap}else{const o=new Set;for(const a of n){const{sorted:u,recipientMap:c}=Ov(a,e);for(const h of u)o.has(h.name)||(t.push(h),o.add(h.name));for(const h in c)r[h]==null&&(r[h]=new Set),c[h].forEach(d=>r[h].add(d))}}return{sorted:t,recipientCounts:qz(r)}}function qz(n){const e={};for(const t in n)e[t]=n[t].size;return e}function Ov(n,e){const t=new Set,r=[],o={};for(const c of e.names())t.add(c);const a=[],u=[];for(a.push(n);a.length>0;){const c=a[a.length-1];if(t.has(c.name)){a.pop();continue}const h=u[u.length-1]===a.length-1;if(c.inputs.length===0||h)a.pop(),r.push(c),t.add(c.name),h&&u.pop();else{u.push(a.length-1);for(const d of c.inputs)o[d.name]==null&&(o[d.name]=new Set),o[d.name].add(c.name),!t.has(d.name)&&a.push(d)}}return{sorted:r,recipientMap:o}}function Hz(n){let e;if(n.sourceLayer.inboundNodes.length===1)e=n.sourceLayer.output;else{let t=null;for(let r=0;r<n.sourceLayer.inboundNodes.length;++r)for(const o of n.sourceLayer.inboundNodes[r].outputTensors)if(o.id===n.id){t=r;break}e=n.sourceLayer.getOutputAt(t)}return e}const Kz=Ke();Kz.registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,Vz);const Yb={kernelName:bw,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>P(n,ou(Se(t,"float32"),-1))}}};const Jz={kernelName:bE,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const r=at(Se(t,"float32")),o=Kt(Re(Je(1),r));return Wt($e(n,o))}}}};const Xz={kernelName:kE,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const r=Kt(Re(at(Se(t,"float32")),1));return $e(n,r)}}}};const Yz={kernelName:sd,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,r]=e,o=gt(t.shape,r.shape);return{a:()=>{let c=n;const h=Rt(t.shape,o);return h.length>0&&(c=Ce(c,h)),J(c,t.shape)},b:()=>{let c=n;const h=Rt(r.shape,o);return h.length>0&&(c=Ce(c,h)),J(c,r.shape)}}}};const Zz={kernelName:SE,saveAllInputs:!0,gradFunc:(n,e)=>{const t={};return e.forEach((r,o)=>{t[o]=()=>n.clone()}),t}};const Qz={kernelName:kw,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>He(t)}}};const e$={kernelName:AE,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>He(t)}}};const t$={kernelName:IE,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>$e(n,Kt(Re(Je(1),at(Se(t,"float32")))))}}};const n$={kernelName:TE,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const r=Kt(le(Je(1),at(Se(t,"float32"))));return $e(n,r)}}}};const r$={kernelName:DE,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,r]=e,o=gt(t.shape,r.shape);return{a:()=>{const c=le(at(t),at(r));let h=P(n,$e(r,c));const d=Rt(t.shape,o);return d.length>0&&(h=Ce(h,d)),J(h,t.shape)},b:()=>{const c=le(at(t),at(r));let h=Wt(P(n,$e(t,c)));const d=Rt(r.shape,o);return d.length>0&&(h=Ce(h,d)),J(h,r.shape)}}}};const s$={kernelName:NE,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>$e(n,le(at(Se(t,"float32")),1))}}};const i$={kernelName:CE,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>$e(n,Re(Je(1),at(Se(t,"float32"))))}}};function o$(n,e,t,r,o,a){const u=O(n,"dy","avgPool3dGrad"),c=O(e,"input","avgPool3dGrad");let h=u,d=c,m=!1;c.rank===4&&(m=!0,h=J(u,[1,u.shape[0],u.shape[1],u.shape[2],u.shape[3]]),d=J(c,[1,c.shape[0],c.shape[1],c.shape[2],c.shape[3]])),E(h.rank===5,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${h.rank}.`),E(d.rank===5,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${d.rank}.`),pn("avgPool3dGrad",o,a);const g={dy:h,input:d},v={filterSize:t,strides:r,pad:o,dimRoundingMode:a},w=G.runKernel($E,g,v);return m?J(w,[w.shape[1],w.shape[2],w.shape[3],w.shape[4]]):w}const a$=X({avgPool3dGrad_:o$});const l$={kernelName:xw,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[r]=e,{filterSize:o,strides:a,pad:u,dimRoundingMode:c}=t;return{x:()=>a$(n,r,o,a,u,c)}}};function u$(n,e,t,r,o){const a=O(n,"dy","avgPoolGrad"),u=O(e,"input","avgPoolGrad");E(u.rank===a.rank,()=>`Rank of input (${u.rank}) does not match rank of dy (${a.rank})`);let c=u,h=a,d=!1;u.rank===3&&(d=!0,c=J(u,[1,u.shape[0],u.shape[1],u.shape[2]]),h=J(a,[1,a.shape[0],a.shape[1],a.shape[2]])),E(h.rank===4,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${h.rank}.`),E(c.rank===4,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${c.rank}.`);const m={dy:h,input:c},g={filterSize:t,strides:r,pad:o},v=G.runKernel(zE,m,g);return d?J(v,[v.shape[1],v.shape[2],v.shape[3]]):v}const c$=X({avgPoolGrad_:u$});const h$={kernelName:Sw,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[r]=e,{filterSize:o,strides:a,pad:u}=t;return{x:()=>c$(n,r,o,a,u)}}};const f$={kernelName:Ew,inputsToSave:["a","b"],gradFunc:(n,e,t)=>{const[r,o]=e,{transposeA:a,transposeB:u}=t;return!a&&!u?{a:()=>et(n,o,!1,!0),b:()=>et(r,n,!0,!1)}:!a&&u?{a:()=>et(n,o,!1,!1),b:()=>et(n,r,!0,!1)}:a&&!u?{a:()=>et(o,n,!1,!0),b:()=>et(r,n,!1,!1)}:{a:()=>et(o,n,!0,!0),b:()=>et(n,r,!0,!0)}}};const d$={kernelName:Aw,gradFunc:(n,e,t)=>{const{blockShape:r,crops:o}=t;return{x:()=>QT(n,r,o)}}};const p$={kernelName:RE,gradFunc:(n,e,t)=>{const r=t,o=r.inputShape,a=r.shape,u=Array.from(a);for(let h=o.length-1;h>=0;h--)if(o[h]===a[h])u[h]=1;else if(o[h]!==1)throw new Error(`broadcastTo(): [${o}] cannot be broadcast to [${a}].`);const c=[];for(let h=0;h<u.length;h++)u[h]>1&&c.push(h);return{x:()=>Ce(n,c,!0)}}};const m$={kernelName:id,gradFunc:n=>({x:()=>n.clone()})};const g$={kernelName:_E,gradFunc:n=>({x:()=>He(n)})};const y$={kernelName:Iw,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[r]=e,{clipValueMin:o,clipValueMax:a}=t;return{x:()=>Rn(Pi(Wo(r,o),Vo(r,a)),n,He(n))}}};const v$={kernelName:Tw,inputsToSave:["x"],gradFunc:Yb.gradFunc};const w$={kernelName:Nw,saveAllInputs:!0,gradFunc:(n,e,t)=>{const r=e.map(h=>h.shape),{axis:o}=t,a=vr(o,e[0].shape)[0],u=r.map(h=>h[a]);return pr(n,u,a).map(h=>()=>h)}};const b$={kernelName:Cw,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const[r,o]=e,{dilations:a,strides:u,pad:c,dataFormat:h}=t;return E(Ci(a),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${a}'`),{x:()=>pd(r.shape,n,o,u,c,h),filter:()=>kd(r,n,o.shape,u,c,h)}}};const k$={kernelName:Dw,inputsToSave:["dy","filter"],gradFunc:(n,e,t)=>{const[r,o]=e,{strides:a,pad:u,dataFormat:c,dimRoundingMode:h}=t;return{dy:()=>Di(n,o,a,u,c,1,h),filter:()=>kd(n,r,o.shape,a,u,c,h)}}};function S$(n,e,t,r,o){let a=n;n.rank===4&&(a=J(n,[1,n.shape[0],n.shape[1],n.shape[2],n.shape[3]]));let u=e;u.rank===4&&(u=J(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]])),E(a.rank===5,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${a.shape}.`),E(u.rank===5,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${u.shape}.`),E(t.length===5,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${t}.`),E(a.shape[4]===t[3],()=>`Error in conv3dDerFilter: depth of input ${a.shape[4]}) must match input depth in filter (${t[3]}.`),E(u.shape[4]===t[4],()=>`Error in conv3dDerFilter: depth of dy (${u.shape[4]}) must match output depth for filter (${t[4]}).`);const c={x:a,dy:u},h={strides:r,pad:o,filterShape:t};return G.runKernel(OE,c,h)}const x$=X({conv3DBackpropFilter_:S$});const E$={kernelName:zw,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const{dilations:r,strides:o,pad:a}=t;E(Ci(r),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`);const[u,c]=e;return{x:()=>Z0(u.shape,n,c,o,a),filter:()=>x$(u,n,c.shape,o,a)}}};const A$={kernelName:$w,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>P(Wt(FN(Se(t,"float32"))),n)}}};const I$={kernelName:Mw,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>P(ON(Se(t,"float32")),n)}}};const T$={kernelName:Rw,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[r]=e,{axis:o,exclusive:a,reverse:u}=t;return{x:()=>{const c=tb([o],r.rank);let h=nT(n,o,a,!u);return c!=null&&(h=We(h,c)),h}}}};const N$={kernelName:_w,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const{dilations:r,strides:o,pad:a,dimRoundingMode:u}=t,c=r??[1,1];E(Ci(c),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${c}'`);const[h,d]=e;return E(h.rank===4,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${h.rank}.`),E(d.rank===4,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${d.rank}.`),E(h.shape[3]===d.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${h.shape[3]}) must match the inChannels dimension in filter ${d.shape[2]}.`),E(Ps(o,c),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${o} and dilations '${c}'.`),pn("depthwiseConv2d",a,u),{x:()=>uC(h.shape,n,d,o,a,c,u),filter:()=>aC(h,n,d.shape,o,a,c,u)}}};const C$={kernelName:VE,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const[r,o]=e,a={x:r,filter:o,dy:n},u={x:r,filter:o,dy:n};return{x:()=>G.runKernel(GE,a,t),filter:()=>G.runKernel(qE,u,t)}}};const D$={kernelName:Lw,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e,r={dy:n,y:t};return{x:()=>G.runKernel(HE,r)}}};const z$={kernelName:KE,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e,r=P(Ls(Wt(at(t))),2/Math.sqrt(Math.PI));return{x:()=>P(n,r)}}};const $$={kernelName:Ow,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e;return{x:()=>P(n,t)}}};const M$={kernelName:Pw,inputsToSave:["input"],gradFunc:(n,e)=>{const[t]=e;return{input:()=>J(n,t.shape)}}};const R$={kernelName:XE,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>P(n,Ls(t))}}};const _$={kernelName:Bw,gradFunc:n=>({x:()=>He(n)})};const F$={kernelName:Uw,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,r]=e,o=gt(t.shape,r.shape);return{a:()=>{const c=$e(n,Se(r,"float32")),h=Rt(t.shape,o);return h.length>0?J(Ce(c,h),t.shape):c},b:()=>{let c=P(n,Se(t,"float32"));const h=Rt(r.shape,o);h.length>0&&(c=J(Ce(c,h),r.shape));const d=at(r);return Wt($e(c,Se(d,"float32")))}}}};const L$={kernelName:jw,inputsToSave:["x","mean","variance","scale"],gradFunc:(n,e,t)=>{const{varianceEpsilon:r}=t,[o,a,u,c]=e,h=c??Je(1),d=Rt(a.shape,o.shape),m=[];if(a.rank===1){for(let $=0;$<o.shape.length-1;++$)m.push(o.shape[$]);m.push(1)}const g=Re(o,a),v=P(n,h),w=DN(le(u,Je(r))),k=P(P(P(w,w),w),Je(-.5));return{x:()=>a.rank===1?J(P(P(n,fr(J(w,[1,1,1,a.shape[0]]),m)),h),o.shape):J(P(P(n,w),h),o.shape),mean:()=>{let $=P(P(w,Je(-1)),v);return a.rank===1&&($=Ce($,d)),J($,a.shape)},variance:()=>{let $=P(P(k,g),v);return a.rank===1&&($=Ce($,d)),J($,a.shape)},scale:()=>{const $=P(g,w);let B=P(n,$);return a.rank===1&&(B=Ce(B,d)),J(B,a.shape)},offset:()=>{let $=n;return a.rank===1&&($=Ce($,d)),J($,a.shape)}}}};const O$={kernelName:Ww,inputsToSave:["x","indices"],gradFunc:(n,e,t)=>{const[r,o]=e,{axis:a}=t,u=vr(a,r.shape)[0];return{x:()=>{const h=r.shape,d=o.size,m=h.slice(0,u),g=m.length,v=h.slice(a,h.length).slice(1),w=v.length,k=Pv(0,g),S=Pv(g+1,g+1+w),x=Bv([m,[d],v]),T=J(n,x),z=J(o,[d]),R=Bv([[g],k,S]),$=We(T,R);let B=YN($,z,r.shape[u]);const H=gd(R);return B=We(B,H),B},indices:()=>o}}};function Pv(n,e){const t=[];for(let r=n;r<e;++r)t.push(r);return t}function Bv(n){const e=[];for(let t=0;t<n.length;++t)for(let r=0;r<n[t].length;++r)e.push(n[t][r]);return e}const P$={kernelName:Vw,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,r]=e;return{a:()=>He(t),b:()=>He(r)}}};const B$={kernelName:od,gradFunc:n=>({x:()=>Se(n,"float32")})};const U$={kernelName:tA,gradFunc:n=>({x:()=>He(n)})};const j$={kernelName:nA,gradFunc:n=>({x:()=>He(n)})};const W$={kernelName:rA,gradFunc:n=>({x:()=>He(n)})};const V$={kernelName:Gw,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[r]=e,{alpha:o}=t,a=er(r,0);return{x:()=>Rn(a,n,P(n,o))}}};const G$={kernelName:Hw,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>$e(n,le(t,1))}}};const q$={kernelName:qw,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>$e(n,Se(t,"float32"))}}};const H$={kernelName:lA,inputsToSave:[],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[r]=e,{axis:o}=t;return{logits:()=>{const u=Ls(r);return Re(n,P(Ce(n,o,!0),u))}}}};function K$(n,e,t,r=5,o=1,a=1,u=.5){const c={x:n,y:e,dy:t},h={depthRadius:r,bias:o,alpha:a,beta:u};return G.runKernel(cA,c,h)}const J$=X({localResponseNormalizationBackprop_:K$});const X$={kernelName:uA,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[r,o]=e,{depthRadius:a,bias:u,alpha:c,beta:h}=t;return{x:()=>J$(r,o,n,a,u,c,h)}}};function Zb(n,e,t,r){return e.rank<t.rank&&(e=J(e,Ll(e.shape,r))),n.rank<t.rank&&(n=J(n,Ll(n.shape,r))),{x:()=>P(n,Se(ns(t,e),n.dtype))}}const Uv={kernelName:Kw,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const r=t,{reductionIndices:o}=r,a=e[0],u=e[1],c=vr(o,a.shape),h=Zb(n,u,a,c);return{x:()=>h.x()}}};const Y$={kernelName:Jw,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,r]=e;return{a:()=>P(n,Se(Wo(t,r),"float32")),b:()=>P(n,Se(NT(t,r),"float32"))}}};function Z$(n,e,t,r,o,a,u){const c=O(n,"dy","maxPool3dGrad"),h=O(e,"input","maxPool3dGrad"),d=O(t,"output","maxPool3dGrad");let m=c,g=h,v=d,w=!1;h.rank===4&&(w=!0,m=J(c,[1,c.shape[0],c.shape[1],c.shape[2],c.shape[3]]),g=J(h,[1,h.shape[0],h.shape[1],h.shape[2],h.shape[3]]),v=J(d,[1,d.shape[0],d.shape[1],d.shape[2],d.shape[3]])),E(m.rank===5,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${m.rank}.`),E(g.rank===5,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${g.rank}.`),E(v.rank===5,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${v.rank}.`),pn("maxPool3dGrad",a,u);const k={dy:m,input:g,output:v},S={filterSize:r,strides:o,pad:a,dimRoundingMode:u},x=G.runKernel(fA,k,S);return w?J(x,[x.shape[1],x.shape[2],x.shape[3],x.shape[4]]):x}const Q$=X({maxPool3dGrad_:Z$});const eM={kernelName:Yw,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[r,o]=e,{filterSize:a,strides:u,pad:c,dimRoundingMode:h}=t;return{x:()=>Q$(n,r,o,a,u,c,h)}}};function tM(n,e,t,r,o,a,u){const c=O(n,"dy","maxPoolGrad"),h=O(e,"input","maxPoolGrad"),d=O(t,"output","maxPoolGrad");E(h.rank===c.rank,()=>`Rank of input (${h.rank}) does not match rank of dy (${c.rank})`),E(c.rank===4,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${c.rank}.`),E(h.rank===4,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${h.rank}.`),pn("maxPoolGrad",a,u);const m={dy:c,input:h,output:d},g={filterSize:r,strides:o,pad:a,dimRoundingMode:u};return G.runKernel(hA,m,g)}const nM=X({maxPoolGrad_:tM});const rM={kernelName:Xw,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[r,o]=e,{filterSize:a,strides:u,pad:c}=t;return{x:()=>nM(n,r,o,a,u,c)}}};const sM={kernelName:Zw,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[r]=e,{axis:o}=t,a=vr(o,r.shape),c=cT(r.shape,a)[1],h=tn(c);return{x:()=>{const m=r.shape.slice();a.forEach(w=>{m[w]=1});const g=J(n,m);return $e(P(g,Us(r.shape,"float32")),h)}}}};const iM={kernelName:Qw,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const r=t,{axis:o}=r,[a,u]=e,c=vr(o,a.shape),h=Zb(n,u,a,c);return{x:()=>h.x()}}};const oM={kernelName:e0,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,r]=e;return{a:()=>P(n,Se(Vo(t,r),"float32")),b:()=>P(n,Se(er(t,r),"float32"))}}};const aM={kernelName:dA,inputsToSave:["x"],gradFunc:(n,e,t)=>{const r=e[0],{paddings:o}=t,a=o.map(u=>u[0]);return{x:()=>it(n,a,r.shape)}}};const lM={kernelName:pA,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,r]=e,o=gt(t.shape,r.shape);return{a:()=>{const c=Rt(t.shape,o);return c.length>0?J(Ce(n,c),t.shape):n},b:()=>{const c=P(n,Wt(yd($e(t,r)))),h=Rt(r.shape,o);return h.length>0?J(Ce(c,h),r.shape):c}}}};const uM={kernelName:t0,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,r]=e,o=gt(t.shape,r.shape);return{a:()=>{const c=P(n,Se(r,"float32")),h=Rt(t.shape,o);return h.length>0?J(Ce(c,h),t.shape):c},b:()=>{const c=P(n,Se(t,"float32")),h=Rt(r.shape,o);return h.length>0?J(Ce(c,h),r.shape):c}}}};const cM={kernelName:n0,gradFunc:n=>({x:()=>Wt(n)})};const hM={kernelName:s0,inputsToSave:["indices"],gradFunc:(n,e)=>{const t=e[0];return{indices:()=>Ot(t.shape,"float32")}}};const fM={kernelName:r0,gradFunc:n=>({x:()=>He(n)})};const dM={kernelName:i0,saveAllInputs:!0,gradFunc:(n,e,t)=>{const{axis:r}=t;return $i(n,r).map(a=>()=>a)}};const jv={kernelName:o0,inputsToSave:["x"],gradFunc:(n,e,t)=>{const r=e[0],{paddings:o}=t,a=o.map(u=>u[0]);return{x:()=>it(n,a,r.shape)}}};const pM={kernelName:a0,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(n,e)=>{const[t,r,o]=e,a=t,u=r,c=gt(a.shape,u.shape);return{a:()=>{const m=Se(u,"float32");let g=P(n,P(m,Fo(a,Re(m,Je(1)))));const v=Rt(a.shape,c);return v.length>0&&(g=Ce(g,v)),J(g,a.shape)},b:()=>{const m=er(a,0),g=Rn(m,rs(a),He(a));let v=P(n,P(o,g));const w=Rt(u.shape,c);return w.length>0&&(v=Ce(v,w)),J(v,u.shape)}}}};const mM={kernelName:l0,inputsToSave:["x","alpha"],gradFunc:(n,e)=>{const[t,r]=e,o=er(t,0);return{x:()=>Rn(o,n,P(n,r)),alpha:()=>{let a=Rn(o,He(n),P(n,t));const u=Rt(r.shape,n.shape);return u.length>0&&(a=Ce(a,u)),J(a,r.shape)}}}};function gM(n,e,t){const r=n.shape.slice();r[t]=1;const o=J(e,r),a=Sy(n,t,!0,!1),u=Sy(n,t,!0,!0),c=P(a,u);return P(o,c)}function yM(n,e,t){const r=n.shape.length,o=r-t.length,a=tb(t,r);let u=n;a!=null&&(u=We(n,a));const c=u.shape.slice(),d=c.splice(r-t.length,t.length).reduce((v,w)=>v*w,1);c.push(d);const m=u.reshape(c);let g=gM(m,e,o);if(g=g.reshape(u.shape),a!=null){const v=gd(a);g=We(g,v)}return g}const vM={kernelName:wA,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[r]=e,{axis:o}=t;let a=[];return o==null?a=r.shape.map((u,c)=>c):typeof o=="number"?a=[o]:a=o,{x:()=>yM(r,n,a)}}};const wM={kernelName:Fw,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,r]=e,o=gt(t.shape,r.shape);return{a:()=>{const c=$e(n,Se(r,"float32")),h=Rt(t.shape,o);return h.length>0?J(Ce(c,h),t.shape):c},b:()=>{let c=P(n,Se(t,"float32"));const h=Rt(r.shape,o);h.length>0&&(c=J(Ce(c,h),r.shape));const d=at(r);return Wt($e(c,Se(d,"float32")))}}}};const bM={kernelName:SA,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>$e(n,Wt(at(t)))}}};const kM={kernelName:d0,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e,r=P(Vo(t,6),ou(t));return{x:()=>P(n,Se(r,"float32"))}}};const SM={kernelName:u0,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>P(n,Se(ou(t),"float32"))}}};const xM={kernelName:c0,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>J(n,t.shape)}}};const EM={kernelName:f0,inputsToSave:["images"],gradFunc:(n,e,t)=>{const[r]=e,o={dy:n,images:r};return{images:()=>G.runKernel(EA,o,t)}}};const AM={kernelName:h0,inputsToSave:["images"],gradFunc:(n,e,t)=>{const[r]=e,o={dy:n,images:r};return{images:()=>G.runKernel(xA,o,t)}}};const IM={kernelName:p0,gradFunc:(n,e,t)=>{const{dims:r}=t,o=vr(r,n.shape);return{x:()=>Pl(n,o)}}};const TM={kernelName:m0,gradFunc:n=>({x:()=>He(n)})};const NM={kernelName:g0,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Wt($e(n,P(Fo(t,1.5),2)))}}};const CM={kernelName:y0,inputsToSave:["condition"],gradFunc:(n,e)=>{const[t]=e;return{condition:()=>Se(He(t),"float32"),t:()=>P(n,Se(t,n.dtype)),e:()=>P(n,Se(BT(t),n.dtype))}}};const DM={kernelName:v0,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const r=er(t,Je(0)),o=Je(sD),a=Je(iD),u=P(n,a),c=P(P(n,o),Ls(Se(t,"float32")));return Rn(r,u,c)}}}};const zM={kernelName:S0,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e;return{x:()=>P(n,P(t,Re(Je(1),t)))}}};const $M={kernelName:AA,gradFunc:n=>({x:()=>He(n)})};const MM={kernelName:b0,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>P(Q0(Se(t,"float32")),n)}}};const RM={kernelName:k0,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>P(QI(Se(t,"float32")),n)}}};const _M={kernelName:w0,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[r]=e,{begin:o,size:a}=t,u=r.shape,[c,h]=K2(r,o,a),d=[];for(let m=0;m<n.rank;m++)d.push([c[m],u[m]-c[m]-h[m]]);return{x:()=>ab(n,d)}}};const FM={kernelName:N0,outputsToSave:[!0],gradFunc:(n,e,t)=>{const[r]=e,{dim:o}=t,a=!0,u=P(n,r);return{logits:()=>Re(u,P(Ce(u,[o],a),r))}}};const LM={kernelName:x0,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>P(n,nu(t))}}};const Wv={kernelName:I0,gradFunc:(n,e,t)=>{const{blockShape:r,paddings:o}=t;return{x:()=>wI(n,r,o)}}};const Vv={kernelName:T0,gradFunc:(n,e,t)=>{const{axis:r}=t;return{x:()=>Kn(n,r)}}};const OM={kernelName:E0,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>$e(n,P(Kt(Se(t,"float32")),2))}}};const PM={kernelName:TA,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>P(n,P(Se(t,"float32"),2))}}};const BM={kernelName:IA,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,r]=e,o=Je(2);return{a:()=>P(n,P(o,Re(t,r))),b:()=>P(n,P(o,Re(r,t)))}}};const UM={kernelName:R0,gradFunc:n=>({x:()=>He(n)})};const jM={kernelName:C0,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,r]=e,o=gt(t.shape,r.shape);return{a:()=>{let c=n;const h=Rt(t.shape,o);return h.length>0&&(c=Ce(c,h)),J(c,t.shape)},b:()=>{let c=n;const h=Rt(r.shape,o);return h.length>0&&(c=Ce(c,h)),J(Wt(c),r.shape)}}}};const WM={kernelName:A0,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[r]=e,o=r.shape.slice(),{axis:a}=t;vr(a,r.shape).forEach(d=>{o[d]=1});const c=J(n,o),h=P(c,Us(r.shape,"float32"));return{x:()=>h}}};const VM={kernelName:NA,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>$e(n,at(Q0(t)))}}};const GM={kernelName:D0,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e;return{x:()=>P(Re(Je(1),at(t)),n)}}};const qM={kernelName:ad,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[r]=e,{reps:o}=t;return{x:()=>{let u=He(r);if(r.rank===1)for(let c=0;c<o[0];++c)u=le(u,it(n,[c*r.shape[0]],[r.shape[0]]));else if(r.rank===2)for(let c=0;c<o[0];++c)for(let h=0;h<o[1];++h)u=le(u,it(n,[c*r.shape[0],h*r.shape[1]],[r.shape[0],r.shape[1]]));else if(r.rank===3)for(let c=0;c<o[0];++c)for(let h=0;h<o[1];++h)for(let d=0;d<o[2];++d)u=le(u,it(n,[c*r.shape[0],h*r.shape[1],d*r.shape[2]],[r.shape[0],r.shape[1],r.shape[2]]));else if(r.rank===4)for(let c=0;c<o[0];++c)for(let h=0;h<o[1];++h)for(let d=0;d<o[2];++d)for(let m=0;m<o[3];++m)u=le(u,it(n,[c*r.shape[0],h*r.shape[1],d*r.shape[2],m*r.shape[3]],[r.shape[0],r.shape[1],r.shape[2],r.shape[3]]));else throw new Error(`Gradient for tile operation is not implemented for rank-${r.rank} tensors yet.`);return u}}}};const HM={kernelName:kl,gradFunc:(n,e,t)=>{const r=t,{perm:o}=r,a=gd(o);return{x:()=>We(n,a)}}};const KM={kernelName:z0,gradFunc:(n,e,t)=>{const r=t,{axis:o}=r;return{value:()=>ss(n,o)}}};const JM={kernelName:$0,inputsToSave:["segmentIds"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>XM(n,t)}}};function XM(n,e){const t=Bs(e,He(e)),r=Si(n,t);let o=Wo(e,Je(0,"int32"));const a=r.rank-o.rank;for(let c=0;c<a;++c)o=qn(o,c+1);o=Pi(o,Us(r.shape,"bool"));const u=He(r);return Rn(o,r,u)}const YM={kernelName:M0,gradFunc:n=>({x:()=>He(n)})};const ZM=[Yb,Jz,Xz,Yz,Zz,Qz,e$,t$,n$,r$,s$,i$,l$,h$,f$,d$,p$,m$,g$,y$,v$,w$,k$,b$,E$,A$,I$,T$,N$,C$,wM,D$,z$,$$,M$,R$,F$,_$,L$,O$,P$,B$,U$,j$,W$,V$,G$,q$,H$,X$,Uv,Uv,Y$,eM,rM,sM,iM,oM,aM,lM,uM,cM,hM,fM,dM,jv,jv,pM,mM,vM,bM,kM,SM,xM,EM,AM,IM,TM,NM,CM,DM,zM,$M,MM,RM,_M,FM,LM,Wv,Wv,Vv,Vv,OM,BM,PM,UM,jM,WM,VM,GM,qM,HM,KM,JM,YM];for(const n of ZM)zA(n);function qd(n,e){return V(()=>Kt(Ce(P(n,n),e,!0)))}class Qo extends Oi{getConfig(){return{}}}class Qb extends Qo{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return V(()=>{const t=qd(e,this.axis),r=Mn(t,0,this.maxValue);return P(e,$e(r,le(Et(),t)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}Qb.className="MaxNorm";re(Qb);class e1 extends Qo{constructor(e){super(),this.defaultAxis=0,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return V(()=>$e(e,le(Et(),qd(e,this.axis))))}getConfig(){return{axis:this.axis}}}e1.className="UnitNorm";re(e1);class t1 extends Qo{apply(e){return Bi(e)}}t1.className="NonNeg";re(t1);class n1 extends Qo{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=e.minValue!=null?e.minValue:this.defaultMinValue,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.rate=e.rate!=null?e.rate:this.defaultRate,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return V(()=>{const t=qd(e,this.axis),r=le(P(this.rate,Mn(t,this.minValue,this.maxValue)),P(1-this.rate,t));return P(e,$e(r,le(Et(),t)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}n1.className="MinMaxNorm";re(n1);const Gv={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function It(n){return _d(n)}function qv(n,e={}){return Ho(n,Dn.getMap().classNameMap,e,"constraint")}function Tt(n){if(n==null)return null;if(typeof n=="string"){const t={className:n in Gv?Gv[n]:n,config:{}};return qv(t)}else return n instanceof Qo?n:qv(n)}async function Ns(n){if(n==null)return;const e=[],t=[],r=[];for(const o in n){const a=n[o];if(typeof a!="number"){const u=a;e.push(u.data()),t.push(o),r.push(u)}}if(e.length>0){const o=await Promise.all(e);for(let a=0;a<o.length;++a)n[t[a]]=o[a][0];Me(r)}}function r1(n){if(n!=null)for(const e in n){const t=n[e];typeof t!="number"&&t.dispose()}}var Hv;(function(n){n[n.SILENT=0]="SILENT",n[n.VERBOSE=1]="VERBOSE"})(Hv||(Hv={}));const QM=125;class Oo{constructor(){this.validationData=null}setParams(e){this.params=e}async onEpochBegin(e,t){}async onEpochEnd(e,t){}async onBatchBegin(e,t){}async onBatchEnd(e,t){}async onTrainBegin(e){}async onTrainEnd(e){}setModel(e){}}class eR{constructor(e,t=10){e==null&&(e=[]),this.callbacks=e,this.queueLength=t}append(e){this.callbacks.push(e)}setParams(e){for(const t of this.callbacks)t.setParams(e)}setModel(e){for(const t of this.callbacks)t.setModel(e)}async onEpochBegin(e,t){t==null&&(t={});for(const r of this.callbacks)await r.onEpochBegin(e,t)}async onEpochEnd(e,t){t==null&&(t={});for(const r of this.callbacks)await r.onEpochEnd(e,t)}async onBatchBegin(e,t){t==null&&(t={});for(const r of this.callbacks)await r.onBatchBegin(e,t)}async onBatchEnd(e,t){t==null&&(t={});for(const r of this.callbacks)await r.onBatchEnd(e,t)}async onTrainBegin(e){e==null&&(e={});for(const t of this.callbacks)await t.onTrainBegin(e)}async onTrainEnd(e){e==null&&(e={});for(const t of this.callbacks)await t.onTrainEnd(e)}}class tR extends Oo{constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,t){t==null&&(t={});const r=t.size==null?0:t.size;this.seen+=r;for(const o in t){const a=t[o];if(typeof a=="number")this.totals.hasOwnProperty(o)||(this.totals[o]=0),this.totals[o]=this.totals[o]+a*r;else{let u;o in this.totals?u=this.totals[o]:this.totals[o]=0;const c=V(()=>le(this.totals[o],P(a,r)));this.totals[o]=c,u?.dispose()}}}async onEpochEnd(e,t){if(t!=null)for(const r of this.params.metrics)this.totals[r]!=null&&(typeof this.totals[r]=="number"?t[r]=this.totals[r]/this.seen:V(()=>{const o=P($e(1,this.seen),this.totals[r]);t[r]=o,this.totals[r].dispose(),yr(t[r])}))}}class nR extends Oo{async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,t){t==null&&(t={}),this.epoch.push(e);for(const r in t)this.history[r]==null&&(this.history[r]=[]),this.history[r].push(t[r])}async syncData(){const e=[],t=[],r=[];for(const a in this.history){const u=this.history[a];for(let c=0;c<u.length;++c)if(typeof u[c]!="number"){const h=u[c];e.push(h.data()),t.push(a),r.push(c)}}const o=await Promise.all(e);for(let a=0;a<o.length;++a)this.history[t[a]][r[a]].dispose(),this.history[t[a]][r[a]]=o[a][0]}}class rR extends Oo{constructor(e,t){if(super(),this.currentEpoch=0,this.nowFunc=e.nowFunc,this.nextFrameFunc=e.nextFrameFunc||rD,this.yieldEvery=t||"auto",this.yieldEvery==="auto"&&(this.yieldEvery=QM),this.yieldEvery==="never"&&e.onYield!=null)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");Ef(this.yieldEvery)&&(this.maybeWait=pz(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,t,r){const o=[];this.yield!=null&&(await Ns(r),o.push(this.yield(e,t,r))),o.push(this.nextFrameFunc()),await Promise.all(o)}async onEpochBegin(e,t){this.currentEpoch=e,this.epochBegin!=null&&(await Ns(t),await this.epochBegin(e,t))}async onEpochEnd(e,t){const r=[];this.epochEnd!=null&&(await Ns(t),r.push(this.epochEnd(e,t))),this.yieldEvery==="epoch"&&r.push(this.nextFrameFunc()),await Promise.all(r)}async onBatchBegin(e,t){this.batchBegin!=null&&(await Ns(t),await this.batchBegin(e,t))}async onBatchEnd(e,t){const r=[];this.batchEnd!=null&&(await Ns(t),r.push(this.batchEnd(e,t))),this.yieldEvery==="batch"?r.push(this.nextFrameFunc()):Ef(this.yieldEvery)&&r.push(this.maybeWait(this.currentEpoch,e,t)),await Promise.all(r)}async onTrainBegin(e){this.trainBegin!=null&&(await Ns(e),await this.trainBegin(e))}async onTrainEnd(e){this.trainEnd!=null&&(await Ns(e),await this.trainEnd(e))}}function s1(n,e){return n==null&&(n={}),n instanceof Oo?[n]:Array.isArray(n)&&n[0]instanceof Oo?n:nt(n).map(r=>new rR(r,e))}class Cn{constructor(){}static registerCallbackConstructor(e,t){E(e>=0&&Number.isInteger(e),()=>`Verbosity level is expected to be an integer >= 0, but got ${e}`),Cn.checkForDuplicate(t),Cn.constructors[e]==null&&(Cn.constructors[e]=[]),Cn.constructors[e].push(t)}static checkForDuplicate(e){for(const t in Cn.constructors)Cn.constructors[+t].forEach(o=>{if(o===e)throw new _("Duplicate callback constructor.")})}static clear(){Cn.constructors={}}static createCallbacks(e){const t=[];for(const r in Cn.constructors){const o=+r;e>=o&&t.push(...Cn.constructors[o])}return t.map(r=>new r)}}Cn.constructors={};function i1(n,e,t,r,o,a,u,c,h){const d=new nR,m=[new tR,...Cn.createCallbacks(e)];n!=null&&m.push(...n),m.push(d);const g=new eR(m);return g.setParams({epochs:t,initialEpoch:r,samples:o,steps:a,batchSize:u,verbose:e,doValidation:c,metrics:h}),{callbackList:g,history:d}}function gr(n,e={},t=!1){return Ho(n,Dn.getMap().classNameMap,e,"layer",t)}function ql(n,e){return V(()=>{n.dtype!=="float32"&&(n=Se(n,"float32"));const t=Ce(Xo(n),e,!0),r=ru(t.shape,Et()),o=Kt(Bs(t,r));return $e(n,o)})}function fu(n,e){return V(()=>St(Xo(Re(e,n)),-1))}function Hd(n,e){return V(()=>St(Zt(Re(e,n)),-1))}function Kd(n,e){return V(()=>{const t=Re(n,e),r=Mn(Zt(n),Et(),Number.MAX_VALUE),o=Zt($e(t,r));return P(100,St(o,-1))})}function sR(n,e){return V(()=>{const t=Mn(e,Et(),Number.MAX_VALUE),r=rs(le(1,t)),o=Mn(n,Et(),Number.MAX_VALUE),a=rs(le(1,o));return St(Xo(Re(r,a)),-1)})}function iR(n,e){return V(()=>{const t=Bs(0,Re(1,P(n,e)));return St(Xo(t),-1)})}function oR(n,e){return V(()=>{const t=Bs(0,Re(1,P(n,e)));return St(t,-1)})}function aR(n,e){return V(()=>{const t=Ce(P(n,e),-1),r=Dr(P(Re(1,n),e),-1);return Bs(0,le(1,Re(r,t)))})}function lR(n,e){return V(()=>{const t=Math.log(2),r=Re(e,n),o=Re(le(r,vd(P(-2,r))),t);return St(o,-1)})}function Po(n,e,t=!1){return V(()=>{if(t)e=hb(e);else{const r=Ce(e,e.shape.length-1,!0);e=$e(e,r)}return e=Mn(e,Et(),1-Et()),Wt(Ce(P(Se(n,"float32"),rs(e)),e.shape.length-1))})}function Hl(n,e,t=!1){return V(()=>{const r=Se(yd(Iz(n)),"int32");e=Mn(e,Et(),1-Et());const o=e.shape,a=J(xl(r,o[o.length-1]),o);return Po(a,e,t)})}function uR(n,e){if(!nn(n.shape,e.shape))throw new _(`logits and labels must have the same shape, but got shapes ${JSON.stringify(n.shape)} and ${JSON.stringify(e.shape)}`);return V(()=>{const t=Bi(e),r=Wt(Zt(e));return le(Re(t,P(e,n)),$T(Ls(r)))})}function du(n,e){return V(()=>{let t;return t=Mn(e,Et(),1-Et()),t=rs($e(t,Re(1,t))),St(uR(n,t),-1)})}function cR(n,e){return V(()=>{const t=Mn(n,Et(),1),r=Mn(e,Et(),1);return Ce(P(n,rs($e(t,r))),-1)})}function hR(n,e){return V(()=>{const t=rs(le(Et(),e));return St(Re(e,P(n,t)),-1)})}function o1(n,e){return V(()=>{const t=ql(n,-1),r=ql(e,-1),o=P(t,r);return Wt(Ce(o,-1))})}const Kl={meanSquaredError:fu,meanAbsoluteError:Hd,meanAbsolutePercentageError:Kd,meanSquaredLogarithmicError:sR,squaredHinge:iR,hinge:oR,categoricalHinge:aR,logcosh:lR,categoricalCrossentropy:Po,sparseCategoricalCrossentropy:Hl,binaryCrossentropy:du,kullbackLeiblerDivergence:cR,poisson:hR,cosineProximity:o1};function yf(n){if(typeof n=="string"){if(n in Kl)return Kl[n];let e=`Unknown loss ${n}`;throw n.toLowerCase().includes("softmaxcrossentropy")&&(e=`Unknown loss ${n}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new _(e)}else return n}function a1(n,e){return V(()=>{const t=P(.5,Yn(e)),r=Ko(er(e,t),n.dtype);return St(ns(n,r),-1)})}function l1(n,e){return V(()=>Ko(ns(Ni(n,-1),Ni(e,-1)),"float32"))}function fR(n,e){return V(()=>Se(Ce(Pi(ns(n,1),ns(e,1))),"float32"))}function dR(n,e){return V(()=>Se(Ce(Pi(ns(n,0),ns(e,1))),"float32"))}function pR(n,e){return V(()=>{const t=fR(n,e),r=dR(n,e),o=le(t,r);return Se(Rn(er(o,0),$e(t,o),0),"float32")})}function mR(n,e){return du(n,e)}function gR(n,e){return n.rank===e.rank&&(n=zi(n,[n.rank-1])),e=Ni(e,-1),e.dtype!==n.dtype&&(e=Se(e,n.dtype)),Se(ns(n,e),"float32")}const yR=fu,vR=fu,wR=Hd,bR=Hd,kR=Kd,SR=Kd,u1=Po,xR=o1,c1=Hl,Jl={binaryAccuracy:a1,categoricalAccuracy:l1,precision:pR,categoricalCrossentropy:u1,sparseCategoricalCrossentropy:c1,mse:yR,MSE:vR,mae:wR,MAE:bR,mape:kR,MAPE:SR,cosine:xR};function ER(n){if(typeof n=="string"&&n in Jl)return Jl[n];if(typeof n!="string"&&n!=null)return n;throw new _(`Unknown metric ${n}`)}function vl(n){if(cr(n!==null,`Unknown LossOrMetricFn ${n}`),typeof n=="string")return n;{let e;for(const t of Object.keys(Kl))if(Kl[t]===n){e=t;break}if(e!==void 0)return e;for(const t of Object.keys(Jl))if(Jl[t]===n){e=t;break}return e!==void 0?e:n.name}}function AR(n){const e={Adagrad:()=>gi.adagrad(.01),Adadelta:()=>gi.adadelta(1,.95,Et()),Adam:()=>gi.adam(.001,.9,.999,Et()),Adamax:()=>gi.adamax(.002,.9,.999,Et(),0),RMSProp:()=>gi.rmsprop(.001,.9,0,Et()),SGD:()=>gi.sgd(.01)};if(e.adagrad=e.Adagrad,e.adadelta=e.Adadelta,e.adam=e.Adam,e.adamax=e.Adamax,e.rmsprop=e.RMSProp,e.sgd=e.SGD,n in e)return e[n]();throw new _(`Unknown Optimizer ${n}`)}const Kv=1*1024*1024;function Jv(n,e,t=!1){if(n==null||typeof n!="object"||Object.getPrototypeOf(n)!==Object.prototype||!jf(n))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(t){const r=JSON.stringify(n);r.length>Kv&&console.warn(`User-defined metadata of model "${e}" is too large in size (length=${r.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= ${Kv}.`)}}function jf(n){if(n===null)return!0;if(typeof n=="object")if(Object.getPrototypeOf(n)===Object.prototype){const e=Object.keys(n);for(const t of e)if(typeof t!="string"||!jf(n[t]))return!1;return!0}else if(Array.isArray(n)){for(const e of n)if(!jf(e))return!1;return!0}else return!1;else{const e=typeof n;return e==="string"||e==="number"||e==="boolean"}}function IR(n,e,t,r=console.log){const o=NR(n),a=["Layer (type)","Input Shape","Output shape","Param #"];o?(e=e||90,t=t||[.32,.61,.89,1]):(e=e||115,t=t||[.24,.48,.7,.8,1]),t[t.length-1]<=1&&(t=t.map(m=>Math.floor(e*m)));let u;if(!o){a.push("Receives inputs"),u=[];for(const m in n.nodesByDepth)u.push(...n.nodesByDepth[m])}r("_".repeat(e)),Xl(a,t,r),r("=".repeat(e));const c=n.layers;for(let m=0;m<c.length;++m)o?CR(c[m],t,r):DR(c[m],t,u,r),r((m===c.length-1?"=":"_").repeat(e));n.checkTrainableWeightsConsistency();const h=TR(n),d=Wl(n.nonTrainableWeights);r(`Total params: ${h+d}`),r(`Trainable params: ${h}`),r(`Non-trainable params: ${d}`),r("_".repeat(e))}function TR(n){let e;return n.collectedTrainableWeights!=null?e=Wl(n.collectedTrainableWeights):e=Wl(n.trainableWeights),e}function NR(n){let e=!0;const t=[],r=[];for(const o in n.nodesByDepth)t.push(n.nodesByDepth[o]);for(const o of t){if(o.length>1||o.length===1&&o[0].inboundLayers.length>1){e=!1;break}r.push(...o)}if(e)for(const o of n.layers){let a=!1;for(const u of o.inboundNodes)if(r.indexOf(u)!==-1)if(a){e=!1;break}else a=!0;if(!e)break}return e}function Xl(n,e,t=console.log){let r="";for(let o=0;o<n.length;++o)o>0&&(r=r.slice(0,r.length-1)+" "),r+=n[o],r=r.slice(0,e[o]),r+=" ".repeat(e[o]-r.length);t(r)}function CR(n,e,t){let r,o;try{o=n.inboundNodes.map(h=>JSON.stringify(h.inputShapes)).join(",")}catch{o="multiple"}try{r=JSON.stringify(n.outputShape)}catch{r="multiple"}const a=n.name,u=n.getClassName(),c=[`${a} (${u})`,o,r,n.countParams().toString()];Xl(c,e,t)}function DR(n,e,t,r){let o,a;try{a=n.inboundNodes.map(g=>JSON.stringify(g.inputShapes)).join(",")}catch{a="multiple"}try{o=JSON.stringify(n.outputShape)}catch{o="multiple"}const u=[];for(const g of n.inboundNodes)if(!(t!=null&&t.length>0&&t.indexOf(g)===-1))for(let v=0;v<g.inboundLayers.length;++v){const w=g.inboundLayers[v].name,k=g.nodeIndices[v],S=g.tensorIndices[v];u.push(`${w}[${k}][${S}]`)}const c=n.name,h=n.getClassName(),d=u.length===0?"":u[0],m=[`${c} (${h})`,a,o,n.countParams().toString(),d];Xl(m,e,r);for(let g=1;g<u.length;++g)Xl(["","","","",u[g]],e,r)}function h1(n,e,t){return(n==="inboundNodes"||n==="outputLayers"||n==="inputLayers")&&e===0&&typeof t=="string"}function Yl(n,e){if(n===null)return null;if(typeof n=="string")return Cs(n);if(typeof n=="number"||typeof n=="boolean")return n;if(n instanceof Array){const t=[],r=n.length;for(let o=0;o<r;++o){const a=n[o];h1(e,o,a)?t.push(a):t.push(Yl(a,e))}return t}else{const t={};for(const r of Object.keys(n)){const o=n[r];if(r==="name"&&typeof o=="string")t[r]=o;else{const a=Cs(r);t[a]=Yl(o,a)}}return t}}function Wf(n,e){if(n==null)return null;if(typeof n=="string")return Nr(n);if(typeof n=="number"||typeof n=="boolean")return n;if(n instanceof Array){const t=[],r=n.length;for(let o=0;o<r;++o){const a=n[o];h1(e,o,a)?t.push(a):t.push(Wf(a,e))}return t}else{const t={};for(const r of Object.keys(n)){const o=n[r],a=Nr(r);(r==="name"||r==="className")&&typeof o=="string"?t[a]=o:t[a]=Wf(o,r)}return t}}const f1="3.21.0";class Vn extends Ue{constructor(e){if(super({}),this.containerNodes=new Set,this.name=e.name,this.name==null){const z=this.getClassName().toLowerCase();this.name=uu(z)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(e.inputs)?this.inputs=e.inputs.slice():this.inputs=[e.inputs],Array.isArray(e.outputs)?this.outputs=e.outputs.slice():this.outputs=[e.outputs],Qr(this.inputs).length!==this.inputs.length)throw new _(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(z=>z.name)}`);Qr(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(z=>z.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const z of this.outputs){const R=z.sourceLayer,$=z.nodeIndex,B=z.tensorIndex;this.outputLayers.push(R),this.outputLayersNodeIndices.push($),this.outputLayersTensorIndices.push(B)}for(const z of this.inputs){const R=z.sourceLayer,$=z.nodeIndex,B=z.tensorIndex;cr($===0,"input layer has >1 nodes"),cr(B===0,"input layer has >1 tensors"),this.inputLayers.push(R),this.inputLayersNodeIndices.push($),this.inputLayersTensorIndices.push(B)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let z=0;z<this.inputLayers.length;z++){const R=this.inputLayers[z];if(!(R instanceof Zo))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${e.inputs}. Input ${z} (0-based) originates from layer type ${R.getClassName()}.`);this.inputNames.push(R.name),this.feedInputShapes.push(R.batchInputShape),this.feedInputNames.push(R.name)}for(const z of this.outputLayers)this.outputNames.push(z.name);this.internalInputShapes=this.inputs.map(z=>z.shape),this.internalOutputShapes=this.outputs.map(z=>z.shape);const t={},r={},o={},a={},u={},c=[],h=(z,R,$,B,H,Y)=>{(B==null||H==null||Y==null)&&(B=z.sourceLayer,H=z.nodeIndex,Y=z.tensorIndex);const Z=B.inboundNodes[H];if($.indexOf(Z)!==-1)throw new $n(`The tensor ${z.name} at layer "${B.name}" is part of a cycle.`);if(R.indexOf(Z)!==-1)return;this.containerNodes.add(Vn.nodeKey(B,H)),B.id in u||(u[B.id]=Object.keys(u).length),$.indexOf(Z)===-1&&$.push(Z);const ne=Z.inboundLayers.length;for(let oe=0;oe<ne;oe++){const de=Z.inputTensors[oe],me=Z.inboundLayers[oe],ve=Z.nodeIndices[oe],be=Z.tensorIndices[oe];h(de,R,$,me,ve,be)}for(R.push(Z);$.indexOf(Z)>=0;)$.splice($.indexOf(Z),1);c.push(Z)},d=[],m=[];for(const z of this.outputs)h(z,d,m);const g=c.slice().reverse();for(const z of g){r[z.id]=z,z.id in t||(t[z.id]=0);let R=t[z.id];const $=o[z.outboundLayer.id]==null?0:o[z.outboundLayer.id];R=Math.max(R,$),o[z.outboundLayer.id]=R,a[z.outboundLayer.id]=z.outboundLayer,t[z.id]=R;for(let B=0;B<z.inboundLayers.length;B++){const H=z.inboundLayers[B],Y=z.nodeIndices[B],Z=H.inboundNodes[Y],ne=t[Z.id]==null?0:t[Z.id];t[Z.id]=Math.max(R+1,ne),r[Z.id]=Z}}const v={};for(const z in t){const R=t[z];R in v||(v[R]=[]),v[R].push(r[z])}const w={};for(const z in o){const R=o[z];R in w||(w[R]=[]),w[R].push(a[z])}let k=Object.keys(w).map(z=>parseInt(z,10)).sort(ml);this.layers=[];for(const z of k){const R=w[z];R.sort(($,B)=>{const H=u[$.id],Y=u[B.id];return H<Y?-1:H>Y?1:0});for(const $ of R)$ instanceof Vn&&this.internalContainerRefs.push($),this.layers.push($)}this.layersByDepth=w,k=Object.keys(v).map(z=>parseInt(z,10)).sort(ml);const S=this.inputs.slice(),x=[];for(const z of k)for(const R of v[z]){const $=R.outboundLayer;if($!=null){for(const B of R.inputTensors)if(S.indexOf(B)===-1)throw new $n(`Graph disconnected: cannot obtain value for tensor ${B} at layer "${$.name}". The following previous layers were accessed without issue: ${x}`);for(const B of R.outputTensors)S.push(B);x.push($.name)}}this.nodesByDepth=v;const T=this.layers.map(z=>z.name);for(const z of T){const R=T.filter($=>$===z).length;if(R!==1)throw new $n(`The name "${z}" is used ${R} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(T))}this.outboundNodes=[],this.inboundNodes=[],new hu({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(z=>null),outputMasks:this.outputs.map(z=>null),inputShapes:this.inputs.map(z=>z.shape),outputShapes:this.outputs.map(z=>z.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(this._refCount===0)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const e={refCountAfterDispose:null,numDisposedVariables:0};if(--this._refCount===0){for(const t of this.layers)e.numDisposedVariables+=t.dispose().numDisposedVariables;for(const t of this.internalContainerRefs)e.numDisposedVariables+=t.dispose().numDisposedVariables}return e.refCountAfterDispose=this._refCount,e}get trainable(){return this.trainable_}set trainable(e){this.layers.forEach(t=>{t._trainableWeights.forEach(r=>r.trainable=e)}),this.trainable_=e}get trainableWeights(){if(this._trainableWeights.length>0)throw new _("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let e=[];for(const t of this.layers)e=e.concat(t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.layers)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const r of this.layers)t.push(...r.trainableWeights);return t.concat(e)}return e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(e,t=!0){const r={};let o=0;for(const u of this.layers)for(const c of u.weights){if(r[c.originalName]!=null)throw new _(`Duplicate weight name: ${c.originalName}`);r[c.originalName]=c,o++}const a=[];for(const u in e){let c=u;if(r[u]==null){const h=u.split("/");c=h.slice(0,-2).concat([h[h.length-1]]).join("/")}if(r[c]!=null)a.push([r[c],e[u]]);else if(t)throw new _(`Provided weight data has no target variable: ${u}`);delete r[c]}if(t){const u=[];for(const c in r)u.push(c);if(u.length>0)throw new _(`${u.length} of ${o} weights are not set: ${u}`)}Gd(a)}updatedConfig(){const e=this.getConfig(),t={};return t.className=this.getClassName(),t.config=e,t.kerasVersion=`tfjs-layers ${f1}`,t.backend="TensorFlow.js",t}toJSON(e,t=!0){const r=Wf(this.updatedConfig());return t?JSON.stringify(r):r}call(e,t){return V(()=>{e=nt(e);const r=new Zr;for(let o=0;o<this.inputs.length;++o)r.add(this.inputs[o],e[o]);return zo(this.outputs,r,t)})}computeMask(e,t){return V(()=>{e=nt(e);let r;return t==null?r=Os(null,e.length):r=nt(t),this.runInternalGraph(e,r)[1]})}computeOutputShape(e){const t=jl(e);if(t.length!==this.inputLayers.length)throw new _(`Invalid inputShape argument ${e}: model has ${this.inputLayers.length} tensor inputs.`);const r={};for(let c=0;c<t.length;c++){const h=this.inputLayers[c],d=t[c],m=h.name+"_0_0";r[m]=d}const o=Object.keys(this.nodesByDepth).map(c=>parseInt(c,10)).sort(ml);if(o.length>1)for(const c of o){const h=this.nodesByDepth[c];for(const d of h){const m=d.outboundLayer;if(this.inputLayers.map(S=>S.id).indexOf(m.id)!==-1)continue;const g=[];for(let S=0;S<d.inboundLayers.length;S++){const x=d.inboundLayers[S],T=d.nodeIndices[S],z=d.tensorIndices[S],R=`${x.name}_${T}_${z}`,$=r[R];g.push($)}const v=m.computeOutputShape(en(g)),w=jl(v),k=m.inboundNodes.indexOf(d);for(let S=0;S<w.length;S++){const x=`${m.name}_${k}_${S}`;r[x]=w[S]}}}const a=[],u=[];for(let c=0;c<this.outputLayers.length;c++){const h=this.outputLayers[c],d=this.outputLayersNodeIndices[c],m=this.outputLayersTensorIndices[c],g=`${h.name}_${d}_${m}`;u.push(g)}for(let c=0;c<u.length;c++){const h=u[c];cr(h in r),a.push(r[h])}return en(a)}runInternalGraph(e,t){t==null&&(t=Os(null,e.length));const r={};for(let h=0;h<this.inputs.length;++h){const d=this.inputs[h],m=e[h],g=t[h];r[d.id]=[m,g]}const o=Object.keys(this.nodesByDepth).map(h=>parseInt(h,10)).sort(ml);for(const h of o){const d=this.nodesByDepth[h];for(const m of d){const g=m.outboundLayer,v=m.inputTensors,w=m.outputTensors,k=new Array;for(const S of v)S.id in r&&k.push(r[S.id]);if(k.length===v.length){let S={},x,T,z,R;if(m.callArgs!=null&&(S=m.callArgs),k.length===1){const[$,B]=k[0];S.mask==null&&(S.mask=B),z=nt(g.call($,S)),R=nt(g.computeMask($,B)),x=[$],T=[B]}else x=k.map($=>$[0]),T=k.map($=>$[1]),S.mask==null&&(S.mask=T),z=nt(g.call(x,S)),R=nt(g.computeMask(x,T));if(g.activityRegularizer)throw new Oe("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let $=0;$<w.length;++$){const B=w[$],H=z[$],Y=R[$];r[B.id]=[H,Y]}}}}const a=[],u=[],c=[];for(const h of this.outputs){cr(h.id in r,`Could not compute output ${h.name} : ${h.id}`);const[d,m]=r[h.id];c.push(d.shape),a.push(d),u.push(m)}return[a,u,c]}buildNodeConversionMap(e){const t={};let r;for(const o of this.layers){r=o instanceof Vn?1:0;for(let a=0;a<o.inboundNodes.length;a++){const u=Vn.nodeKey(o,a);this.containerNodes.has(u)&&(t[u]=r,r+=1)}}return t}getLayer(e,t){if(t!=null){if(this.layers.length<=t)throw new _(`Was asked to retrieve layer at index ${t}, but model only has ${this.layers.length} layer(s).`);return this.layers[t]}else if(e==null)throw new _("Provide either a layer name or layer index");for(const r of this.layers)if(r.name===e)return r;throw new _(`No such layer: ${e}`)}calculateLosses(){return V(()=>{const e=[];for(const t of this.layers)for(let r=0;r<t.inboundNodes.length;++r){const o=Vn.nodeKey(t,r);this.containerNodes.has(o)&&e.push(...t.calculateLosses())}return e})}getConfig(){const e={name:this.name},t=this.buildNodeConversionMap(this.layers),r=[];for(const u of this.layers){const c=u.getClassName(),h=u.getConfig(),d=[];for(let g=0;g<u.inboundNodes.length;g++){const v=u.inboundNodes[g],w=Vn.nodeKey(u,g);let k={};if(this.containerNodes.has(w)){if(v.callArgs)try{JSON.stringify(v.callArgs),k=v.callArgs}catch{console.warn(`Layer ${u.name} was passed non-serializable keyword arguments: ${v.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),k={}}if(v.inboundLayers.length>0){const S=[];for(let x=0;x<v.inboundLayers.length;x++){const T=v.inboundLayers[x],z=v.nodeIndices[x],R=v.tensorIndices[x],$=Vn.nodeKey(T,z);let B=t[$];B==null&&(B=0),S.push([T.name,B,R,k])}d.push(S)}}}const m={};m.name=u.name,m.className=c,m.config=h,m.inboundNodes=d,r.push(m)}e.layers=r;const o=[];for(let u=0;u<this.inputLayers.length;u++){const c=this.inputLayers[u],h=this.inputLayersNodeIndices[u],d=Vn.nodeKey(c,h);if(!this.containerNodes.has(d))continue;let m=t[d];m==null&&(m=0);const g=this.inputLayersTensorIndices[u];o.push([c.name,m,g])}e.inputLayers=o;const a=[];for(let u=0;u<this.outputLayers.length;u++){const c=this.outputLayers[u],h=this.outputLayersNodeIndices[u],d=Vn.nodeKey(c,h);if(!this.containerNodes.has(d))continue;let m=t[d];m==null&&(m=0);const g=this.outputLayersTensorIndices[u];a.push([c.name,m,g])}return e.outputLayers=a,e}static fromConfig(e,t,r={},o=!1){const a={},u={};function c(x,T){x.name in u?u[x.name].push(T):u[x.name]=[T]}function h(x,T){const z=[];let R;for(const $ of T){const B=$[0],H=$[1],Y=$[2];if(R=$[3]==null?{}:$[3],!(B in a)){c(x,T);return}const Z=a[B];if(Z.inboundNodes.length<=H){c(x,T);return}const ne=Z.inboundNodes[H];z.push(ne.outputTensors[Y])}z.length>0&&x.apply(en(z),R)}function d(x){const T=x.name,z=gr(x,t.customObjects!=null?t.customObjects:{});z.setFastWeightInitDuringBuild(o),a[T]=z,x.inboundNodes.forEach($=>{if(!($ instanceof Array))throw new _(`Corrupted configuration, expected array for nodeData: ${$}`);c(z,$)})}const m=t.name,g=t.layers;for(const x of g)d(x);for(;!dz(u);)for(const x of g){const T=a[x.name];if(T.name in u){const z=u[T.name];delete u[T.name];for(const R of z)h(T,R)}}const v=[],w=[],k=t.inputLayers;for(const x of k){const T=x[0],z=x[1],R=x[2];cr(T in a);const B=a[T].inboundNodes[z].outputTensors;v.push(B[R])}const S=t.outputLayers;for(const x of S){const T=x[0],z=x[1],R=x[2];cr(T in a);const B=a[T].inboundNodes[z].outputTensors;w.push(B[R])}return new e({inputs:v,outputs:w,name:m})}get stateful(){if(this._stateful)throw new _("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const e of this.layers)if(e.stateful)return!0;return!1}resetStates(){V(()=>{this.layers.forEach(e=>{e.stateful&&e.resetStates()})})}}function zR(n,e,t){const r=e.length;if(n==null||Array.isArray(n)&&n.length===0)return e.map(o=>null);if(r===1)return Array.isArray(n)&&n.length===1?n:typeof n=="object"&&e[0]in n?[n[e[0]]]:[n];if(Array.isArray(n)){if(n.length!==r)throw new Error(`Provided ${t} is an array of ${n.length} element(s), but the model has ${r} outputs. Make sure a set of weights is provided for each model output.`);return n}else if(typeof n=="object"&&Object.keys(n).length>0&&typeof n[Object.keys(n)[0]]=="object"){const o=[];return e.forEach(a=>{a in n?o.push(n[a]):o.push(null)}),o}else throw new Error(`The model has multiple (${r}) outputs, so ${t} must be either an array with ${r} elements or an object with ${e} keys. Provided ${t} not understood: ${JSON.stringify(n)}`)}function d1(n,e){return zR(n,e,"classWeight")}async function p1(n,e,t,r){if(t!=null){const o=V(()=>{if(n.shape.length===1)return zs(n);if(n.shape.length===2){if(n.shape[1]>1)return Ni(n,1);if(n.shape[1]===1)return J(n,[n.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${n.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}else throw new Error(`Unexpected rank of target (y) tensor (${n.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),a=Array.from(await o.data());Me(o);const u=[];return a.forEach(c=>{if(t[c]==null)throw new Error(`classWeight must contain all classes in the training data. The class ${c} exists in the data but not in classWeight`);u.push(t[c])}),jt(u,"float32")}else return null}function $R(n,e){return P(n,e)}const MR=32;function m1(n,e){let t,r;const o=e;t=o.xs,r=o.ys,E(t!=null&&r!=null,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${e}`);const a=Xv("input",n.inputNames,t),u=Xv("output",n.outputNames,r),c=a[0].shape[0];E(a.length===n.inputs.length,()=>`LayersModel has ${n.inputs.length} inputs, but the dataset provides ${a.length} inputs.  (Expected input keys: ${JSON.stringify(n.inputNames)})`),E(u.length===n.outputs.length,()=>`LayersModel has ${n.outputs.length} outputs, but the dataset provides ${u.length} outputs.  (Expected output keys: ${JSON.stringify(n.outputNames)})`);for(let h=0;h<a.length;h++)E(a[h].shape[0]===c,()=>`Batch size mismatch: input ${n.inputNames[h]} has ${a[h].shape[0]}; expected  ${c} based on input ${n.inputNames[0]}.`);for(let h=0;h<u.length;h++)E(u[h].shape[0]===c,()=>`Batch size mismatch: output ${n.outputNames[h]} has ${u[h].shape[0]}; expected  ${c} based on input ${n.inputNames[0]}.`);return{xs:a,ys:u}}function Xv(n,e,t){if(t instanceof ot)return[t];if(Array.isArray(t))return E(t.length===e.length,()=>`Received an array of ${t.length} Tensors, but expected ${e.length} to match the ${n} keys ${e}.`),t;{const r=[];for(const o of e){if(t[o]==null)throw new _(`The feature data generated by the dataset lacks the required ${n} key '${o}'.`);r.push(t[o])}return r}}function RR(n){if(n.length===3)throw new Oe("Validation with sample weights is not implemented yet.");return{xs:n[0],ys:n[1]}}async function _R(n,e,t){const r=t.batchesPerEpoch!=null;if(E(n.optimizer!=null,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),E(t!=null,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),E(t.epochs!=null&&t.epochs>0&&Number.isInteger(t.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${t.epochs}`),E(!r||t.batchesPerEpoch>0&&Number.isInteger(t.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${t.batchesPerEpoch}`),E(t.validationSplit==null,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),n.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");n.isTraining=!0;try{const o=t.validationData!=null;let a,u;if(o)if(Yv(t.validationData))E(t.validationBatches==null||t.validationBatches>0&&Number.isInteger(t.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${t.validationBatches}`);else{const x=RR(t.validationData);a=x.xs,u=x.ys}const c=n.makeTrainFunction(),h=n.getDedupedMetricsNames();let d;o?d=h.slice().concat(h.map(x=>"val_"+x)):d=h.slice();const m=s1(t.callbacks,t.yieldEvery),g=t.verbose==null?1:t.verbose,{callbackList:v,history:w}=i1(m,g,t.epochs,null,null,FR(e,t),null,o,d);v.setModel(n),n.history=w,await v.onTrainBegin(),n.stopTraining_=!1;let k=t.initialEpoch==null?0:t.initialEpoch,S=await e.iterator();for(;k<t.epochs;){const x={};await v.onEpochBegin(k);let T=0,z=0;for(r||(S=await e.iterator());!r||T<t.batchesPerEpoch;){const R=await S.next();if(r&&R.done){console.warn(`You provided \`batchesPerEpoch\` as ${t.batchesPerEpoch}, but your dataset iterator ran out of data after ${T} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${t.batchesPerEpoch*t.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(R.value!=null){const{xs:$,ys:B}=m1(n,R.value),H={};H.batch=z,H.size=$[0].shape[0],await v.onBatchBegin(z,H);const Y=[];if(t.classWeight!=null){const oe=d1(t.classWeight,n.outputNames);for(let de=0;de<oe.length;++de)Y.push(await p1(B[de],null,oe[de]))}const Z=$.concat(B).concat(Y),ne=c(Z);Me(Z);for(let oe=0;oe<h.length;++oe){const de=h[oe],me=ne[oe];H[de]=me,yr(me)}await v.onBatchEnd(z,H),r1(H),z++,T++}if(r?T>=t.batchesPerEpoch:R.done){if(o){let $;Yv(t.validationData)?$=nt(await n.evaluateDataset(t.validationData,{batches:t.validationBatches})):$=nt(n.evaluate(a,u,{batchSize:t.validationBatchSize==null?MR:t.validationBatchSize,verbose:0}));for(let B=0;B<n.metricsNames.length;++B)x[`val_${n.metricsNames[B]}`]=$[B]}break}if(n.stopTraining_)break}if(await v.onEpochEnd(k,x),k++,n.stopTraining_)break}return await v.onTrainEnd(),await n.history.syncData(),n.history}finally{n.isTraining=!1}}function FR(n,e){let t=null;return e.batchesPerEpoch!=null?t=e.batchesPerEpoch:Number.isFinite(n.size)&&(t=n.size),t}function Yv(n){return typeof n.iterator=="function"}function LR(n){return typeof n.next=="function"}async function OR(n,e,t){t=t||{};const r=t.batches!=null,o=n.testFunction;let a=[];if(t.verbose>0)throw new Oe("Verbose mode is not implemented yet.");E(!r||t.batches>0&&Number.isInteger(t.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(t.batches)}`);const u=LR(e)?e:await e.iterator();let c=0,h=0;for(;!r||h<t.batches;){const d=await u.next();if(a=V(()=>{if(d.value){const{xs:m,ys:g}=m1(n,d.value),v=m.concat(g),w=V(()=>o(v));if(Me(v),h===0)for(let S=0;S<w.length;++S)a.push(Je(0));const k=v[0].shape[0];for(let S=0;S<w.length;++S){const x=w[S],T=a[S];a[S]=V(()=>le(a[S],P(k,x))),h>0&&Me(T)}Me(w),c+=k,++h}return a}),d.done){r&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${t.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let d=0;d<a.length;++d){const m=a[d];a[d]=$e(a[d],c),Me(m)}return en(a)}function Vf(n){E(n>0&&Number.isInteger(n),()=>`batchSize is required to be a positive integer, but got ${n}`)}function $o(n,e,t){return n==null?[null]:Array.isArray(n)?n.map(r=>Ms(r,e,t-e)):Ms(n,e,t-e)}function Jd(n,e){return V(()=>n==null?null:Array.isArray(n)?n.map(t=>Jd(t,e)):Ub(n,e.dtype==="int32"?e:Se(e,"int32")))}function Gf(n,e){const t=[];let r=0,o=null;for(;r<n;)o=r+e,o>=n&&(o=n),t.push([r,o]),r=o;return t}async function PR(n,e,t,r,o,a,u,c,h,d,m,g,v,w,k){o==null&&(o=32),a==null&&(a=1),m==null&&(m=!0),v==null&&(v=0);let S=!1;h!=null&&d!=null&&(S=!0);const x=n.checkNumSamples(t,o,w,"steps_per_epoch");let T;x!=null&&(T=Zn(0,x)),u==null&&(u=1);const{callbackList:z,history:R}=i1(c,u,a,v,x,w,o,S,g);z.setModel(n),n.history=R,await z.onTrainBegin(),n.stopTraining_=!1;for(let $=v;$<a;++$){await z.onEpochBegin($);const B={};{if(m==="batch")throw new Oe("batch shuffling is not implemneted yet");m&&_o(T);const H=jt(T),Y=Gf(x,o);for(let Z=0;Z<Y.length;++Z){const ne={};if(await z.onBatchBegin(Z,ne),V(()=>{const oe=Y[Z][0],de=Y[Z][1],me=Ms(H,oe,de-oe);ne.batch=Z,ne.size=de-oe;const ve=Jd(t,me),be=e(ve);for(let Ne=0;Ne<r.length;++Ne){const Ie=r[Ne],Ee=be[Ne];ne[Ie]=Ee,yr(Ee)}if(Z===Y.length-1&&S){const Ne=n.testLoop(h,d,o);for(let Ie=0;Ie<r.length;++Ie){const Ee=r[Ie],D=Ne[Ie];yr(D),B["val_"+Ee]=D}}}),await z.onBatchEnd(Z,ne),r1(ne),n.stopTraining_)break}H.dispose()}if(await z.onEpochEnd($,B),n.stopTraining_)break}return await z.onTrainEnd(),await n.history.syncData(),n.history}async function BR(n,e,t,r={}){if(n.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");n.isTraining=!0;let o,a,u,c,h,d,m,g,v;try{const w=r.batchSize==null?32:r.batchSize;Vf(w);const S=await n.standardizeUserData(e,t,r.sampleWeight,r.classWeight,!1,w);o=S[0],a=S[1],v=S[2];let x=!1,T;if(r.validationData!=null&&r.validationData.length>0){if(x=!0,r.validationData.length===2)h=r.validationData[0],d=r.validationData[1];else throw r.validationData.length===3?new Oe("validationData including sample weights is not supported yet."):new _(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${r.validationData} is invalid.`);const oe=await n.standardizeUserData(h,d,null,null,!0,w);m=oe[0],g=oe[1],T=m.concat(g)}else if(r.validationSplit!=null&&r.validationSplit>0&&r.validationSplit<1){x=!0;const ne=Math.floor(o[0].shape[0]*(1-r.validationSplit)),oe=o[0].shape[0];m=$o(o,ne,oe),u=o,o=$o(o,0,ne),g=$o(a,ne,oe),c=a,a=$o(a,0,ne),T=m.concat(g)}else r.validationSteps!=null&&(x=!0);const z=o.concat(a).concat(v);n.checkTrainableWeightsConsistency();const R=n.makeTrainFunction(),$=n.getDedupedMetricsNames();let B,H;x?(n.makeTestFunction(),B=n.testFunction,H=$.slice().concat($.map(ne=>"val_"+ne))):(B=null,T=[],H=$.slice());const Y=s1(r.callbacks,r.yieldEvery);return await PR(n,R,z,$,w,r.epochs,r.verbose,Y,B,T,r.shuffle,H,r.initialEpoch,null,null)}finally{n.isTraining=!1,Hn(o,e),Hn(a,t),Hn(u,e),Hn(c,t),Hn(m,h),Hn(g,d),v!=null&&Me(v)}}function g1(n){const e=[];n instanceof ot&&(n=[n]);for(let t=0;t<n.length;++t){const r=n[t];if(r.rank===1)e.push(Jo(r,1));else{if(r.rank===0)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");e.push(r)}}return e}function Hn(n,e){if(n==null)return;const t=[];if(e instanceof ot)t.push(e.id);else if(Array.isArray(e))e.forEach(o=>t.push(o.id));else if(e!=null)for(const o in e){const a=e[o];t.push(a.id)}const r=[];if(n instanceof ot)t.indexOf(n.id)===-1&&r.push(n);else if(Array.isArray(n))n.forEach(o=>{t.indexOf(o.id)===-1&&r.push(o)});else if(n!=null)for(const o in n){const a=n[o];t.indexOf(a.id)===-1&&r.push(a)}r.forEach(o=>{o.isDisposed||o.dispose()})}function UR(n){return n instanceof ot}function qf(n){return Array.isArray(n)}function Zv(n){return!UR(n)&&!qf(n)}function Qv(n,e,t,r=!0,o=""){if(e==null||e.length===0){if(n!=null){let u=!1;if(qf(n)&&n.length>0)u=!0;else if(Zv(n)){for(const c in n)if(n.hasOwnProperty(c)){u=!0;break}}else u=!0;if(u)throw new _(`Error when checking model ${o} expected no data, but got ${n}`)}return[]}if(n==null)return e.map(u=>null);let a;if(Zv(n)){n=n,a=[];for(const u of e){if(n[u]==null)throw new _(`No data provided for "${u}". Need data for each key in: ${e}`);a.push(n[u])}}else if(qf(n)){if(n=n,n.length!==e.length)throw new _(`Error when checking model ${o}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${e.length} Tensor(s), but instead got the following list of Tensor(s): ${n}`);a=n}else{if(n=n,e.length>1)throw new _(`The model ${o} expects ${e.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${n.shape}`);a=[n]}if(a=g1(a),t!=null)for(let u=0;u<e.length;++u){if(t[u]==null)continue;const c=a[u];if(c.shape.length!==t[u].length)throw new _(`Error when checking ${o}: expected ${e[u]} to have ${t[u].length} dimension(s). but got array with shape ${c.shape}`);for(let h=0;h<t[u].length;++h){if(h===0&&!r)continue;const d=c.shape[h],m=t[u][h];if(m!=null&&m>=0&&d!==m)throw new _(`${o} expected a batch of elements where each example has shape [${t[u].slice(1,t[u].length)}] (i.e.,tensor shape [*,${t[u].slice(1,t[u].length)}]) but the ${o} received an input with ${c.shape[0]} examples, each with shape [${c.shape.slice(1,c.shape.length)}] (tensor shape [${c.shape}])`)}}return a}function jR(n,e,t){const r=Qr(n.map(a=>a.shape[0]));r.sort();const o=Qr(e.map(a=>a.shape[0]));if(o.sort(),r.length>1)throw new _(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(n.map(a=>a.shape))}`);if(o.length>1)throw new _(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map(a=>a.shape))}`);if(r.length>0&&o.length>0&&!nn(r,o))throw new _(`Input Tensors should have the same number of samples as target Tensors. Found ${r[0]} input sample(s) and ${o[0]} target sample(s).`)}function WR(n,e,t){const r=[fu,du,Po];for(let o=0;o<n.length;++o){const a=n[o],u=e[o],c=t[o];if(u!=null){if(u===Po&&a.shape[a.shape.length-1]===1)throw new _(`You are passing a target array of shape ${a.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(r.indexOf(u)!==-1){const h=a.shape.slice(1),d=c.slice(1);for(let m=0;m<h.length;++m){const g=h[m],v=d[m];if(v!=null&&g!==v)throw new _(`A target Tensor with shape ${a.shape} was passed for an output of shape ${c}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}function ew(n,e,t,r=!0,o=""){let a;if(Array.isArray(n)){if(n.length!==e.length)throw new _(`Error when checking model ${o}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${e.length} Tensor(s), but instead got ${n.length} Tensors(s).`);a=n}else{if(e.length>1)throw new _(`The model expects ${e.length} ${o} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(n.shape)}.`);a=[n]}if(t!=null)for(let u=0;u<e.length;++u){if(t[u]==null)continue;const c=a[u];if(c.shape.length!==t[u].length)throw new _(`Error when checking ${o}: expected ${e[u]} to have ${t[u].length} dimension(s), but got array with shape ${JSON.stringify(c.shape)}`);for(let h=0;h<t[u].length;++h){if(h===0&&!r)continue;const d=c.shape[h],m=t[u][h];if(m!=null&&m!==d)throw new _(`Error when checking ${o}: expected ${e[u]} to have shape ${JSON.stringify(t[u])} but got array with shape ${JSON.stringify(c.shape)}.`)}}}function VR(n,e){if(n==null||Array.isArray(n)&&n.length===0)return e.map(r=>[]);let t;if(typeof n=="string"||typeof n=="function")t=[n];else if(Array.isArray(n)||typeof n=="object")t=n;else throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${n}`);if(Array.isArray(t))return e.map(r=>t);{const r=[];for(const o of e){let a=t.hasOwnProperty(o)?t[o]:[];Array.isArray(a)||(a=[a]),r.push(a)}return r}}const GR="layers-model";class Rs extends Vn{constructor(e){super(e),this.isTraining=!1}summary(e,t,r=console.log){if(!this.built)throw new _("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");IR(this,e,t,r)}compile(e){if(e.loss==null&&(e.loss=[]),this.loss=e.loss,typeof e.optimizer=="string")this.optimizer_=AR(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof us))throw new _("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let t=[];if(!Array.isArray(e.loss)&&typeof e.loss!="string"&&typeof e.loss!="function"){e.loss=e.loss;for(const u in e.loss)if(this.outputNames.indexOf(u)===-1)throw new _(`Unknown entry in loss dictionary: "${u}". Only expected the following keys: ${this.outputNames}`);for(const u of this.outputNames)e.loss[u]==null&&console.warn(`Output "${u}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${u} during training`),t.push(yf(e.loss[u]))}else if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new _(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);t=e.loss.map(c=>yf(c))}else{const u=yf(e.loss);this.outputs.forEach(c=>{t.push(u)})}this.lossFunctions=t,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let u=0;u<this.outputs.length;++u){const c=this.internalOutputShapes[u],h=this.outputNames[u];this.feedOutputNames.push(h),this.feedOutputShapes.push(c),this.feedLossFns.push(this.lossFunctions[u])}const r=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],$s("loss",()=>{for(let u=0;u<this.outputs.length;++u){if(r.indexOf(u)!==-1)continue;const c=this.lossFunctions[u];this.outputs.length>1&&(this.metricsTensors.push([c,u]),this.metricsNames.push(this.outputNames[u]+"_loss"))}});const o=VR(e.metrics,this.outputNames),a=(u,c,h)=>{this.outputNames.length>1&&(c=this.outputNames[u]+"_"+c),this.metricsNames.push(c),this.metricsTensors.push([h,u])};$s("metric",()=>{for(let u=0;u<this.outputs.length;++u){if(r.indexOf(u)!==-1)continue;const c=o[u];(d=>{let g,v,w;for(const k of d){if(typeof k=="string"&&["accuracy","acc","crossentropy","ce"].indexOf(k)!==-1){const x=this.internalOutputShapes[u];x[x.length-1]===1||this.lossFunctions[u]===du?["accuracy","acc"].indexOf(k)!==-1?v=a1:["crossentropy","ce"].indexOf(k)!==-1&&(v=mR):this.lossFunctions[u]===Hl?["accuracy","acc"].indexOf(k)!==-1?v=gR:["crossentropy","ce"].indexOf(k)!==-1&&(v=c1):["accuracy","acc"].indexOf(k)!==-1?v=l1:["crossentropy","ce"].indexOf(k)!==-1&&(v=u1);let T;["accuracy","acc"].indexOf(k)!==-1?T="acc":["crossentropy","ce"].indexOf(k)!==-1&&(T="ce"),w=v,g=""+T}else w=ER(k),g=""+vl(k);let S;$s(g,()=>{S=w}),a(u,g,S)}})(c)}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){this.collectedTrainableWeights!=null&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,t,r={}){const o=r.batchSize==null?32:r.batchSize;Vf(o);const u=this.standardizeUserDataXY(e,t,!0,o);try{const c=u[0].concat(u[1]);this.makeTestFunction();const h=this.testFunction,d=this.testLoop(h,c,o,r.verbose,r.steps);return en(d)}finally{Hn(u[0],e),Hn(u[1],t)}}async evaluateDataset(e,t){return this.makeTestFunction(),OR(this,e,t)}checkNumSamples(e,t,r,o="steps"){let a;if(r!=null){if(a=null,t!=null)throw new _(`If ${o} is set, batchSize must be null or undefined.Got batchSize = ${t}`)}else if(e!=null)Array.isArray(e)?a=e[0].shape[0]:a=e.shape[0];else throw new _(`Either the input data should have a defined shape, or ${o} shoud be specified.`);return a}execute(e,t){if(Array.isArray(t)&&t.length===0)throw new _("`outputs` is an empty Array, which is not allowed.");const r=Array.isArray(t),o=r?t:[t],a=this.retrieveSymbolicTensors(o),u=new Zr;if(e instanceof ot&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new _(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let h=0;h<this.inputs.length;++h)u.add(this.inputs[h],e[h])}else for(const h of this.inputs){const d=e[h.name];if(d==null)throw new _(`No value is provided for the model's input ${h.name}`);u.add(h,d)}const c=zo(a,u);return r?c:c[0]}retrieveSymbolicTensors(e){const t=Os(null,e.length);let r=e.length;for(const o of this.layers){const a=Array.isArray(o.output)?o.output:[o.output],u=a.map(c=>c.name);for(let c=0;c<e.length;++c){const h=u.indexOf(e[c]);if(h!==-1&&(t[c]=a[h],r--),r===0)break}if(r===0)break}if(r>0){const o=[];throw t.forEach((a,u)=>{a==null&&o.push(e[u])}),new _(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(o)}`)}return t}predictLoop(e,t=32,r=!1){return V(()=>{const o=this.checkNumSamples(e);if(r)throw new Oe("Verbose predictLoop() is not implemented yet.");const a=Gf(o,t),u=this.outputs.map(c=>[]);for(let c=0;c<a.length;++c)V(()=>{const d=a[c][0],m=a[c][1],g=$o(e,d,m),v=[];if(Array.isArray(g))for(let k=0;k<g.length;++k)v.push({key:this.inputs[k],value:g[k]});else v.push({key:this.inputs[0],value:g});const w=new Zr(v);return zo(this.outputs,w)}).forEach((d,m)=>u[m].push(d));return en(u.map(c=>Kn(c,0)))})}predict(e,t={}){const r=g1(e);ew(r,this.inputNames,this.feedInputShapes,!1);try{const o=t.batchSize==null?32:t.batchSize;return Vf(o),this.predictLoop(r,o)}finally{Hn(r,e)}}predictOnBatch(e){ew(e,this.inputNames,this.feedInputShapes,!0);const t=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,t)}standardizeUserDataXY(e,t,r=!0,o){if(this.optimizer_==null)throw new $n("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const a=[];for(let u=0;u<this.feedOutputShapes.length;++u){const c=this.feedOutputShapes[u];this.feedLossFns[u]===Hl?a.push(c.slice(0,c.length-1).concat([1])):a.push(c)}if(e=Qv(e,this.feedInputNames,this.feedInputShapes,!1,"input"),t=Qv(t,this.feedOutputNames,a,!1,"target"),jR(e,t),WR(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&o!=null&&o>0&&e[0].shape[0]%o!==0)throw new _(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${o}. Found: ${e[0].shape[0]} sample(s).`);return[e,t]}async standardizeUserData(e,t,r,o,a=!0,u){const[c,h]=this.standardizeUserDataXY(e,t,a,u);if(r!=null)throw new Error("sample weight is not supported yet.");let d=null;if(o!=null){const m=d1(o,this.outputNames);d=[];for(let g=0;g<m.length;++g)d.push(await p1(h[g],null,m[g]))}return[c,h,d]}testLoop(e,t,r,o=0,a){return V(()=>{const u=this.checkNumSamples(t,r,a,"steps"),c=[];if(o>0)throw new Oe("Verbose mode is not implemented yet.");if(a!=null)throw new Oe("steps mode in testLoop() is not implemented yet");{const h=Gf(u,r),d=jt(Zn(0,u));for(let m=0;m<h.length;++m){const g=h[m][0],v=h[m][1],w=Ms(d,g,v-g),k=Jd(t,w),S=e(k);if(m===0)for(let x=0;x<S.length;++x)c.push(Je(0));for(let x=0;x<S.length;++x){const T=S[x];c[x]=le(c[x],P(v-g,T))}}for(let m=0;m<c.length;++m)c[m]=$e(c[m],u)}return c})}getDedupedMetricsNames(){const e=this.metricsNames,t=[];for(let r=0;r<e.length;++r){const o=e[r];let a=o;if($v(e,o)>1){const u=$v(e.slice(0,r),o);a+=`_${u}`}t.push(a)}return t}makeTrainFunction(){return e=>{const t=[],r=e.slice(0,this.inputs.length),o=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),a=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+this.outputs.length*2),u=[],c=()=>{const g=[];for(let S=0;S<this.inputs.length;++S)g.push({key:this.inputs[S],value:r[S]});const v=new Zr(g),w=zo(this.outputs,v,{training:!0});let k;for(let S=0;S<this.lossFunctions.length;++S){const x=this.lossFunctions[S];let T=x(o[S],w[S]);a[S]!=null&&(T=$R(T,a[S]));const z=St(T);t.push(z),S===0?k=T:k=le(k,T)}for(let S=0;S<this.metricsTensors.length;++S){let x;if(this.outputs.length>1&&S<this.outputs.length)x=t[S];else{const T=this.metricsTensors[S][0],z=this.metricsTensors[S][1];x=St(T(o[z],w[z]))}yr(x),u.push(x)}return k=St(k),this.calculateLosses().forEach(S=>{k=le(k,S)}),k},h=this.collectedTrainableWeights.map(g=>g.read());return[this.optimizer_.minimize(c,!0,h)].concat(u)}}makeTestFunction(){this.testFunction=e=>V(()=>{const t=[];let r;const o=e.slice(0,this.inputs.length),a=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),u=[];for(let d=0;d<this.inputs.length;++d)u.push({key:this.inputs[d],value:o[d]});const c=new Zr(u),h=zo(this.outputs,c);for(let d=0;d<this.lossFunctions.length;++d){const m=this.lossFunctions[d],g=St(m(a[d],h[d]));d===0?r=g:r=le(r,g),t.push(r)}for(let d=0;d<this.metricsTensors.length;++d){const m=this.metricsTensors[d][0],g=this.metricsTensors[d][1],v=St(m(a[g],h[g]));t.push(v)}return t})}async fit(e,t,r={}){return BR(this,e,t,r)}async fitDataset(e,t){return _R(this,e,t)}async trainOnBatch(e,t){const r=await this.standardizeUserData(e,t),o=r[0],a=r[1],c=this.makeTrainFunction()(o.concat(a)),h=[];for(const d of c){const m=await d.data();h.push(m[0])}return Me(c),Hn(r[0],e),Hn(r[1],t),en(h)}getNamedWeights(e){const t=[],r=e!=null&&e.trainableOnly,o=r?this.trainableWeights:this.weights,a=this.getWeights(r);for(let u=0;u<o.length;++u)r&&!o[u].trainable||t.push({name:o[u].originalName,tensor:a[u]});return t}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){const e=super.dispose();if(e.refCountAfterDispose===0&&this.optimizer!=null&&this.isOptimizerOwned){const t=by().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=t-by().numTensors}return e}getLossIdentifiers(){let e;if(typeof this.loss=="string")e=Nr(this.loss);else if(Array.isArray(this.loss)){for(const t of this.loss)if(typeof t!="string")throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map(t=>Nr(t))}else{const t=Object.keys(this.loss);e={};const r=this.loss;for(const o of t)if(typeof r[o]=="string")e[o]=Nr(r[o]);else throw new Error("Serialization of non-string loss is not supported.")}return e}getMetricIdentifiers(){if(typeof this.metrics=="string"||typeof this.metrics=="function")return[Nr(vl(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(e=>Nr(vl(e)));{const e={};for(const t in this.metrics)e[t]=Nr(vl(this.metrics[t]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(e.weighted_metrics!=null)throw new Error("Loading weight_metrics is not supported yet.");if(e.loss_weights!=null)throw new Error("Loading loss_weights is not supported yet.");if(e.sample_weight_mode!=null)throw new Error("Loading sample_weight_mode is not supported yet.");const t=Yl(e.optimizer_config),r=gr(t);let o;if(typeof e.loss=="string")o=Cs(e.loss);else if(Array.isArray(e.loss))o=e.loss.map(u=>Cs(u));else if(e.loss!=null){o={};for(const u in e.loss)o[u]=Cs(e.loss[u])}let a;if(Array.isArray(e.metrics))a=e.metrics.map(u=>Cs(u));else if(e.metrics!=null){a={};for(const u in e.metrics)a[u]=Cs(e.metrics[u])}this.compile({loss:o,metrics:a,optimizer:r})}async save(e,t){if(typeof e=="string"){const d=f2(e);if(d.length===0)throw new _(`Cannot find any save handlers for URL '${e}'`);if(d.length>1)throw new _(`Found more than one (${d.length}) save handlers for URL '${e}'`);e=d[0]}if(e.save==null)throw new _("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const r=await my(this.getNamedWeights(t)),c={modelTopology:this.toJSON(null,!1),format:GR,generatedBy:`TensorFlow.js tfjs-layers v${f1}`,convertedBy:null};if((t==null?!1:t.includeOptimizer)&&this.optimizer!=null){c.trainingConfig=this.getTrainingConfig();const d="optimizer",{data:m,specs:g}=await my(await this.optimizer.getWeights(),d);r.specs.push(...g),r.data=j0([r.data,m])}return this.userDefinedMetadata!=null&&(Jv(this.userDefinedMetadata,this.name,!0),c.userDefinedMetadata=this.userDefinedMetadata),c.weightData=r.data,c.weightSpecs=r.specs,e.save(c)}setUserDefinedMetadata(e){Jv(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}}Rs.className="Model";re(Rs);class y1 extends Rs{}y1.className="Functional";re(y1);async function qR(n,e){if(e==null&&(e={}),typeof n=="string"){const t=d2(n,e);if(t.length===0)t.push(F2(n,e));else if(t.length>1)throw new _(`Found more than one (${t.length}) load handlers for URL '${n}'`);n=t[0]}return HR(n,void 0,e)}async function HR(n,e,t){if(t==null&&(t={}),n.load==null)throw new _("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const r=await n.load();let o=r.modelTopology;o.model_config!=null&&(o=o.model_config);const a=t.strict==null?!0:t.strict,u=r.weightData!=null&&r.weightSpecs!=null&&a,c=gr(Yl(o),e,u),h=r.trainingConfig;if(h!=null&&c.loadTrainingConfig(h),r.userDefinedMetadata!=null&&c.setUserDefinedMetadata(r.userDefinedMetadata),r.weightData!=null){if(r.weightSpecs==null)throw new _("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");const{modelWeights:d,optimizerWeights:m}=KR(r.weightData,r.weightSpecs);c.loadWeights(d,a),c.optimizer!=null&&m.length>0&&await c.optimizer.setWeights(m),Me(d),Me(m.map(g=>g.tensor))}return c}function KR(n,e){const t=e2(n,e),r={},o=[];return e.forEach(a=>{a.group==="optimizer"?o.push({name:a.name,tensor:t[a.name]}):r[a.name]=t[a.name]}),{modelWeights:r,optimizerWeights:o}}class _i extends Rs{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=e.name!=null?e.name:uu("sequential_"),e.layers!=null)for(const t of e.layers)this.add(t)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some(r=>r<0))throw new _(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(e){const t=e instanceof _i||e instanceof Rs;let r;if(t){if(r=e,r.outputs.length!==1)throw new _("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(r.inputs.length!==1)throw new _("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(this.outputs.length===0){if(e.inboundNodes.length===0){if(e.batchInputShape==null)throw new _("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const o=jz({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(o)}if(t)this.outputs=r.outputs,this.inputs=r.inputs;else{if(e.inboundNodes.length!==1)throw new _(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);if(e.inboundNodes[0].outputTensors.length!==1)throw new _("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=Xb(this.outputs[0])}this.inboundNodes=[],new hu({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:Os(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(o=>o.shape),outputShapes:this.outputs[0].shape})}else{const o=e.apply(this.outputs[0]);if(Array.isArray(o))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[o],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(this.layers.length===0)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),this.layers.length===0)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,t){return this.model==null&&this.build(),this.model.call(e,t)}build(e){if(Ye(e),this.inputs.length===0||this.outputs.length===0)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new Rs({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,t,r=console.log){this.built||this.build(),super.summary(e,t,r)}setWeights(e){this.model==null&&this.build(),this.model.setWeights(e)}evaluate(e,t,r={}){if(!this.built)throw new $n("The model needs to be compiled before being used.");return this.model.evaluate(e,t,r)}async evaluateDataset(e,t){if(!this.built)throw new $n("The model needs to be compiled before being used.");return this.model.evaluateDataset(e,t)}predict(e,t={}){return this.model==null&&this.build(),this.model.predict(e,t)}predictOnBatch(e){return this.model==null&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return this.model==null?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}async fit(e,t,r={}){if(!this.built)throw new $n("The model needs to be compiled before being used.");return this.model.fit(e,t,r)}async fitDataset(e,t){if(!this.built)throw new $n("The model needs to be compiled before being used.");return this.model.fitDataset(e,t)}async trainOnBatch(e,t){return this.model.trainOnBatch(e,t)}static fromConfig(e,t,r={},o=!1){let a,u={};if(t instanceof Array){if(t[0].className==null||t[0].className==="Merge")throw new _("Legacy serialization format not supported yet.");a=t}else E(t.layers!=null,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),a=t.layers,delete t.layers,u=t;const c=new e(u);if(!(c instanceof _i))throw new Oe(`Sequential.fromConfig called on non-Sequential input: ${c}`);for(const h of a){const m=gr(h,void 0,o);o&&m.setFastWeightInitDuringBuild(!0),c.add(m)}return c}set stopTraining(e){if(this.model==null)throw new _("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(this.model==null)throw new _("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const e=[];for(const t of this.layers){const r={};r.className=t.getClassName(),r.config=t.getConfig(),e.push(r)}return{name:this.name,layers:e}}}_i.className="Sequential";re(_i);function v1(n){return new Rs(n)}function JR(n){return new _i(n)}function Hf(n,e){return e==null&&(e={}),qR(n,e)}let sn=class extends Oi{getConfig(){return{}}};class w1 extends sn{apply(e,t=1){return Nz(e,t)}}w1.className="elu";re(w1);class b1 extends sn{apply(e){return $N(e)}}b1.className="selu";re(b1);class k1 extends sn{apply(e){return Bi(e)}}k1.className="relu";re(k1);class S1 extends sn{apply(e){return V(()=>ob(6,Bi(e)))}}S1.className="relu6";re(S1);class x1 extends sn{apply(e){return e}}x1.className="linear";re(x1);class E1 extends sn{apply(e){return nu(e)}}E1.className="sigmoid";re(E1);class A1 extends sn{apply(e){return Dz(e)}}A1.className="hardSigmoid";re(A1);class I1 extends sn{apply(e){return vd(e)}}I1.className="softplus";re(I1);class T1 extends sn{apply(e){return Cz(e)}}T1.className="softsign";re(T1);class N1 extends sn{apply(e){return Y0(e)}}N1.className="tanh";re(N1);let Xd=class extends sn{apply(e,t=-1){return hb(e,t)}};Xd.className="softmax";re(Xd);class C1 extends sn{apply(e,t=-1){return LT(e,t)}}C1.className="logSoftmax";re(C1);class D1 extends sn{apply(e,t=1){return V(()=>P(nu(P(e,t)),e))}}D1.className="swish";re(D1);class z1 extends sn{apply(e){return V(()=>P(e,Y0(vd(e))))}}z1.className="mish";re(z1);function os(n){return n.getClassName()}function vf(n,e={}){return Ho(n,Dn.getMap().classNameMap,e,"activation")}function as(n){if(n==null){const e={};return e.className="linear",e.config={},vf(e)}if(typeof n=="string"){const e={};return e.className=n,e.config={},vf(e)}else return n instanceof sn?n:vf(n)}function XR(n){if(n!=null&&typeof n!="object")throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${n}`)}class $1 extends Oi{}class M1 extends $1{constructor(e){super(),XR(e),this.l1=e==null||e.l1==null?.01:e.l1,this.l2=e==null||e.l2==null?.01:e.l2,this.hasL1=this.l1!==0,this.hasL2=this.l2!==0}apply(e){return V(()=>{let t=Ot([1]);return this.hasL1&&(t=le(t,Ce(P(this.l1,Zt(e))))),this.hasL2&&(t=le(t,Ce(P(this.l2,Xo(e))))),J(t,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,t){return new e({l1:t.l1,l2:t.l2})}}M1.className="L1L2";re(M1);const tw={l1l2:"L1L2"};function Qe(n){return _d(n)}function nw(n,e={}){return Ho(n,Dn.getMap().classNameMap,e,"regularizer")}function ut(n){if(n==null)return null;if(typeof n=="string"){const t={className:n in tw?tw[n]:n,config:{}};return nw(t)}else return n instanceof $1?n:nw(n)}class R1 extends Ue{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null&&(this.maxValue=e.maxValue)}call(e,t){e=Fe(e);let r=Bi(e);return this.maxValue!=null&&(r=Mn(r,0,this.maxValue)),r}computeOutputShape(e){return e}getConfig(){const e={maxValue:this.maxValue},t=super.getConfig();return Object.assign(e,t),e}}R1.className="ReLU";re(R1);class _1 extends Ue{constructor(e){super(e??{}),this.DEFAULT_ALPHA=.3,e==null&&(e={}),this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){const r=Fe(e);return ib(r,this.alpha)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}}_1.className="LeakyReLU";re(_1);class F1 extends Ue{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA_INITIALIZER="zeros",e==null&&(e={}),this.supportsMasking=!0,this.alphaInitializer=lt(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=ut(e.alphaRegularizer),this.alphaConstraint=Tt(e.alphaConstraint),e.sharedAxes==null)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else if(typeof e.sharedAxes=="number")this.sharedAxes=[e.sharedAxes];else throw new _(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`)}build(e){e=Ye(e);const t=e.slice(1);if(this.sharedAxes!=null)for(const o of this.sharedAxes)t[o-1]=1;this.alpha=this.addWeight("alpha",t,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const r={};if(this.sharedAxes!=null)for(let o=1;o<e.length;++o)r[o]=e[o];this.inputSpec=[new At({ndim:e.length,axes:r})],this.built=!0}call(e,t){return e=Fe(e),lb(e,this.alpha.read())}getConfig(){const e={alphaInitializer:dt(this.alphaInitializer),alphaRegularizer:Qe(this.alphaRegularizer),alphaConstraint:It(this.alphaConstraint),sharedAxes:this.sharedAxes},t=super.getConfig();return Object.assign(e,t),e}}F1.className="PReLU";re(F1);class L1 extends Ue{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA=1,e==null&&(e={}),e.alpha!=null&&e.alpha!==this.DEFAULT_ALPHA)throw new Oe(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){const r=Fe(e);return md(r)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}}L1.className="ELU";re(L1);class O1 extends Ue{constructor(e){super(e??{}),this.DEFAULT_THETA=1,e==null&&(e={}),this.theta=e.theta==null?this.DEFAULT_THETA:e.theta}call(e,t){const r=Fe(e);return P(r,Se(er(r,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){const e={theta:this.theta},t=super.getConfig();return Object.assign(e,t),e}}O1.className="ThresholdedReLU";re(O1);class P1 extends Ue{constructor(e){super(e??{}),this.DEFAULT_AXIS=1,e==null&&(e={}),this.softmax=new Xd().apply,this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis}call(e,t){const r=Fe(e);return this.softmax(r,this.axis)}computeOutputShape(e){return e}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}P1.className="Softmax";re(P1);function Ei(n,e,t){if(typeof n=="number")return Os(n,e);if(n.length!==e)throw new _(`The ${t} argument must be an integer or tuple of ${e} integers. Received: ${n.length} elements.`);for(let r=0;r<e;++r){const o=n[r];if(!Ez(o))throw new _(`The ${t} argument must be an integer or tuple of ${e} integers. Received: ${JSON.stringify(n)} including a non-integer number ${o}`)}return n}function Jn(n,e,t,r,o=1){if(n==null)return n;const a=e+(e-1)*(o-1);let u;return t==="same"?u=n:u=n-a+1,Math.floor((u+r-1)/r)}function hr(n,e,t,r){if(n==null)return null;if(r==="valid")n=n*e+is([t-e,0]);else if(r==="same")n=n*e;else throw new _(`Unsupport padding mode: ${r}.`);return n}function Yd(n,e){return V(()=>(vt(e),e==="channelsFirst"?We(n,[0,2,3,1]):n))}function B1(n,e){return V(()=>(vt(e),e==="channelsFirst"?We(n,[0,2,3,4,1]):n))}function YR(n,e,t,r=1,o="valid",a,u=1){return V(()=>{if(a==null&&(a=Qn()),vt(a),n.shape.length!==3)throw new _(`The input of a conv1dWithBias operation should be 3, but is ${n.shape.length} instead.`);if(e.shape.length!==3)throw new _(`The kernel for a conv1dWithBias operation should be 3, but is ${e.shape.length} instead`);if(t!=null&&t.shape.length!==1)throw new _(`The bias for a conv1dWithBias operation should be 1, but is ${e.shape.length} instead`);if(a==="channelsFirst"&&(n=We(n,[0,2,1])),o==="causal")throw new Oe("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let c=jI(n,e,r,o==="same"?"same":"valid","NWC",u);return t!=null&&(c=tr(c,t)),c})}function rw(n,e,t,r=[1,1],o="valid",a,u,c=null){return V(()=>{if(a==null&&(a=Qn()),vt(a),n.rank!==3&&n.rank!==4)throw new _(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${n.rank}.`);if(e.rank!==3&&e.rank!==4)throw new _(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${n.rank}.`);let h=Yd(n,a);if(o==="causal")throw new Oe("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return h=iC({x:h,filter:e,strides:r,pad:o==="same"?"same":"valid",dilations:u,dataFormat:"NHWC",bias:t,activation:c}),a==="channelsFirst"&&(h=We(h,[0,3,1,2])),h})}function ZR(n,e,t,r=[1,1,1],o="valid",a,u){return V(()=>{if(a==null&&(a=Qn()),vt(a),n.rank!==4&&n.rank!==5)throw new _(`conv3dWithBias expects input to be of rank 4 or 5, but received ${n.rank}.`);if(e.rank!==4&&e.rank!==5)throw new _(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${n.rank}.`);let c=B1(n,a);if(o==="causal")throw new Oe("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return c=HI(c,e,r,o==="same"?"same":"valid","NDHWC",u),t!=null&&(c=tr(c,t)),a==="channelsFirst"&&(c=We(c,[0,4,1,2,3])),c})}class pu extends Ue{constructor(e,t){if(super(t),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",pu.verifyArgs(t),this.rank=e,Mt(this.rank,"rank"),this.rank!==1&&this.rank!==2&&this.rank!==3)throw new Oe(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=Ei(t.kernelSize,e,"kernelSize"),this.strides=Ei(t.strides==null?1:t.strides,e,"strides"),this.padding=t.padding==null?"valid":t.padding,bn(this.padding),this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,vt(this.dataFormat),this.activation=as(t.activation),this.useBias=t.useBias==null?!0:t.useBias,this.biasInitializer=lt(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=Tt(t.biasConstraint),this.biasRegularizer=ut(t.biasRegularizer),this.activityRegularizer=ut(t.activityRegularizer),this.dilationRate=Ei(t.dilationRate==null?1:t.dilationRate,e,"dilationRate"),this.rank===1&&Array.isArray(this.dilationRate)&&this.dilationRate.length!==1)throw new _(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(this.rank===2){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==2)throw new _(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(this.rank===3){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==3)throw new _(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}}static verifyArgs(e){if(cr("kernelSize"in e,"required key 'kernelSize' not in config"),typeof e.kernelSize!="number"&&!Fd(e.kernelSize,"number",1,3))throw new _(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(e.kernelSize)}.`)}getConfig(){const e={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:os(this.activation),useBias:this.useBias,biasInitializer:dt(this.biasInitializer),biasRegularizer:Qe(this.biasRegularizer),activityRegularizer:Qe(this.activityRegularizer),biasConstraint:It(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}class ji extends pu{constructor(e,t){super(e,t),this.kernel=null,ji.verifyArgs(t),this.filters=t.filters,Mt(this.filters,"filters"),this.kernelInitializer=lt(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=Tt(t.kernelConstraint),this.kernelRegularizer=ut(t.kernelRegularizer)}build(e){e=Ye(e);const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new _(`The channel dimension of the input should be defined. Found ${e[t]}`);const r=e[t],o=this.kernelSize.concat([r,this.filters]);this.kernel=this.addWeight("kernel",o,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[t]:r}}],this.built=!0}call(e,t){return V(()=>{e=Fe(e);let r;const o=this.bias==null?null:this.bias.read(),a=_b(this.activation.getClassName());if(a!=null&&this.rank===2)r=rw(e,this.kernel.read(),o,this.strides,this.padding,this.dataFormat,this.dilationRate,a);else{if(this.rank===1)r=YR(e,this.kernel.read(),o,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(this.rank===2)r=rw(e,this.kernel.read(),o,this.strides,this.padding,this.dataFormat,this.dilationRate);else if(this.rank===3)r=ZR(e,this.kernel.read(),o,this.strides,this.padding,this.dataFormat,this.dilationRate);else throw new Oe("convolutions greater than 3D are not implemented yet.");this.activation!=null&&(r=this.activation.apply(r))}return r})}computeOutputShape(e){e=Ye(e);const t=[],r=this.dataFormat==="channelsLast"?e.slice(1,e.length-1):e.slice(2);for(let a=0;a<r.length;++a){const u=Jn(r[a],this.kernelSize[a],this.padding,this.strides[a],typeof this.dilationRate=="number"?this.dilationRate:this.dilationRate[a]);t.push(u)}let o=[e[0]];return this.dataFormat==="channelsLast"?(o=o.concat(t),o.push(this.filters)):(o.push(this.filters),o=o.concat(t)),o}getConfig(){const e={filters:this.filters,kernelInitializer:dt(this.kernelInitializer),kernelRegularizer:Qe(this.kernelRegularizer),kernelConstraint:It(this.kernelConstraint)},t=super.getConfig();return Object.assign(e,t),e}static verifyArgs(e){if(!("filters"in e)||typeof e.filters!="number"||e.filters<1)throw new _(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(e.filters)}`)}}class ea extends ji{constructor(e){super(2,e),ea.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!Fd(e.kernelSize,"number",1,2))throw new _(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}}ea.className="Conv2D";re(ea);class ta extends ji{constructor(e){super(3,e),ta.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!(Array.isArray(e.kernelSize)&&(e.kernelSize.length===1||e.kernelSize.length===3)))throw new _(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}}ta.className="Conv3D";re(ta);class U1 extends ea{constructor(e){if(super(e),this.inputSpec=[new At({ndim:4})],this.padding!=="same"&&this.padding!=="valid")throw new _(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=Ye(e),e.length!==4)throw new _("Input should have rank 4; Received input shape: "+JSON.stringify(e));const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new _("The channel dimension of the inputs should be defined. Found `None`.");const r=e[t],o=this.kernelSize.concat([this.filters,r]);this.kernel=this.addWeight("kernel",o,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new At({ndim:4,axes:{[t]:r}})],this.built=!0}call(e,t){return V(()=>{let r=Fe(e);if(r.shape.length!==4)throw new _(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${r.shape.length}`);const o=r.shape,a=o[0];let u,c;this.dataFormat==="channelsFirst"?(u=2,c=3):(u=1,c=2);const h=o[u],d=o[c],m=this.kernelSize[0],g=this.kernelSize[1],v=this.strides[0],w=this.strides[1],k=hr(h,v,m,this.padding),S=hr(d,w,g,this.padding),x=[a,k,S,this.filters];this.dataFormat!=="channelsLast"&&(r=We(r,[0,2,3,1]));let T=GI(r,this.kernel.read(),x,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(T=We(T,[0,3,1,2])),this.bias!=null&&(T=tr(T,this.bias.read(),this.dataFormat)),this.activation!=null&&(T=this.activation.apply(T)),T})}computeOutputShape(e){e=Ye(e);const t=e.slice();let r,o,a;this.dataFormat==="channelsFirst"?(r=1,o=2,a=3):(r=3,o=1,a=2);const u=this.kernelSize[0],c=this.kernelSize[1],h=this.strides[0],d=this.strides[1];return t[r]=this.filters,t[o]=hr(t[o],h,u,this.padding),t[a]=hr(t[a],d,c,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}U1.className="Conv2DTranspose";re(U1);class j1 extends ta{constructor(e){if(super(e),this.inputSpec=[new At({ndim:5})],this.padding!=="same"&&this.padding!=="valid")throw new _(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=Ye(e),e.length!==5)throw new _("Input should have rank 5; Received input shape: "+JSON.stringify(e));const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new _("The channel dimension of the inputs should be defined. Found `None`.");const r=e[t],o=this.kernelSize.concat([this.filters,r]);this.kernel=this.addWeight("kernel",o,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new At({ndim:5,axes:{[t]:r}})],this.built=!0}call(e,t){return V(()=>{let r=Fe(e);if(r.shape.length!==5)throw new _(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${r.shape.length}`);const o=r.shape,a=o[0];let u,c,h;this.dataFormat==="channelsFirst"?(h=2,u=3,c=4):(h=1,u=2,c=3);const d=o[h],m=o[u],g=o[c],v=this.kernelSize[0],w=this.kernelSize[1],k=this.kernelSize[2],S=this.strides[0],x=this.strides[1],T=this.strides[2],z=hr(d,S,v,this.padding),R=hr(m,x,w,this.padding),$=hr(g,T,k,this.padding),B=[a,z,R,$,this.filters];this.dataFormat!=="channelsLast"&&(r=We(r,[0,2,3,4,1]));let H=XI(r,this.kernel.read(),B,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(H=We(H,[0,4,1,2,3])),this.bias!==null&&(H=tr(H,this.bias.read(),this.dataFormat)),this.activation!==null&&(H=this.activation.apply(H)),H})}computeOutputShape(e){e=Ye(e);const t=e.slice();let r,o,a,u;this.dataFormat==="channelsFirst"?(r=1,o=2,a=3,u=4):(r=4,o=1,a=2,u=3);const c=this.kernelSize[0],h=this.kernelSize[1],d=this.kernelSize[2],m=this.strides[0],g=this.strides[1],v=this.strides[2];return t[r]=this.filters,t[o]=hr(t[o],m,c,this.padding),t[a]=hr(t[a],g,h,this.padding),t[u]=hr(t[u],v,d,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}j1.className="Conv3DTranspose";re(j1);class W1 extends ji{constructor(e,t){if(super(e,t),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,t.filters==null)throw new _("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(t.kernelInitializer!=null||t.kernelRegularizer!=null||t.kernelConstraint!=null)throw new _("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(t.padding!=null&&t.padding!=="same"&&t.padding!=="valid")throw new _(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(t.padding)}`);this.depthMultiplier=t.depthMultiplier==null?1:t.depthMultiplier,this.depthwiseInitializer=lt(t.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=ut(t.depthwiseRegularizer),this.depthwiseConstraint=Tt(t.depthwiseConstraint),this.pointwiseInitializer=lt(t.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=ut(t.pointwiseRegularizer),this.pointwiseConstraint=Tt(t.pointwiseConstraint)}build(e){if(e=Ye(e),e.length<this.rank+2)throw new _(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null||e[t]<0)throw new _(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[t])}`);const r=e[t],o=this.kernelSize.concat([r,this.depthMultiplier]),a=[];for(let c=0;c<this.rank;++c)a.push(1);a.push(r*this.depthMultiplier,this.filters);const u=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",o,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,u,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",a,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,u,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,u,this.biasConstraint):this.bias=null,this.inputSpec=[new At({ndim:this.rank+2,axes:{[t]:r}})],this.built=!0}call(e,t){return V(()=>{e=Fe(e);let r;if(this.rank===1)throw new Oe("1D separable convolution is not implemented yet.");return this.rank===2&&(this.dataFormat==="channelsFirst"&&(e=We(e,[0,2,3,1])),r=RN(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(r=tr(r,this.bias.read(),this.dataFormat)),this.activation!=null&&(r=this.activation.apply(r)),this.dataFormat==="channelsFirst"&&(r=We(r,[0,3,1,2])),r})}getConfig(){const e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=dt(this.depthwiseInitializer),e.pointwiseInitializer=dt(this.pointwiseInitializer),e.depthwiseRegularizer=Qe(this.depthwiseRegularizer),e.pointwiseRegularizer=Qe(this.pointwiseRegularizer),e.depthwiseConstraint=It(this.depthwiseConstraint),e.pointwiseConstraint=It(this.pointwiseConstraint),e}}W1.className="SeparableConv";class V1 extends W1{constructor(e){super(2,e)}}V1.className="SeparableConv2D";re(V1);class mu extends ji{constructor(e){super(1,e),mu.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){const e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!Fd(e.kernelSize,"number",1,1))throw new _(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}}mu.className="Conv1D";re(mu);class G1 extends Ue{constructor(e){super(e),typeof e.cropping=="number"?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:typeof e.cropping[0]=="number"?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=e.dataFormat===void 0?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return this.dataFormat==="channelsFirst"?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,t){return V(()=>{if(e=Fe(e),this.dataFormat==="channelsLast"){const r=yl(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return yl(r,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}else{const r=yl(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return yl(r,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){const e={cropping:this.cropping,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}G1.className="Cropping2D";re(G1);class q1 extends Ue{constructor(e){super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=e.size==null?this.DEFAULT_SIZE:e.size,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,vt(this.dataFormat),this.interpolation=e.interpolation==null?"nearest":e.interpolation,kz(this.interpolation)}computeOutputShape(e){if(this.dataFormat==="channelsFirst"){const t=e[2]==null?null:this.size[0]*e[2],r=e[3]==null?null:this.size[1]*e[3];return[e[0],e[1],t,r]}else{const t=e[1]==null?null:this.size[0]*e[1],r=e[2]==null?null:this.size[1]*e[2];return[e[0],t,r,e[3]]}}call(e,t){return V(()=>{let r=Fe(e);const o=r.shape;if(this.dataFormat==="channelsFirst"){r=We(r,[0,2,3,1]);const a=this.size[0]*o[2],u=this.size[1]*o[3],c=this.interpolation==="nearest"?fl.resizeNearestNeighbor(r,[a,u]):fl.resizeBilinear(r,[a,u]);return We(c,[0,3,1,2])}else{const a=this.size[0]*o[1],u=this.size[1]*o[2];return this.interpolation==="nearest"?fl.resizeNearestNeighbor(r,[a,u]):fl.resizeBilinear(r,[a,u])}})}getConfig(){const e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}}q1.className="UpSampling2D";re(q1);function QR(n,e,t=[1,1],r="valid",o,a){return V(()=>{o==null&&(o=Qn()),vt(o);let u=Yd(n,o);if(n.rank!==4)throw new _(`Input for depthwiseConv2d is required to be 4-D, but is instead ${n.rank}-D`);if(e.rank!==4)throw new _(`depthwiseKernel is required to be 4-D, but is instead ${e.rank}-D`);return u=eb(u,e,t,r==="same"?"same":"valid","NHWC",a),o==="channelsFirst"&&(u=We(u,[0,3,1,2])),u})}class H1 extends pu{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=e.depthMultiplier==null?1:e.depthMultiplier,this.depthwiseInitializer=lt(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=Tt(e.depthwiseConstraint),this.depthwiseRegularizer=ut(e.depthwiseRegularizer)}build(e){if(e=Ye(e),e.length<4)throw new _(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);const t=this.dataFormat==="channelsFirst"?1:3;if(e[t]==null||e[t]<0)throw new _(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[t]}).`);const r=e[t],o=[this.kernelSize[0],this.kernelSize[1],r,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",o,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[r*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return V(()=>{e=Fe(e);let r=QR(e,this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(r=tr(r,this.bias.read(),this.dataFormat)),this.activation!=null&&(r=this.activation.apply(r)),r})}computeOutputShape(e){e=Ye(e);const t=this.dataFormat==="channelsFirst"?e[2]:e[1],r=this.dataFormat==="channelsFirst"?e[3]:e[2],o=this.dataFormat==="channelsFirst"?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,a=Jn(t,this.kernelSize[0],this.padding,this.strides[0]),u=Jn(r,this.kernelSize[1],this.padding,this.strides[1]);return this.dataFormat==="channelsFirst"?[e[0],o,a,u]:[e[0],a,u,o]}getConfig(){const e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=dt(this.depthwiseInitializer),e.depthwiseRegularizer=Qe(this.depthwiseRegularizer),e.depthwiseConstraint=It(this.depthwiseRegularizer),e}}H1.className="DepthwiseConv2D";re(H1);function K1(n,e,t,r){if(Array.isArray(n)){if(e!=null||t!=null)throw new _("When inputs is an array, neither initialState or constants should be provided");r!=null&&(t=n.slice(n.length-r,n.length),n=n.slice(0,n.length-r)),n.length>1&&(e=n.slice(1,n.length)),n=n[0]}function o(a){return a==null||Array.isArray(a)?a:[a]}return e=o(e),t=o(t),{inputs:n,initialState:e,constants:t}}function J1(n,e,t,r=!1,o,a,u=!1,c=!1){return V(()=>{const h=e.shape.length;if(h<3)throw new _(`Input should be at least 3D, but is ${h}D.`);const d=[1,0].concat(Zn(2,h));e=We(e,d),u&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),o!=null&&(o=Se(Se(o,"bool"),"float32"),o.rank===h-1&&(o=qn(o,-1)),o=We(o,d)),r&&(e=Pl(e,0),o!=null&&(o=Pl(o,0)));const m=[];let g,v=t;const w=e.shape[0],k=$i(e);let S;o!=null&&(S=$i(o));for(let T=0;T<w;++T){const z=k[T],R=V(()=>n(z,v));if(o==null)g=R[0],v=R[1];else{const $=V(()=>{const B=S[T],H=Re(Yn(B),B),Y=le(P(R[0],B),P(v[0],H)),Z=v.map((ne,oe)=>le(P(R[1][oe],B),P(ne,H)));return{output:Y,newStates:Z}});g=$.output,v=$.newStates}c&&m.push(g)}let x;return c&&(x=ss(m,1)),[g,x,v]})}class cs extends Ue{constructor(e){super(e);let t;if(e.cell==null)throw new _("cell property is missing for the constructor of RNN.");if(Array.isArray(e.cell)?t=new ep({cells:e.cell}):t=e.cell,t.stateSize==null)throw new _("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=t,this.returnSequences=e.returnSequences==null?!1:e.returnSequences,this.returnState=e.returnState==null?!1:e.returnState,this.goBackwards=e.goBackwards==null?!1:e.goBackwards,this._stateful=e.stateful==null?!1:e.stateful,this.unroll=e.unroll==null?!1:e.unroll,this.supportsMasking=!0,this.inputSpec=[new At({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(this.states_==null){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return Zn(0,e).map(t=>null)}else return this.states_}setStates(e){this.states_=e}computeOutputShape(e){Bf(e)&&(e=e[0]),e=e;let t=this.cell.stateSize;Array.isArray(t)||(t=[t]);const r=t[0];let o;if(this.returnSequences?o=[e[0],e[1],r]:o=[e[0],r],this.returnState){const a=[];for(const u of t)a.push([e[0],u]);return[o].concat(a)}else return o}computeMask(e,t){return V(()=>{Array.isArray(t)&&(t=t[0]);const r=this.returnSequences?t:null;if(this.returnState){const o=this.states.map(a=>null);return[r].concat(o)}else return r})}get states(){if(this.states_==null){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,t=[];for(let r=0;r<e;++r)t.push(null);return t}else return this.states_}set states(e){this.states_=e}build(e){if(this.numConstants!=null)throw new Oe("Constants support is not implemented in RNN yet.");Bf(e)&&(e=e[0]),e=e;const t=this.stateful?e[0]:null,r=e.slice(2);this.inputSpec[0]=new At({shape:[t,null,...r]});const o=[e[0]].concat(e.slice(2));this.cell.build(o);let a;if(Array.isArray(this.cell.stateSize)?a=this.cell.stateSize:a=[this.cell.stateSize],this.stateSpec!=null){if(!nn(this.stateSpec.map(u=>u.shape[u.shape.length-1]),a))throw new _(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=a.map(u=>new At({shape:[null,u]}));this.stateful&&this.resetStates()}resetStates(e,t=!1){V(()=>{if(!this.stateful)throw new ur("Cannot call resetStates() on an RNN Layer that is not stateful.");const r=this.inputSpec[0].shape[0];if(r==null)throw new _("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.states_==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(o=>Ot([r,o])):this.states_=[Ot([r,this.cell.stateSize])];else if(e==null)Me(this.states_),this.keptStates!=null&&(Me(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(o=>Ot([r,o])):this.states_[0]=Ot([r,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new _(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t===!0?this.keptStates.push(this.states_.slice()):Me(this.states_);for(let o=0;o<this.states_.length;++o){const a=e[o],u=Array.isArray(this.cell.stateSize)?this.cell.stateSize[o]:this.cell.stateSize,c=[r,u];if(!nn(a.shape,c))throw new _(`State ${o} is incompatible with layer ${this.name}: expected shape=${c}, received shape=${a.shape}`);this.states_[o]=a}}this.states_=this.states_.map(o=>yr(o.clone()))})}apply(e,t){let r=t==null?null:t.initialState,o=t==null?null:t.constants;t==null&&(t={});const a=K1(e,r,o,this.numConstants);e=a.inputs,r=a.initialState,o=a.constants;let u=[],c=[];if(r!=null){t.initialState=r,u=u.concat(r),this.stateSpec=[];for(const d of r)this.stateSpec.push(new At({shape:d.shape}));c=c.concat(this.stateSpec)}if(o!=null&&(t.constants=o,u=u.concat(o),this.numConstants=o.length),u[0]instanceof dr){const d=[e].concat(u),m=this.inputSpec.concat(c),g=this.inputSpec;this.inputSpec=m;const v=super.apply(d,t);return this.inputSpec=g,v}else return super.apply(e,t)}call(e,t){return V(()=>{const r=t==null?null:t.mask,o=t==null?null:t.training;let a=t==null?null:t.initialState;e=Fe(e),a==null&&(this.stateful?a=this.states_:a=this.getInitialState(e));const u=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(a.length!==u)throw new _(`RNN Layer has ${u} state(s) but was passed ${a.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const c={training:o},d=J1((k,S)=>{const x=this.cell.call([k].concat(S),c);return[x[0],x.slice(1)]},e,a,this.goBackwards,r,null,this.unroll,this.returnSequences),m=d[0],g=d[1],v=d[2];this.stateful&&this.resetStates(v,o);const w=this.returnSequences?g:m;return this.returnState?[w].concat(v):w})}getInitialState(e){return V(()=>{let t=Ot(e.shape);return t=Ce(t,[1,2]),t=Jo(t),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(r=>r>1?Of(t,[1,r]):t):this.cell.stateSize>1?[Of(t,[1,this.cell.stateSize])]:[t]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.cell!=null&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){const e=super.getConfig(),t={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};this.numConstants!=null&&(t.numConstants=this.numConstants);const r=this.cell.getConfig();return this.getClassName()===cs.className&&(t.cell={className:this.cell.getClassName(),config:r}),Object.assign({},r,e,t)}static fromConfig(e,t,r={}){const o=t.cell,a=gr(o,r);return new e(Object.assign(t,{cell:a}))}}cs.className="RNN";re(cs);class gu extends Ue{}class Zd extends gu{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,Mt(this.units,"units"),this.activation=as(e.activation==null?this.DEFAULT_ACTIVATION:e.activation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=lt(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=lt(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=lt(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=ut(e.kernelRegularizer),this.recurrentRegularizer=ut(e.recurrentRegularizer),this.biasRegularizer=ut(e.biasRegularizer),this.kernelConstraint=Tt(e.kernelConstraint),this.recurrentConstraint=Tt(e.recurrentConstraint),this.biasConstraint=Tt(e.biasConstraint),this.dropout=Ri([1,is([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=Ri([1,is([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=Ye(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return V(()=>{if(e=e,e.length!==2)throw new _(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let r=e[1];e=e[0];const o=t.training==null?!1:t.training;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=ls({ones:()=>Yn(e),rate:this.dropout,training:o,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=ls({ones:()=>Yn(r),rate:this.recurrentDropout,training:o,dropoutFunc:this.dropoutFunc}));let a;const u=this.dropoutMask,c=this.recurrentDropoutMask;u!=null?a=mr(P(e,u),this.kernel.read()):a=mr(e,this.kernel.read()),this.bias!=null&&(a=tr(a,this.bias.read())),c!=null&&(r=P(r,c));let h=le(a,mr(r,this.recurrentKernel.read()));return this.activation!=null&&(h=this.activation.apply(h)),[h,h]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:os(this.activation),useBias:this.useBias,kernelInitializer:dt(this.kernelInitializer),recurrentInitializer:dt(this.recurrentInitializer),biasInitializer:dt(this.biasInitializer),kernelRegularizer:Qe(this.kernelRegularizer),recurrentRegularizer:Qe(this.recurrentRegularizer),biasRegularizer:Qe(this.biasRegularizer),activityRegularizer:Qe(this.activityRegularizer),kernelConstraint:It(this.kernelConstraint),recurrentConstraint:It(this.recurrentConstraint),biasConstraint:It(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign({},e,t)}}Zd.className="SimpleRNNCell";re(Zd);class X1 extends cs{constructor(e){e.cell=new Zd(e),super(e)}call(e,t){return V(()=>{this.cell.dropoutMask!=null&&(Me(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Me(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const r=t==null?null:t.mask,o=t==null?null:t.training,a=t==null?null:t.initialState;return super.call(e,{mask:r,training:o,initialState:a})})}static fromConfig(e,t){return new e(t)}}X1.className="SimpleRNN";re(X1);class Qd extends gu{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new _("GRUCell does not support reset_after parameter set to true.");this.units=e.units,Mt(this.units,"units"),this.activation=as(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=as(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=lt(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=lt(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=lt(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=ut(e.kernelRegularizer),this.recurrentRegularizer=ut(e.recurrentRegularizer),this.biasRegularizer=ut(e.biasRegularizer),this.kernelConstraint=Tt(e.kernelConstraint),this.recurrentConstraint=Tt(e.recurrentConstraint),this.biasConstraint=Tt(e.biasConstraint),this.dropout=Ri([1,is([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=Ri([1,is([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=Ye(e);const t=e[e.length-1];this.kernel=this.addWeight("kernel",[t,this.units*3],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*3],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units*3],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return V(()=>{if(e=e,e.length!==2)throw new _(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);const r=t.training==null?!1:t.training;let o=e[1];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=ls({ones:()=>Yn(e),rate:this.dropout,training:r,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=ls({ones:()=>Yn(o),rate:this.recurrentDropout,training:r,count:3,dropoutFunc:this.dropoutFunc}));const a=this.dropoutMask,u=this.recurrentDropoutMask;let c,h,d;0<this.dropout&&this.dropout<1&&(e=P(e,a[0]));let m=mr(e,this.kernel.read());this.useBias&&(m=tr(m,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(o=P(o,u[0]));const g=this.recurrentKernel.read(),[v,w]=pr(g,[2*this.units,this.units],g.rank-1),k=mr(o,v),[S,x,T]=pr(m,3,m.rank-1),[z,R]=pr(k,2,k.rank-1);c=this.recurrentActivation.apply(le(S,z)),h=this.recurrentActivation.apply(le(x,R));const $=mr(P(h,o),w);d=this.activation.apply(le(T,$));const B=le(P(c,o),P(le(1,Wt(c)),d));return[B,B]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:os(this.activation),recurrentActivation:os(this.recurrentActivation),useBias:this.useBias,kernelInitializer:dt(this.kernelInitializer),recurrentInitializer:dt(this.recurrentInitializer),biasInitializer:dt(this.biasInitializer),kernelRegularizer:Qe(this.kernelRegularizer),recurrentRegularizer:Qe(this.recurrentRegularizer),biasRegularizer:Qe(this.biasRegularizer),activityRegularizer:Qe(this.activityRegularizer),kernelConstraint:It(this.kernelConstraint),recurrentConstraint:It(this.recurrentConstraint),biasConstraint:It(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign({},e,t)}}Qd.className="GRUCell";re(Qd);class Y1 extends cs{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new Qd(e),super(e)}call(e,t){return V(()=>{this.cell.dropoutMask!=null&&(Me(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Me(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const r=t==null?null:t.mask,o=t==null?null:t.training,a=t==null?null:t.initialState;return super.call(e,{mask:r,training:o,initialState:a})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}}Y1.className="GRU";re(Y1);class yu extends gu{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,Mt(this.units,"units"),this.activation=as(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=as(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=lt(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=lt(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=lt(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=ut(e.kernelRegularizer),this.recurrentRegularizer=ut(e.recurrentRegularizer),this.biasRegularizer=ut(e.biasRegularizer),this.kernelConstraint=Tt(e.kernelConstraint),this.recurrentConstraint=Tt(e.recurrentConstraint),this.biasConstraint=Tt(e.biasConstraint),this.dropout=Ri([1,is([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=Ri([1,is([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var t;e=Ye(e);const r=e[e.length-1];this.kernel=this.addWeight("kernel",[r,this.units*4],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*4],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint);let o;if(this.useBias){if(this.unitForgetBias){const a=this.biasInitializer,u=this.units;o=new(t=class extends _n{apply(h,d){const m=a.apply([u]),g=new Od().apply([u]),v=a.apply([u*2]);return Rv(Rv(m,g),v)}},t.className="CustomInit",t)}else o=this.biasInitializer;this.bias=this.addWeight("bias",[this.units*4],null,o,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,t){return V(()=>{const r=t.training==null?!1:t.training;if(e=e,e.length!==3)throw new _(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let o=e[1];const a=e[2];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=ls({ones:()=>Yn(e),rate:this.dropout,training:r,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=ls({ones:()=>Yn(o),rate:this.recurrentDropout,training:r,count:4,dropoutFunc:this.dropoutFunc}));const u=this.dropoutMask,c=this.recurrentDropoutMask;let h,d,m,g;0<this.dropout&&this.dropout<1&&(e=P(e,u[0]));let v=mr(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(o=P(o,c[0])),v=le(v,mr(o,this.recurrentKernel.read())),this.useBias&&(v=tr(v,this.bias.read()));const[w,k,S,x]=pr(v,4,v.rank-1);h=this.recurrentActivation.apply(w),d=this.recurrentActivation.apply(k),m=le(P(d,a),P(h,this.activation.apply(S))),g=this.recurrentActivation.apply(x);const T=P(g,this.activation.apply(m));return[T,T,m]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:os(this.activation),recurrentActivation:os(this.recurrentActivation),useBias:this.useBias,kernelInitializer:dt(this.kernelInitializer),recurrentInitializer:dt(this.recurrentInitializer),biasInitializer:dt(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:Qe(this.kernelRegularizer),recurrentRegularizer:Qe(this.recurrentRegularizer),biasRegularizer:Qe(this.biasRegularizer),activityRegularizer:Qe(this.activityRegularizer),kernelConstraint:It(this.kernelConstraint),recurrentConstraint:It(this.recurrentConstraint),biasConstraint:It(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign({},e,t)}}yu.className="LSTMCell";re(yu);class Z1 extends cs{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new yu(e),super(e)}call(e,t){return V(()=>{this.cell.dropoutMask!=null&&(Me(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Me(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const r=t==null?null:t.mask,o=t==null?null:t.training,a=t==null?null:t.initialState;return super.call(e,{mask:r,training:o,initialState:a})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}}Z1.className="LSTM";re(Z1);class ep extends gu{constructor(e){super(e),this.cells=e.cells}get stateSize(){const e=[];for(const t of this.cells.slice().reverse())Array.isArray(t.stateSize)?e.push(...t.stateSize):e.push(t.stateSize);return e}call(e,t){return V(()=>{e=e;let r=e.slice(1);const o=[];for(const c of this.cells.slice().reverse())Array.isArray(c.stateSize)?o.push(r.splice(0,c.stateSize.length)):o.push(r.splice(0,1));o.reverse();const a=[];let u;for(let c=0;c<this.cells.length;++c){const h=this.cells[c];r=o[c],c===0?u=[e[0]].concat(r):u=[u[0]].concat(r),u=h.call(u,t),a.push(u.slice(1))}r=[];for(const c of a.slice().reverse())r.push(...c);return[u[0]].concat(r)})}build(e){Bf(e)&&(e=e[0]),e=e;let t;this.cells.forEach((r,o)=>{$s(`RNNCell_${o}`,()=>{r.build(e),Array.isArray(r.stateSize)?t=r.stateSize[0]:t=r.stateSize,e=[e[0],t]})}),this.built=!0}getConfig(){const e=super.getConfig(),t=a=>({className:a.getClassName(),config:a.getConfig()}),o={cells:this.cells.map(t)};return Object.assign({},e,o)}static fromConfig(e,t,r={}){const o=[];for(const a of t.cells)o.push(gr(a,r));return new e({cells:o})}get trainableWeights(){if(!this.trainable)return[];const e=[];for(const t of this.cells)e.push(...t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.cells)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const r of this.cells)t.push(...r.trainableWeights);return t.concat(e)}return e}getWeights(){const e=[];for(const t of this.cells)e.push(...t.weights);return Uf(e)}setWeights(e){const t=[];for(const r of this.cells){const o=r.weights.length,a=e.splice(o);for(let u=0;u<r.weights.length;++u)t.push([r.weights[u],a[u]])}Gd(t)}}ep.className="StackedRNNCells";re(ep);function ls(n){const{ones:e,rate:t,training:r=!1,count:o=1,dropoutFunc:a}=n,u=()=>a!=null?a(e(),t):jb(e(),t),c=()=>Yo(u,e,r);return!o||o<=1?yr(c().clone()):Array(o).fill(void 0).map(c).map(d=>yr(d.clone()))}var e_=function(n,e){var t={};for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&e.indexOf(r)<0&&(t[r]=n[r]);if(n!=null&&typeof Object.getOwnPropertySymbols=="function")for(var o=0,r=Object.getOwnPropertySymbols(n);o<r.length;o++)e.indexOf(r[o])<0&&Object.prototype.propertyIsEnumerable.call(n,r[o])&&(t[r[o]]=n[r[o]]);return t};class Q1 extends cs{constructor(e){if(e.unroll)throw new Oe("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new Oe("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new At({ndim:5})]}call(e,t){return V(()=>{if(this.cell.dropoutMask!=null&&(Me(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(Me(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),t&&t.constants)throw new _("ConvRNN2D cell does not support constants");const r=t==null?null:t.mask,o=t==null?null:t.training,a=t==null?null:t.initialState;return super.call(e,{mask:r,training:o,initialState:a})})}computeOutputShape(e){let t=this.computeSingleOutputShape(e);return this.returnSequences||(t=[t[0],...t.slice(2)]),this.returnState&&(t=[t,...Array(2).fill([e[0],...t.slice(-3)])]),t}getInitialState(e){return V(()=>{const{stateSize:t}=this.cell,r=e.shape,o=this.computeSingleOutputShape(r),a=[o[0],...o.slice(2)],u=Ot(a);return Array.isArray(t)?Array(t.length).fill(u):[u]})}resetStates(e,t=!1){V(()=>{if(!this.stateful)throw new ur("Cannot call resetStates() on an RNN Layer that is not stateful.");const r=this.inputSpec[0].shape,o=this.computeSingleOutputShape(r),a=[o[0],...o.slice(2)];if(r[0]==null)throw new _("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.getStates()==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>Ot(a)):this.states_=[Ot(a)];else if(e==null)Me(this.states_),this.keptStates!=null&&(Me(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>Ot(a)):this.states_[0]=Ot(a);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new _(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t?this.keptStates.push(this.states_.slice()):Me(this.states_);for(let c=0;c<this.states_.length;++c){const h=e[c],d=a;if(!nn(h.shape,d))throw new _(`State ${c} is incompatible with layer ${this.name}: expected shape=${d}, received shape=${h.shape}`);this.states_[c]=h}}this.states_=this.states_.map(c=>yr(c.clone()))})}computeSingleOutputShape(e){const{dataFormat:t,filters:r,kernelSize:o,padding:a,strides:u,dilationRate:c}=this.cell,h=t==="channelsFirst",d=e[h?3:2],m=e[h?4:3],g=Jn(d,o[0],a,u[0],c[0]),v=Jn(m,o[1],a,u[1],c[1]);return[...e.slice(0,2),...h?[r,g,v]:[g,v,r]]}}Q1.className="ConvRNN2D";class tp extends yu{constructor(e){const{filters:t,kernelSize:r,strides:o,padding:a,dataFormat:u,dilationRate:c}=e;super(Object.assign({},e,{units:t})),this.filters=t,Mt(this.filters,"filters"),this.kernelSize=Ei(r,2,"kernelSize"),this.kernelSize.forEach(h=>Mt(h,"kernelSize")),this.strides=Ei(o||1,2,"strides"),this.strides.forEach(h=>Mt(h,"strides")),this.padding=a||"valid",bn(this.padding),this.dataFormat=u||"channelsLast",vt(this.dataFormat),this.dilationRate=Ei(c||1,2,"dilationRate"),this.dilationRate.forEach(h=>Mt(h,"dilationRate"))}build(e){var t;e=Ye(e);const r=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[r]==null)throw new _(`The channel dimension of the input should be defined. Found ${e[r]}`);const o=e[r],a=4,u=this.kernelSize.concat([o,this.filters*a]);this.kernel=this.addWeight("kernel",u,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const c=this.kernelSize.concat([this.filters,this.filters*a]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",c,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let h;if(this.unitForgetBias){const d=this.biasInitializer,m=this.filters;h=new(t=class extends _n{apply(v,w){const k=d.apply([m]),S=Us([m]),x=d.apply([m*2]);return Ld([k,S,x])}},t.className="CustomInit",t)}else h=this.biasInitializer;this.bias=this.addWeight("bias",[this.filters*a],null,h,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,t){return V(()=>{if(e.length!==3)throw new _(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);const r=t.training||!1,o=e[0],a=e[1],u=e[2],c=4;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=ls({ones:()=>Yn(o),rate:this.dropout,training:r,count:c,dropoutFunc:this.dropoutFunc}));const h=this.dropoutMask,d=(A,W,te)=>!W||!W[te]?A:P(W[te],A);let m=d(o,h,0),g=d(o,h,1),v=d(o,h,2),w=d(o,h,3);0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=ls({ones:()=>Yn(a),rate:this.recurrentDropout,training:r,count:c,dropoutFunc:this.dropoutFunc}));const k=this.recurrentDropoutMask;let S=d(a,k,0),x=d(a,k,1),T=d(a,k,2),z=d(a,k,3);const R=3,[$,B,H,Y]=pr(this.kernel.read(),c,R),[Z,ne,oe,de]=this.useBias?pr(this.bias.read(),c):[null,null,null,null];m=this.inputConv(m,$,Z,this.padding),g=this.inputConv(g,B,ne,this.padding),v=this.inputConv(v,H,oe,this.padding),w=this.inputConv(w,Y,de,this.padding);const[me,ve,be,Ne]=pr(this.recurrentKernel.read(),c,R);S=this.recurrentConv(S,me),x=this.recurrentConv(x,ve),T=this.recurrentConv(T,be),z=this.recurrentConv(z,Ne);const Ie=this.recurrentActivation.apply(le(m,S)),Ee=this.recurrentActivation.apply(le(g,x)),D=le(P(Ee,u),P(Ie,this.activation.apply(le(v,T)))),I=P(this.recurrentActivation.apply(le(w,z)),this.activation.apply(D));return[I,I,D]})}getConfig(){const e=super.getConfig(),{units:t}=e,r=e_(e,["units"]),o={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign({},r,o)}inputConv(e,t,r,o){const a=Di(e,t,this.strides,o||"valid",this.dataFormat==="channelsFirst"?"NCHW":"NHWC",this.dilationRate);return r?tr(a,r,this.dataFormat):a}recurrentConv(e,t){return Di(e,t,1,"same",this.dataFormat==="channelsFirst"?"NCHW":"NHWC")}}tp.className="ConvLSTM2DCell";re(tp);class ek extends Q1{constructor(e){const t=new tp(e);super(Object.assign({},e,{cell:t}))}static fromConfig(e,t){return new e(t)}}ek.className="ConvLSTM2D";re(ek);class np extends Ue{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(this.noiseShape==null)return this.noiseShape;const t=e.shape,r=[];for(let o=0;o<this.noiseShape.length;++o)r.push(this.noiseShape[o]==null?t[o]:this.noiseShape[o]);return r}call(e,t){return V(()=>{this.invokeCallHook(e,t);const r=Fe(e);if(0<this.rate&&this.rate<1){const o=t.training==null?!1:t.training,a=this.getNoiseShape(r);return Yo(()=>jb(r,this.rate,a,this.seed),()=>r,o)}return e})}getConfig(){const e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},t=super.getConfig();return Object.assign(e,t),e}dispose(){return super.dispose()}}np.className="Dropout";re(np);class tk extends np{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){const t=e.shape;return[t[0],1,t[2]]}}tk.className="SpatialDropout1D";re(tk);class rp extends Ue{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.batchInputShape==null&&e.inputShape==null&&e.inputDim!=null){let t=null;e.batchSize!=null&&(t=e.batchSize),this.batchInputShape=[t,e.inputDim]}this.units=e.units,Mt(this.units,"units"),this.activation=as(e.activation),e.useBias!=null&&(this.useBias=e.useBias),this.kernelInitializer=lt(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=lt(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=Tt(e.kernelConstraint),this.biasConstraint=Tt(e.biasConstraint),this.kernelRegularizer=ut(e.kernelRegularizer),this.biasRegularizer=ut(e.biasRegularizer),this.activityRegularizer=ut(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){e=Ye(e);const t=e[e.length-1];this.kernel==null&&(this.kernel=this.addWeight("kernel",[t,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:t}}],this.built=!0}computeOutputShape(e){e=Ye(e);const t=e.slice();return t[t.length-1]=this.units,t}call(e,t){return V(()=>{this.invokeCallHook(e,t);const r=Fe(e),o=_b(this.activation.getClassName());let a;return o!=null?a=mr(r,this.kernel.read(),o,this.bias?this.bias.read():null):(a=mr(r,this.kernel.read()),this.bias!=null&&(a=tr(a,this.bias.read())),this.activation!=null&&(a=this.activation.apply(a))),a})}getConfig(){const e={units:this.units,activation:os(this.activation),useBias:this.useBias,kernelInitializer:dt(this.kernelInitializer),biasInitializer:dt(this.biasInitializer),kernelRegularizer:Qe(this.kernelRegularizer),biasRegularizer:Qe(this.biasRegularizer),activityRegularizer:Qe(this.activityRegularizer),kernelConstraint:It(this.kernelConstraint),biasConstraint:It(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}rp.className="Dense";re(rp);class nk extends Ue{constructor(e){e=e||{},super(e),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=Ye(e);for(const t of e.slice(1))if(t==null)throw new _(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],es(e,1)]}call(e,t){return V(()=>{this.invokeCallHook(e,t);let r=Fe(e);if(this.dataFormat==="channelsFirst"&&r.rank>1){const o=[0];for(let a=2;a<r.rank;++a)o.push(a);o.push(1),r=We(r,o)}return Tz(r)})}getConfig(){const e={};this.dataFormat!=null&&(e.dataFormat=this.dataFormat);const t=super.getConfig();return Object.assign(e,t),e}}nk.className="Flatten";re(nk);class rk extends Ue{constructor(e){super(e),this.supportsMasking=!0,this.activation=as(e.activation)}call(e,t){return V(()=>{this.invokeCallHook(e,t);const r=Fe(e);return this.activation.apply(r)})}getConfig(){const e={activation:os(this.activation)},t=super.getConfig();return Object.assign(e,t),e}}rk.className="Activation";re(rk);class sk extends Ue{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,t){return V(()=>(e=Fe(e),Az(e,this.n)))}getConfig(){const e={n:this.n},t=super.getConfig();return Object.assign(e,t),e}}sk.className="RepeatVector";re(sk);class ik extends Ue{constructor(e){super(e),this.targetShape=e.targetShape;for(let t=0;t<this.targetShape.length;++t)this.isUnknown(this.targetShape[t])&&(this.targetShape[t]=null)}isUnknown(e){return e<0||e==null}fixUnknownDimension(e,t){const r="Total size of new array must be unchanged.",o=t.slice();let a=1,u=null;for(let h=0;h<o.length;++h){const d=o[h];if(this.isUnknown(d))if(u===null)u=h;else throw new _("Can only specifiy one unknown dimension.");else a*=d}const c=es(e);if(u!==null){if(a===0||c%a!==0)throw new _(r);o[u]=c/a}else if(c!==a)throw new _(r);return o}computeOutputShape(e){let t=!1;for(let r=0;r<e.length;++r)if(this.isUnknown(e[r])){t=!0;break}return t?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,t){return V(()=>{this.invokeCallHook(e,t);const r=Fe(e),o=r.shape,a=o.slice(0,1).concat(this.fixUnknownDimension(o.slice(1),this.targetShape));return J(r,a)})}getConfig(){const e={targetShape:this.targetShape},t=super.getConfig();return Object.assign(e,t),e}}ik.className="Reshape";re(ik);class ok extends Ue{constructor(e){if(super(e),e.dims==null)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);const t=Zn(1,e.dims.length+1);if(!nn(e.dims.slice().sort(),t))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new At({ndim:this.dims.length+1})]}computeOutputShape(e){e=Ye(e);const t=e.slice();return this.dims.forEach((r,o)=>{t[o+1]=e[r]}),t}call(e,t){return We(Fe(e),this.dimsIncludingBatch)}getConfig(){const e={dims:this.dims},t=super.getConfig();return Object.assign(e,t),e}}ok.className="Permute";re(ok);class ak extends Ue{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null?this.maskValue=e.maskValue==null?0:e.maskValue:this.maskValue=0}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={maskValue:this.maskValue};return Object.assign(t,e),t}computeMask(e,t){const r=Fe(e);return ky(Ff(r,this.maskValue),-1)}call(e,t){return V(()=>{this.invokeCallHook(e,t);const r=Fe(e),u=ky(Ff(r,this.maskValue),-1,!0);return P(r,Se(u,r.dtype))})}}ak.className="Masking";re(ak);class lk extends Ue{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",e.batchInputShape==null&&e.inputShape==null){let t=null;e.batchSize!=null&&(t=e.batchSize),e.inputLength==null?this.batchInputShape=[t,null]:this.batchInputShape=[t].concat(nt(e.inputLength))}this.inputDim=e.inputDim,Mt(this.inputDim,"inputDim"),this.outputDim=e.outputDim,Mt(this.outputDim,"outputDim"),this.embeddingsInitializer=lt(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=ut(e.embeddingsRegularizer),this.activityRegularizer=ut(e.activityRegularizer),this.embeddingsConstraint=Tt(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,t){return V(()=>this.maskZero?(e=Fe(e),Ff(e,He(e))):null)}computeOutputShape(e){if(e=Ye(e),this.inputLength==null)return[...e,this.outputDim];const t=nt(this.inputLength);if(t.length!==e.length-1)throw new _(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let r=0;for(let o=0;o<t.length;++o){const a=t[o],u=e[o+1];if(a!=null&&u!=null&&a!==u)throw new _(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);a==null&&(t[r]=u),r++}}return[e[0],...t,this.outputDim]}call(e,t){return V(()=>{this.invokeCallHook(e,t);let r=Fe(e);r.dtype!=="int32"&&(r=Ko(r,"int32"));const o=Ub(this.embeddings.read(),J(r,[r.size]));return J(o,Ye(this.computeOutputShape(r.shape)))})}getConfig(){const e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:dt(this.embeddingsInitializer),embeddingsRegularizer:Qe(this.embeddingsRegularizer),activityRegularizer:Qe(this.activityRegularizer),embeddingsConstraint:It(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},t=super.getConfig();return Object.assign(e,t),e}}lk.className="Embedding";re(lk);class Ws extends Ue{constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new Oe}computeElementwiseOpOutputShape(e,t){if(e==null||t==null)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(t.length===0)return e;const r=e.slice(0,e.length-t.length);for(let o=0;o<t.length;++o){const a=e[e.length-t.length+o],u=t[o];if(a==null||u==null||a<0||u<0)r.push(null);else if(a===1)r.push(u);else if(u===1)r.push(a);else{if(a!==u)throw new _("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(t));r.push(a)}}return r}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[Ye(e)]),e=e,e.length<2)throw new _(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);let t=[];for(const a of e)a!=null&&a[0]!==null&&t.push(a[0]);if(t=Qr(t),t.length>1)throw new _(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);let r=e[0]==null?null:e[0].slice(1);for(let a=1;a<e.length;++a){const u=e[a]==null?null:e[a].slice(1);r=this.computeElementwiseOpOutputShape(r,u)}const o=e.map(a=>a.length);e.indexOf(null)===-1&&Qr(o).length===1?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,t){return V(()=>{if(e=e,this.reshapeRequired){const r=[],o=e.map(a=>a.rank);if(o.indexOf(null)===-1){const a=is(o);for(let u of e){const c=u.rank;for(let h=0;h<a-c;++h)u=Jo(u,1);r.push(u)}return this.mergeFunction(r)}else{let a=!1;for(const h of e){const d=h.rank;if(d==null){const m=h.shape,g=m[0],v=m.slice(1).concat([g]);let w=J(h,[g].concat(es(m.slice(1))));w=We(w,[1,0]),w=J(w,v),r.push(w),a=!0}else if(d>1){const m=Zn(1,d).concat([0]);r.push(We(h,m)),a=!0}else r.push(h)}let u=this.mergeFunction(r);const c=u.rank;if(a){if(c==null){const h=u.shape,d=h.length,m=h[d-1],g=[m].concat(h.slice(0,h.length-1));u=J(We(J(u,[-1,m]),[1,0]),g)}else if(c>1){const h=[c-1].concat(Zn(0,c-1));u=We(u,h)}}return u}}else return this.mergeFunction(e)})}computeOutputShape(e){e=e;let t;e[0]==null?t=null:t=e[0].slice(1);for(let o=1;o<e.length;++o){const a=e[o]==null?null:e[o].slice(1);t=this.computeElementwiseOpOutputShape(t,a)}let r=[];for(const o of e)o!=null&&o[0]!==null&&r.push(o[0]);return r=Qr(r),r.length===1?t=r.concat(t):t=[null].concat(t),t}computeMask(e,t){return V(()=>{if(t==null)return null;if(!Array.isArray(t))throw new _("`mask` should be an Array");if(!Array.isArray(e))throw new _("`inputs` should be an Array");if(t.length!==e.length)throw new _(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${t.length})`);if(t.every(o=>o==null))return null;t=t.map(o=>o==null?o:qn(o,0));let r=t[0];for(let o=1;o<t.length-1;++o)r=Pi(r,t[o]);return r})}}class uk extends Ws{constructor(e){super(e)}mergeFunction(e){return V(()=>{let t=e[0].clone();for(let r=1;r<e.length;++r)t=le(t,e[r]);return t})}}uk.className="Add";re(uk);class ck extends Ws{constructor(e){super(e)}mergeFunction(e){return V(()=>{let t=e[0].clone();for(let r=1;r<e.length;++r)t=P(t,e[r]);return t})}}ck.className="Multiply";re(ck);class hk extends Ws{constructor(e){super(e)}mergeFunction(e){return V(()=>{let t=e[0].clone();for(let r=1;r<e.length;++r)t=le(t,e[r]);return P(1/e.length,t)})}}hk.className="Average";re(hk);class fk extends Ws{constructor(e){super(e)}mergeFunction(e){return V(()=>{let t=e[0];for(let r=1;r<e.length;++r)t=Bs(t,e[r]);return t})}}fk.className="Maximum";re(fk);class dk extends Ws{constructor(e){super(e)}mergeFunction(e){return V(()=>{let t=e[0];for(let r=1;r<e.length;++r)t=ob(t,e[r]);return t})}}dk.className="Minimum";re(dk);class pk extends Ws{constructor(e){super(e),this.DEFAULT_AXIS=-1,e==null&&(e={}),this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!(Array.isArray(e)&&Array.isArray(e[0]))||e.length===1)throw new _("A `Concatenate` layer should be called on a list of at least 2 inputs");e=e;let t=!0;for(const o of e)if(o!=null){t=!1;break}if(t)return;const r=[];for(let o=0;o<e.length;++o){const a=e[o].slice();a.splice(this.axis,1);let u=!1;for(const c of r)if(nn(c,a)){u=!0;break}u||r.push(a)}if(r.length>1)throw new _("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return V(()=>Ld(e,this.axis))}computeOutputShape(e){if(!(Array.isArray(e)&&Array.isArray(e[0])))throw new _("A `Concatenate` layer should be called on a list of inputs.");const t=e,r=t[0].slice(),o=this.axis<0?r.length+this.axis:this.axis;for(const a of t.slice(1)){if(r[o]==null||a[o]==null){r[o]=null;break}r[o]+=a[o]}return r}computeMask(e,t){if(t==null)return null;if(!Array.isArray(t))throw new _("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new _("`inputs` should be an array for Concatenate");if(t.length!==e.length)throw new _(`Mismatch in the length of mask (${t.length}) and the legnth of inputs (${e.length})`);return V(()=>{let r=!0;if(t.forEach(u=>{if(u!=null){r=!1;return}}),r)return null;const o=[];for(let u=0;u<e.length;++u)t[u]==null?o.push(Se(Yn(e[u]),"bool")):t[u].rank<e[u].rank?o.push(qn(t[u],-1)):o.push(t[u]);const a=Kn(o,this.axis);return nI(a,-1,!1)})}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}pk.className="Concatenate";re(pk);function No(n,e){for(;n<0;)n+=e;return n}function t_(n,e,t){if(n.shape.length>3||e.shape.length>3)throw new Oe("batchDot is not implemented for tensors of 4D or higher rank yet");if(E(n.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${n.shape.length}`),E(n.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${e.shape.length}`),typeof t=="number"&&(t=[t,t]),n.dtype==="complex64"||e.dtype==="complex64")throw new Oe("batchDot is not implemented for complex64-type Tensors yet.");const r=n.shape.length,o=e.shape.length;t==null&&(t=[r-1,o-2]);const a=t;return V(()=>{let u;if(r>o){u=r-o;const h=[];for(let d=0;d<u;++d)h.push(1);e=J(e,e.shape.concat(h))}else if(o>r){u=o-r;const h=[];for(let d=0;d<u;++d)h.push(1);n=J(n,n.shape.concat(h))}else u=0;let c;if(n.shape.length===2&&e.shape.length===2)a[0]===a[1]?c=Ce(P(n,e),a[0]):c=Ce(P(We(n,[1,0]),e),a[1]);else{const h=a[0]!==n.shape.length-1,d=a[1]===e.shape.length-1;c=et(n,e,h,d)}if(u>0){let h;r>o?h=r+o-3:h=r-1;const d=[];for(let m=h;m<h+u;++m)d.push(m);c=zi(c,d)}return c.shape.length===1&&(c=qn(c,1)),c})}class mk extends Ws{constructor(e){super(e),this.axes=e.axes,this.normalize=e.normalize==null?!1:e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){E(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const t=e[0],r=e[1];if(t.length>3||r.length>3)throw new Oe("Dot layer does not support tensors of 4D or higher rank yet.");const o=this.interpretAxes(t,r);if(t[o[0]]!==r[o[1]])throw new _(`Dimension incompatibility: ${t[o[0]]} !== ${r[o[1]]}`)}mergeFunction(e){if(e.length!==2)throw new _(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let t=e[0],r=e[1],o;return Array.isArray(this.axes)?o=this.axes.map((a,u)=>No(a,e[u].shape.length)):o=[No(this.axes,t.shape.length),No(this.axes,r.shape.length)],this.normalize&&(t=ql(t,o[0]),r=ql(r,o[1])),t_(t,r,o)}interpretAxes(e,t){let r;return Array.isArray(this.axes)?r=this.axes:r=[No(this.axes,e.length),No(this.axes,t.length)],r}computeOutputShape(e){E(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const t=e[0].slice(),r=e[1].slice();if(t.length>3||r.length>3)throw new Oe("Dot layer does not support tensors of 4D or higher rank yet.");const o=this.interpretAxes(t,r);t.splice(o[0],1),r.splice(o[1],1),r.splice(0,1);const a=t.concat(r);return a.length===1&&a.push(1),a}computeMask(e,t){return null}getConfig(){const e={axes:this.axes,normalize:this.normalize},t=super.getConfig();return Object.assign(e,t),e}}mk.className="Dot";re(mk);class gk extends Ue{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={stddev:this.stddev};return Object.assign(t,e),t}call(e,t){return V(()=>{this.invokeCallHook(e,t);const r=Fe(e);return Yo(()=>le(cu(r.shape,0,this.stddev),r),()=>r,t.training||!1)})}}gk.className="GaussianNoise";re(gk);class yk extends Ue{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return V(()=>{this.invokeCallHook(e,t);const r=Fe(e);return this.rate>0&&this.rate<1?Yo(()=>{const a=Math.sqrt(this.rate/(1-this.rate));return P(r,cu(r.shape,1,a))},()=>r,t.training||!1):r})}}yk.className="GaussianDropout";re(yk);class vk extends Ue{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||Fe(e).shape}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return V(()=>{if(this.rate<1&&this.rate>0){const r=this._getNoiseShape(e);return Yo(()=>{const a=Fe(e),c=-1.6732632423543772*1.0507009873554805;let h=Wo(iu(r),this.rate);h=Ko(h,"float32");const d=((1-this.rate)*(1+this.rate*c**2))**-.5,m=-d*c*this.rate,g=le(P(a,h),P(le(h,-1),c));return le(P(g,d),m)},()=>Fe(e),t.training||!1)}return e})}}vk.className="AlphaDropout";re(vk);function Bo(n,e,t,r,o,a=.001){let u;if(n.rank===2)u=xI(n,e,t,r,o,a);else if(n.rank===3)u=AI(n,e,t,r,o,a);else if(n.rank===4)u=TI(n,e,t,r,o,a);else throw new Oe(`batchNormalization is not implemented for array of rank ${n.rank} yet`);return u}function n_(n,e,t,r,o=.001){return V(()=>{const a=Go(n,r),u=a.mean,c=a.variance;return[Bo(n,u,c,t,e,o),u,c]})}function r_(n,e,t,r,o=.001){return V(()=>{const a=Go(n,r),u=a.mean,c=a.variance,h=[];for(const k of Zn(0,n.rank))r.indexOf(k)!==-1?h.push(1):h.push(n.shape[k]);const d=J(u,h),m=J(c,h),g=e==null?null:J(e,h),v=t==null?null:J(t,h);return[Bo(n,d,m,v,g,o),u,c]})}function s_(n,e,t,r,o=.001){return nn(r.slice().sort(),Zn(0,n.rank-1))?n_(n,e,t,r,o):r_(n,e,t,r,o)}class wk extends Ue{constructor(e){e==null&&(e={}),super(e),this.supportsMasking=!0,this.axis=e.axis==null?-1:e.axis,this.momentum=e.momentum==null?.99:e.momentum,this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=lt(e.betaInitializer||"zeros"),this.gammaInitializer=lt(e.gammaInitializer||"ones"),this.movingMeanInitializer=lt(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=lt(e.movingVarianceInitializer||"ones"),this.betaConstraint=Tt(e.betaConstraint),this.gammaConstraint=Tt(e.gammaConstraint),this.betaRegularizer=ut(e.betaRegularizer),this.gammaRegularizer=ut(e.gammaRegularizer)}build(e){e=Ye(e);const t=this.axis>=0?this.axis:this.axis+e.length,r=e[t];if(r==null)throw new _(`Axis ${t} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new At({ndim:e.length,axes:{[t]:r}})];const o=[r];this.scale&&(this.gamma=this.addWeight("gamma",o,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",o,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",o,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",o,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,t){return V(()=>{const r=t.training==null?!1:t.training,o=Fe(e),a=o.shape,u=a.length,c=Zn(0,u),h=this.axis>=0?this.axis:this.axis+u;c.splice(h,1);const d=Os(1,u);d[h]=a[h];const m=c.slice();m.sort();const g=!nn(m,Zn(0,u).slice(0,u-1)),v=()=>{if(g){const z=J(this.movingMean.read(),d),R=J(this.movingVariance.read(),d),$=this.center?J(this.beta.read(),d):null,B=this.scale?J(this.gamma.read(),d):null;return Bo(o,z,R,$,B,this.epsilon)}else return Bo(o,this.movingMean.read(),this.movingVariance.read(),this.beta==null?null:this.beta.read(),this.gamma==null?null:this.gamma.read(),this.epsilon)};if(!r)return v();const[w,k,S]=s_(o,this.gamma.read(),this.beta.read(),c,this.epsilon),x=(z,R,$)=>{V(()=>{const B=1-$,H=z.read(),Y=P(Re(H,R),B);z.write(Re(H,Y))})};return x(this.movingMean,k,this.momentum),x(this.movingVariance,S,this.momentum),w})}getConfig(){const e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:dt(this.betaInitializer),gammaInitializer:dt(this.gammaInitializer),movingMeanInitializer:dt(this.movingMeanInitializer),movingVarianceInitializer:dt(this.movingVarianceInitializer),betaRegularizer:Qe(this.betaRegularizer),gammaRegularizer:Qe(this.gammaRegularizer),betaConstraint:It(this.betaConstraint),gammaConstraint:It(this.gammaConstraint)},t=super.getConfig();return Object.assign(e,t),e}}wk.className="BatchNormalization";re(wk);class bk extends Ue{constructor(e){if(e==null&&(e={}),super(e),this.axis=e.axis==null?-1:e.axis,typeof this.axis=="number"){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else if(Array.isArray(this.axis)){for(const t of this.axis)if(!Number.isInteger(t))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}else throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=lt(e.betaInitializer||"zeros"),this.gammaInitializer=lt(e.gammaInitializer||"ones"),this.betaRegularizer=ut(e.betaRegularizer),this.gammaRegularizer=ut(e.gammaRegularizer),this.supportsMasking=!0}build(e){e=Ye(e);const t=e.length;typeof this.axis=="number"&&(this.axis=[this.axis]);for(let a=0;a<this.axis.length;++a)this.axis[a]<0&&(this.axis[a]+=t);for(const a of this.axis)if(a<0||a>=t)throw new Error(`Invalid axis: ${a}`);if(this.axis.length!==Qr(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const r=this.axis.map(a=>e[a]),o=!0;this.scale?this.gamma=this.addWeight("gamma",r,"float32",this.gammaInitializer,this.gammaRegularizer,o):this.gamma=null,this.center?this.beta=this.addWeight("beta",r,"float32",this.betaInitializer,this.betaRegularizer,o):this.beta=null,this.built=!0}call(e,t){const r=Fe(e),o=r.shape,a=o.length;return V(()=>{let{mean:c,variance:h}=Go(r,this.axis,!0);const d=Os(1,a);for(const S of this.axis)d[S]=o[S];const m=S=>S!=null&&S.shape.length!==a?J(S,d):S;let g=this.scale?m(this.gamma.read()):null,v=this.center?m(this.beta.read()):null;const w=[],k=[];for(let S=0;S<a;++S)this.axis.indexOf(S)!==-1?(w.push(o[S]),k.push(1)):(w.push(1),k.push(o[S]));return c=fr(c,w),h=fr(h,w),g!=null&&(g=fr(g,k)),v!=null&&(v=fr(v,k)),Bo(r,c,h,v,g,this.epsilon)})}getConfig(){const e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:dt(this.betaInitializer),gammaInitializer:dt(this.gammaInitializer),betaRegularizer:Qe(this.betaRegularizer),gammaRegularizer:Qe(this.gammaRegularizer)},t=super.getConfig();return Object.assign(e,t),e}}bk.className="LayerNormalization";re(bk);function i_(n,e,t){return V(()=>{if(n.rank!==4)throw new _(`temporalPadding expects input tensor to be 4-D, but received a ${n.rank}-D tensor.`);if(e==null&&(e=[[1,1],[1,1]]),e.length!==2||e[0].length!==2||e[1].length!==2)throw new _("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(t==null&&(t=Qn()),t!=="channelsLast"&&t!=="channelsFirst")throw new _(`Unknown data format: ${t}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let r;return t==="channelsFirst"?r=[[0,0],[0,0],e[0],e[1]]:r=[[0,0],e[0],e[1],[0,0]],ab(n,r)})}class kk extends Ue{constructor(e){if(e==null&&(e={}),super(e),this.dataFormat=e.dataFormat==null?Qn():e.dataFormat,e.padding==null)this.padding=[[1,1],[1,1]];else if(typeof e.padding=="number")this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,e.padding.length!==2)throw new _(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let t,r;if(typeof e.padding[0]=="number")t=[e.padding[0],e.padding[0]],r=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,e.padding[0].length!==2)throw new _(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(t=e.padding[0],e.padding[1].length!==2)throw new _(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);r=e.padding[1]}this.padding=[t,r]}this.inputSpec=[new At({ndim:4})]}computeOutputShape(e){e=Ye(e);let t,r;return this.dataFormat==="channelsFirst"?(e[2]!=null&&e[2]>=0?t=e[2]+this.padding[0][0]+this.padding[0][1]:t=null,e[3]!=null&&e[3]>=0?r=e[3]+this.padding[1][0]+this.padding[1][1]:r=null,[e[0],e[1],t,r]):(e[1]!=null&&e[1]>=0?t=e[1]+this.padding[0][0]+this.padding[0][1]:t=null,e[2]!=null&&e[2]>=0?r=e[2]+this.padding[1][0]+this.padding[1][1]:r=null,[e[0],t,r,e[3]])}call(e,t){return V(()=>i_(Fe(e),this.padding,this.dataFormat))}getConfig(){const e={padding:this.padding,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}kk.className="ZeroPadding2D";re(kk);function vu(n,e,t,r,o,a){return V(()=>{vt(o),Lb(a),bn(r),t==null&&(t=[1,1]),r==null&&(r="valid"),o==null&&(o=Qn()),a==null&&(a="max"),n=Yd(n,o);let u;const c=r==="same"?"same":"valid";return a==="max"?u=jT(n,e,t,c):u=hI(n,e,t,c),o==="channelsFirst"&&(u=We(u,[0,3,1,2])),u})}function Sk(n,e,t,r,o,a){return V(()=>{vt(o),Lb(a),bn(r),t==null&&(t=[1,1,1]),r==null&&(r="valid"),o==null&&(o=Qn()),a==null&&(a="max"),n=B1(n,o);let u;const c=r==="same"?"same":"valid";return a==="max"?u=VT(n,e,t,c):u=dI(n,e,t,c),o==="channelsFirst"&&(u=We(u,[0,4,1,2,3])),u})}class xk extends Ue{constructor(e){if(e.poolSize==null&&(e.poolSize=2),super(e),typeof e.poolSize=="number")this.poolSize=[e.poolSize];else if(Array.isArray(e.poolSize)&&e.poolSize.length===1&&typeof e.poolSize[0]=="number")this.poolSize=e.poolSize;else throw new _(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.poolSize)}`);if(Mt(this.poolSize,"poolSize"),e.strides==null)this.strides=this.poolSize;else if(typeof e.strides=="number")this.strides=[e.strides];else if(Array.isArray(e.strides)&&e.strides.length===1&&typeof e.strides[0]=="number")this.strides=e.strides;else throw new _(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.strides)}`);Mt(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,bn(this.padding),this.inputSpec=[new At({ndim:3})]}computeOutputShape(e){e=Ye(e);const t=Jn(e[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]}call(e,t){return V(()=>{this.invokeCallHook(e,t),e=Jo(Fe(e),2);const r=this.poolingFunction(Fe(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return zi(r,[2])})}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},t=super.getConfig();return Object.assign(e,t),e}}class Ek extends xk{constructor(e){super(e)}poolingFunction(e,t,r,o,a){return vt(a),bn(o),vu(e,t,r,o,a,"max")}}Ek.className="MaxPooling1D";re(Ek);class Ak extends xk{constructor(e){super(e)}poolingFunction(e,t,r,o,a){return vt(a),bn(o),vu(e,t,r,o,a,"avg")}}Ak.className="AveragePooling1D";re(Ak);class Ik extends Ue{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==2)throw new _(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides];Mt(this.poolSize,"poolSize"),Mt(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,vt(this.dataFormat),bn(this.padding),this.inputSpec=[new At({ndim:4})]}computeOutputShape(e){e=Ye(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],r=this.dataFormat==="channelsFirst"?e[3]:e[2];return t=Jn(t,this.poolSize[0],this.padding,this.strides[0]),r=Jn(r,this.poolSize[1],this.padding,this.strides[1]),this.dataFormat==="channelsFirst"?[e[0],e[1],t,r]:[e[0],t,r,e[3]]}call(e,t){return V(()=>(this.invokeCallHook(e,t),this.poolingFunction(Fe(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class Tk extends Ik{constructor(e){super(e)}poolingFunction(e,t,r,o,a){return vt(a),bn(o),vu(e,t,r,o,a,"max")}}Tk.className="MaxPooling2D";re(Tk);class Nk extends Ik{constructor(e){super(e)}poolingFunction(e,t,r,o,a){return vt(a),bn(o),vu(e,t,r,o,a,"avg")}}Nk.className="AveragePooling2D";re(Nk);class Ck extends Ue{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==3)throw new _(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];Mt(this.poolSize,"poolSize"),Mt(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,vt(this.dataFormat),bn(this.padding),this.inputSpec=[new At({ndim:5})]}computeOutputShape(e){e=Ye(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],r=this.dataFormat==="channelsFirst"?e[3]:e[2],o=this.dataFormat==="channelsFirst"?e[4]:e[3];return t=Jn(t,this.poolSize[0],this.padding,this.strides[0]),r=Jn(r,this.poolSize[1],this.padding,this.strides[1]),o=Jn(o,this.poolSize[2],this.padding,this.strides[2]),this.dataFormat==="channelsFirst"?[e[0],e[1],t,r,o]:[e[0],t,r,o,e[4]]}call(e,t){return V(()=>(this.invokeCallHook(e,t),this.poolingFunction(Fe(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class Dk extends Ck{constructor(e){super(e)}poolingFunction(e,t,r,o,a){return vt(a),bn(o),Sk(e,t,r,o,a,"max")}}Dk.className="MaxPooling3D";re(Dk);class zk extends Ck{constructor(e){super(e)}poolingFunction(e,t,r,o,a){return vt(a),bn(o),Sk(e,t,r,o,a,"avg")}}zk.className="AveragePooling3D";re(zk);class $k extends Ue{constructor(e){super(e),this.inputSpec=[new At({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,t){throw new Oe}}class Mk extends $k{constructor(e){super(e||{})}call(e,t){return V(()=>{const r=Fe(e);return St(r,1)})}}Mk.className="GlobalAveragePooling1D";re(Mk);class Rk extends $k{constructor(e){super(e||{})}call(e,t){return V(()=>{const r=Fe(e);return Dr(r,1)})}}Rk.className="GlobalMaxPooling1D";re(Rk);class _k extends Ue{constructor(e){super(e),this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,vt(this.dataFormat),this.inputSpec=[new At({ndim:4})]}computeOutputShape(e){return e=e,this.dataFormat==="channelsLast"?[e[0],e[3]]:[e[0],e[1]]}call(e,t){throw new Oe}getConfig(){const e={dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class Fk extends _k{call(e,t){return V(()=>{const r=Fe(e);return this.dataFormat==="channelsLast"?St(r,[1,2]):St(r,[2,3])})}}Fk.className="GlobalAveragePooling2D";re(Fk);class Lk extends _k{call(e,t){return V(()=>{const r=Fe(e);return this.dataFormat==="channelsLast"?Dr(r,[1,2]):Dr(r,[2,3])})}}Lk.className="GlobalMaxPooling2D";re(Lk);class Ok extends Ue{constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return this.layer!=null?this.layer.trainable:!1}set trainable(e){this.layer!=null&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){const e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},t=super.getConfig();return Object.assign(e,t),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.layer!=null&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,t,r={}){const o=t.layer,a=gr(o,r);delete t.layer;const u={layer:a};return Object.assign(u,t),new e(u)}}class Pk extends Ok{constructor(e){super(e),this.supportsMasking=!0}build(e){if(e=Ye(e),e.length<3)throw new _(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];const t=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(t),this.layer.built=!0),super.build(e)}computeOutputShape(e){e=Ye(e);const t=[e[0]].concat(e.slice(2)),r=this.layer.computeOutputShape(t),o=e[1];return[r[0],o].concat(r.slice(1))}call(e,t){return V(()=>(e=Fe(e),J1((u,c)=>[Fe(this.layer.call(u,t)),[]],e,[],!1,null,null,!1,!0)[1]))}}Pk.className="TimeDistributed";re(Pk);function o_(n){js(bz,"BidirectionalMergeMode",n)}const a_="concat";class Bk extends Ok{constructor(e){super(e);const t=e.layer.getConfig(),r={};r.className=e.layer.getClassName(),r.config=t,this.forwardLayer=gr(r),t.goBackwards=t.goBackwards!==!0;const o={};if(o.className=e.layer.getClassName(),o.config=t,this.backwardLayer=gr(o),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=e.mergeMode===void 0?a_:e.mergeMode,o_(this.mergeMode),e.weights)throw new Oe("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,this.forwardLayer!=null&&(this.forwardLayer.trainable=e),this.backwardLayer!=null&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){const t=e.length,r=Math.floor(t/2);this.forwardLayer.setWeights(e.slice(0,r)),this.backwardLayer.setWeights(e.slice(r))}computeOutputShape(e){let t=this.forwardLayer.computeOutputShape(e);Array.isArray(t)&&Array.isArray(t[0])||(t=[t]),t=t;let r,o,a;return this.returnState&&(a=t.slice(1)),r=t[0],r=r,this.mergeMode==="concat"?(r[r.length-1]*=2,o=[r]):this.mergeMode==null?o=[r,r.slice()]:o=[r],this.returnState?this.mergeMode==null?o.concat(a).concat(a.slice()):[r].concat(a).concat(a.slice()):en(o)}apply(e,t){let r=t==null?null:t.initialState,o=t==null?null:t.constants;t==null&&(t={});const a=K1(e,r,o,this.numConstants);if(e=a.inputs,r=a.initialState,o=a.constants,Array.isArray(e)&&(r=e.slice(1),e=e[0]),(r==null||r.length===0)&&o==null)return super.apply(e,t);const u=[],c=[];if(r!=null){const d=r.length;if(d%2>0)throw new _("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");t.initialState=r,u.push(...r);const m=r.map(g=>new At({shape:g.shape}));this.forwardLayer.stateSpec=m.slice(0,d/2),this.backwardLayer.stateSpec=m.slice(d/2),c.push(...m)}if(o!=null)throw new Oe("Support for constants in Bidirectional layers is not implemented yet.");const h=u[0]instanceof dr;for(const d of u)if(d instanceof dr!==h)throw new _("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(h){const d=[e].concat(u),m=this.inputSpec.concat(c),g=this.inputSpec;this.inputSpec=m;const v=super.apply(d,t);return this.inputSpec=g,v}else return super.apply(e,t)}call(e,t){return V(()=>{const r=t.initialState;let o,a;if(r==null)o=this.forwardLayer.call(e,t),a=this.backwardLayer.call(e,t);else{const h=r.slice(0,r.length/2),d=r.slice(r.length/2);o=this.forwardLayer.call(e,Object.assign(t,{initialState:h})),a=this.backwardLayer.call(e,Object.assign(t,{initialState:d}))}let u;this.returnState&&(Array.isArray(o)&&(u=o.slice(1).concat(a.slice(1))),o=o[0],a=a[0]),this.returnSequences&&(a=Pl(a,1));let c;return this.mergeMode==="concat"?c=Ld([o,a]):this.mergeMode==="sum"?c=le(o,a):this.mergeMode==="ave"?c=P(.5,le(o,a)):this.mergeMode==="mul"?c=P(o,a):this.mergeMode==null&&(c=[o,a]),this.returnState?this.mergeMode==null?c.concat(u):[c].concat(u):c})}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){$s(this.forwardLayer.name,()=>{this.forwardLayer.build(e)}),$s(this.backwardLayer.name,()=>{this.backwardLayer.build(e)}),this.built=!0}computeMask(e,t){Array.isArray(t)&&(t=t[0]);let r;if(this.returnSequences?this.mergeMode==null?r=[t,t]:r=t:this.mergeMode==null?r=[null,null]:r=null,this.returnState){const a=this.forwardLayer.states.map(u=>null);return Array.isArray(r)?r.concat(a).concat(a):[r].concat(a).concat(a)}else return r}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.forwardLayer!=null&&this.forwardLayer.setFastWeightInitDuringBuild(e),this.backwardLayer!=null&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){const e={mergeMode:this.mergeMode},t=super.getConfig();return Object.assign(e,t),e}static fromConfig(e,t){const r=gr(t.layer);if(delete t.layer,t.numConstants!=null)throw new Oe("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const o=t;return o.layer=r,new e(o)}}Bk.className="Bidirectional";re(Bk);class Uk extends Ue{constructor(e){super(e),this.scale=e.scale,e.offset?this.offset=e.offset:this.offset=0}getConfig(){const e={scale:this.scale,offset:this.offset},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return V(()=>(e=Fe(e),e.dtype!=="float32"&&(e=Ko(e,"float32")),le(P(e,this.scale),this.offset)))}}Uk.className="Rescaling";re(Uk);function l_(n){return new rp(n)}var jk=function(n,e){return(jk=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,r){t.__proto__=r}||function(t,r){for(var o in r)r.hasOwnProperty(o)&&(t[o]=r[o])})(n,e)};function u_(n,e){function t(){this.constructor=n}jk(n,e),n.prototype=e===null?Object.create(e):(t.prototype=e.prototype,new t)}var Kf=function(){return(Kf=Object.assign||function(n){for(var e,t=1,r=arguments.length;t<r;t++)for(var o in e=arguments[t])Object.prototype.hasOwnProperty.call(e,o)&&(n[o]=e[o]);return n}).apply(this,arguments)};function ht(n,e,t,r){return new(t||(t=Promise))(function(o,a){function u(d){try{h(r.next(d))}catch(m){a(m)}}function c(d){try{h(r.throw(d))}catch(m){a(m)}}function h(d){var m;d.done?o(d.value):(m=d.value,m instanceof t?m:new t(function(g){g(m)})).then(u,c)}h((r=r.apply(n,[])).next())})}function ft(n,e){var t,r,o,a,u={label:0,sent:function(){if(1&o[0])throw o[1];return o[1]},trys:[],ops:[]};return a={next:c(0),throw:c(1),return:c(2)},typeof Symbol=="function"&&(a[Symbol.iterator]=function(){return this}),a;function c(h){return function(d){return(function(m){if(t)throw new TypeError("Generator is already executing.");for(;u;)try{if(t=1,r&&(o=2&m[0]?r.return:m[0]?r.throw||((o=r.return)&&o.call(r),0):r.next)&&!(o=o.call(r,m[1])).done)return o;switch(r=0,o&&(m=[2&m[0],o.value]),m[0]){case 0:case 1:o=m;break;case 4:return u.label++,{value:m[1],done:!1};case 5:u.label++,r=m[1],m=[0];continue;case 7:m=u.ops.pop(),u.trys.pop();continue;default:if(!(o=(o=u.trys).length>0&&o[o.length-1])&&(m[0]===6||m[0]===2)){u=0;continue}if(m[0]===3&&(!o||m[1]>o[0]&&m[1]<o[3])){u.label=m[1];break}if(m[0]===6&&u.label<o[1]){u.label=o[1],o=m;break}if(o&&u.label<o[2]){u.label=o[2],u.ops.push(m);break}o[2]&&u.ops.pop(),u.trys.pop();continue}m=e.call(n,u)}catch(g){m=[6,g],r=0}finally{t=o=0}if(5&m[0])throw m[1];return{value:m[0]?m[1]:void 0,done:!0}})([h,d])}}}function Qt(n){var e=typeof Symbol=="function"&&Symbol.iterator,t=e&&n[e],r=0;if(t)return t.call(n);if(n&&typeof n.length=="number")return{next:function(){return n&&r>=n.length&&(n=void 0),{value:n&&n[r++],done:!n}}};throw new TypeError(e?"Object is not iterable.":"Symbol.iterator is not defined.")}function sp(n,e){var t=typeof Symbol=="function"&&n[Symbol.iterator];if(!t)return n;var r,o,a=t.call(n),u=[];try{for(;(e===void 0||e-- >0)&&!(r=a.next()).done;)u.push(r.value)}catch(c){o={error:c}}finally{try{r&&!r.done&&(t=a.return)&&t.call(a)}finally{if(o)throw o.error}}return u}function Ro(){for(var n=[],e=0;e<arguments.length;e++)n=n.concat(sp(arguments[e]));return n}function c_(n){return ht(this,void 0,void 0,function(){var e,t,r,o,a,u,c;return ft(this,function(h){switch(h.label){case 0:return e="http://",t="https://",r="file://",n.indexOf(e)!==0&&n.indexOf(t)!==0?[3,3]:[4,fetch(n)];case 1:return[4,h.sent().json()];case 2:return[2,h.sent()];case 3:return n.indexOf(r)!==0?[3,5]:(o=require("fs"),a=UD.promisify(o.readFile),c=(u=JSON).parse,[4,a(n.slice(r.length),{encoding:"utf-8"})]);case 4:return[2,c.apply(u,[h.sent()])];case 5:throw new Error("Unsupported URL scheme in metadata URL: "+n+". Supported schemes are: http://, https://, and (node.js-only) file://")}})})}var Ai=null;function Uo(n){return Ai==null&&(Ai=fd().epsilon()),V(function(){var e=Go(n),t=e.mean,r=e.variance;return $e(Re(n,t),le(Kt(r),Ai))})}function h_(n){if(n.length<2)throw new Error("Cannot normalize a Float32Array with fewer than 2 elements.");return Ai==null&&(Ai=fd().epsilon()),V(function(){var e=Go(jt(n)),t=e.mean,r=e.variance,o=t.arraySync(),a=Math.sqrt(r.arraySync()),u=Array.from(n).map(function(c){return(c-o)/(a+Ai)});return new Float32Array(u)})}function f_(){return window.AudioContext||window.webkitAudioContext}function d_(n){return ht(this,void 0,void 0,function(){return ft(this,function(e){return[2,navigator.mediaDevices.getUserMedia({audio:n==null||n,video:!1})]})})}var Jf=(function(){function n(e){var t=this;if(e==null)throw new Error("Required configuration object is missing for BrowserFftFeatureExtractor constructor");if(e.spectrogramCallback==null)throw new Error("spectrogramCallback cannot be null or undefined");if(!(e.numFramesPerSpectrogram>0))throw new Error("Invalid value in numFramesPerSpectrogram: "+e.numFramesPerSpectrogram);if(e.suppressionTimeMillis<0)throw new Error("Expected suppressionTimeMillis to be >= 0, but got "+e.suppressionTimeMillis);if(this.suppressionTimeMillis=e.suppressionTimeMillis,this.spectrogramCallback=e.spectrogramCallback,this.numFrames=e.numFramesPerSpectrogram,this.sampleRateHz=e.sampleRateHz||44100,this.fftSize=e.fftSize||1024,this.frameDurationMillis=this.fftSize/this.sampleRateHz*1e3,this.columnTruncateLength=e.columnTruncateLength||this.fftSize,this.overlapFactor=e.overlapFactor,this.includeRawAudio=e.includeRawAudio,E(this.overlapFactor>=0&&this.overlapFactor<1,function(){return"Expected overlapFactor to be >= 0 and < 1, but got "+t.overlapFactor}),this.columnTruncateLength>this.fftSize)throw new Error("columnTruncateLength "+this.columnTruncateLength+" exceeds fftSize ("+this.fftSize+").");this.audioContextConstructor=f_()}return n.prototype.start=function(e){return ht(this,void 0,void 0,function(){var t,r,o;return ft(this,function(a){switch(a.label){case 0:if(this.frameIntervalTask!=null)throw new Error("Cannot start already-started BrowserFftFeatureExtractor");return t=this,[4,d_(e)];case 1:return t.stream=a.sent(),this.audioContext=new this.audioContextConstructor({sampleRate:this.sampleRateHz}),r=this.audioContext.createMediaStreamSource(this.stream),this.analyser=this.audioContext.createAnalyser(),this.analyser.fftSize=2*this.fftSize,this.analyser.smoothingTimeConstant=0,r.connect(this.analyser),this.freqDataQueue=[],this.freqData=new Float32Array(this.fftSize),this.includeRawAudio&&(this.timeDataQueue=[],this.timeData=new Float32Array(this.fftSize)),o=Math.max(1,Math.round(this.numFrames*(1-this.overlapFactor))),this.tracker=new p_(o,Math.round(this.suppressionTimeMillis/this.frameDurationMillis)),this.frameIntervalTask=setInterval(this.onAudioFrame.bind(this),this.fftSize/this.sampleRateHz*1e3),[2]}})})},n.prototype.onAudioFrame=function(){return ht(this,void 0,void 0,function(){var e,t,r,o;return ft(this,function(a){switch(a.label){case 0:return this.analyser.getFloatFrequencyData(this.freqData),this.freqData[0]===-1/0?[2]:(this.freqDataQueue.push(this.freqData.slice(0,this.columnTruncateLength)),this.includeRawAudio&&(this.analyser.getFloatTimeDomainData(this.timeData),this.timeDataQueue.push(this.timeData.slice())),this.freqDataQueue.length>this.numFrames&&this.freqDataQueue.shift(),this.tracker.tick()?(e=sw(this.freqDataQueue),t=iw(e,[1,this.numFrames,this.columnTruncateLength,1]),r=void 0,this.includeRawAudio&&(o=sw(this.timeDataQueue),r=iw(o,[1,this.numFrames*this.fftSize])),[4,this.spectrogramCallback(t,r)]):[3,2]);case 1:a.sent()&&this.tracker.suppress(),Me([t,r]),a.label=2;case 2:return[2]}})})},n.prototype.stop=function(){return ht(this,void 0,void 0,function(){return ft(this,function(e){if(this.frameIntervalTask==null)throw new Error("Cannot stop because there is no ongoing streaming activity.");return clearInterval(this.frameIntervalTask),this.frameIntervalTask=null,this.analyser.disconnect(),this.audioContext.close(),this.stream!=null&&this.stream.getTracks().length>0&&this.stream.getTracks()[0].stop(),[2]})})},n.prototype.setConfig=function(e){throw new Error("setConfig() is not implemented for BrowserFftFeatureExtractor.")},n.prototype.getFeatures=function(){throw new Error("getFeatures() is not implemented for BrowserFftFeatureExtractor. Use the spectrogramCallback field of the constructor config instead.")},n})();function sw(n){var e=n[0].length,t=new Float32Array(n.length*e);return n.forEach(function(r,o){return t.set(r,o*e)}),t}function iw(n,e){var t=new Float32Array(tn(e));return t.set(n,t.length-n.length),xi(t,e)}var p_=(function(){function n(e,t){var r=this;this.period=e,this.suppressionTime=t??0,this.counter=0,E(this.period>0,function(){return"Expected period to be positive, but got "+r.period})}return n.prototype.tick=function(){return this.counter++,this.counter%this.period==0&&(this.suppressionOnset==null||this.counter-this.suppressionOnset>this.suppressionTime)},n.prototype.suppress=function(){this.suppressionOnset=this.counter},n})();function Zl(n){var e=0;n.forEach(function(o){e+=o.byteLength});var t=new Uint8Array(e),r=0;return n.forEach(function(o){t.set(new Uint8Array(o),r),r+=o.byteLength}),t.buffer}function m_(n){var e=0;n.forEach(function(o){return e+=o.length});var t=new Float32Array(e),r=0;return n.forEach(function(o){t.set(o,r),r+=o.length}),t}function ow(n){if(n==null)throw new Error("Received null or undefind string");for(var e=unescape(encodeURIComponent(n)),t=new Uint8Array(e.length),r=0;r<e.length;++r)t[r]=e.charCodeAt(r);return t.buffer}function aw(n){if(n==null)throw new Error("Received null or undefind buffer");var e=new Uint8Array(n);return decodeURIComponent(escape(String.fromCharCode.apply(String,Ro(e))))}function g_(){function n(){return Math.floor(65536*(1+Math.random())).toString(16).substring(1)}return n()+n()+"-"+n()+"-"+n()+"-"+n()+"-"+n()+n()+n()}function y_(n,e){return Math.floor((e-n)*Math.random())+n}function v_(n,e,t){return E(t>0&&t<1,function(){return"validationSplit is expected to be >0 and <1, but got "+t}),V(function(){for(var r=Ni(e,-1).dataSync(),o=[],a=0;a<r.length;++a){var u=r[a];o[u]==null&&(o[u]=[]),o[u].push(a)}var c=o.length,h=[],d=[];for(o.map(function(w){return _o(w)}),a=0;a<c;++a)for(var m=o[a],g=Math.round(m.length*(1-t)),v=0;v<m.length;++v)v<g?h.push(m[v]):d.push(m[v]);return{trainXs:Si(n,h),trainYs:Si(e,h),valXs:Si(n,d),valYs:Si(e,d)}})}function w_(n,e,t){var r,o,a,u,c,h,d,m;E(t>0&&t<1,function(){return"validationSplit is expected to be >0 and <1, but got "+t});for(var g=!Array.isArray(n[0]),v=e,w=[],k=0;k<v.length;++k){var S=v[k];w[S]==null&&(w[S]=[]),w[S].push(k)}var x=w.length,T=[],z=[];for(w.map(function(I){return _o(I)}),k=0;k<x;++k)for(var R=w[k],$=Math.round(R.length*(1-t)),B=0;B<R.length;++B)B<$?T.push(R[B]):z.push(R[B]);if(g){var H=[],Y=[],Z=[],ne=[];try{for(var oe=Qt(T),de=oe.next();!de.done;de=oe.next()){var me=de.value;H.push(n[me]),Y.push(e[me])}}catch(I){r={error:I}}finally{try{de&&!de.done&&(o=oe.return)&&o.call(oe)}finally{if(r)throw r.error}}try{for(var ve=Qt(z),be=ve.next();!be.done;be=ve.next())me=be.value,Z.push(n[me]),ne.push(e[me])}catch(I){a={error:I}}finally{try{be&&!be.done&&(u=ve.return)&&u.call(ve)}finally{if(a)throw a.error}}return{trainXs:H,trainYs:Y,valXs:Z,valYs:ne}}H=[],Y=[],Z=[],ne=[];try{for(var Ne=Qt(T),Ie=Ne.next();!Ie.done;Ie=Ne.next())me=Ie.value,H.push(n[me]),Y.push(e[me])}catch(I){c={error:I}}finally{try{Ie&&!Ie.done&&(h=Ne.return)&&h.call(Ne)}finally{if(c)throw c.error}}try{for(var Ee=Qt(z),D=Ee.next();!D.done;D=Ee.next())me=D.value,Z.push(n[me]),ne.push(e[me])}catch(I){d={error:I}}finally{try{D&&!D.done&&(m=Ee.return)&&m.call(Ee)}finally{if(d)throw d.error}}return{trainXs:H,trainYs:Y,valXs:Z,valYs:ne}}var $l="TFJSSCDS",b_=1,Ii="_background_noise_",lw=(function(){function n(e){if(this.examples={},this.label2Ids={},e!=null)for(var t=E_(e),r=0,o=0;o<t.manifest.length;++o){var a=t.manifest[o],u=a.spectrogramNumFrames*a.spectrogramFrameSize;a.rawAudioNumSamples!=null&&(u+=a.rawAudioNumSamples),u*=4,this.addExample(S_({spec:a,data:t.data.slice(r,r+u)})),r+=u}}return n.prototype.addExample=function(e){E(e!=null,function(){return"Got null or undefined example"}),E(e.label!=null&&e.label.length>0,function(){return"Expected label to be a non-empty string, but got "+JSON.stringify(e.label)});var t=g_();return this.examples[t]=e,e.label in this.label2Ids||(this.label2Ids[e.label]=[]),this.label2Ids[e.label].push(t),t},n.prototype.merge=function(e){var t,r,o,a;E(e!==this,function(){return"Cannot merge a dataset into itself"});var u=e.getVocabulary();try{for(var c=Qt(u),h=c.next();!h.done;h=c.next()){var d=h.value,m=e.getExamples(d);try{for(var g=(o=void 0,Qt(m)),v=g.next();!v.done;v=g.next()){var w=v.value;this.addExample(w.example)}}catch(k){o={error:k}}finally{try{v&&!v.done&&(a=g.return)&&a.call(g)}finally{if(o)throw o.error}}}}catch(k){t={error:k}}finally{try{h&&!h.done&&(r=c.return)&&r.call(c)}finally{if(t)throw t.error}}},n.prototype.getExampleCounts=function(){var e={};for(var t in this.examples){var r=this.examples[t];r.label in e||(e[r.label]=0),e[r.label]++}return e},n.prototype.getExamples=function(e){var t=this;E(e!=null,function(){return"Expected label to be a string, but got "+JSON.stringify(e)}),E(e in this.label2Ids,function(){return'No example of label "'+e+'" exists in dataset'});var r=[];return this.label2Ids[e].forEach(function(o){r.push({uid:o,example:t.examples[o]})}),r},n.prototype.getData=function(e,t){var r=this;E(this.size()>0,function(){return"Cannot get spectrograms as tensors because the dataset is empty"});var o=this.getVocabulary();e!=null?E(o.indexOf(e)!==-1,function(){return"Label "+e+" is not in the vocabulary ("+JSON.stringify(o)+")"}):E(o.length>1,function(){return"One-hot encoding of labels requires the vocabulary to have at least two words, but it has only "+o.length+" word."}),t==null&&(t={});var a,u,c=this.getSortedUniqueNumFrames();c.length===1?(a=t.numFrames==null?c[0]:t.numFrames,u=t.hopFrames==null?1:t.hopFrames):(a=t.numFrames,E(a!=null&&Number.isInteger(a)&&a>0,function(){return"There are "+c.length+" unique lengths among the "+r.size()+" examples of this Dataset, hence numFrames is required. But it is not provided."}),E(a<=c[0],function(){return"numFrames ("+a+") exceeds the minimum numFrames ("+c[0]+") among the examples of the Dataset."}),u=t.hopFrames,E(u!=null&&Number.isInteger(u)&&u>0,function(){return"There are "+c.length+" unique lengths among the "+r.size()+" examples of this Dataset, hence hopFrames is required. But it is not provided."}));var h=t.normalize==null||t.normalize;return V(function(){for(var d,m,g,v=[],w=[],k=[],S=0;S<o.length;++S){var x=o[S];if(e==null||x===e){var T=r.label2Ids[x],z=function(N){var F,U,Q=r.examples[N].spectrogram,ue=Q.frameSize;g==null?g=ue:E(ue===g,function(){return"Mismatch in frameSize  ("+ue+" vs "+g+")"});var fe=Q.data.length/ue,ce=null;x!==Ii&&(ce=Q.keyFrameIndex==null?T_(Q).dataSync()[0]:Q.keyFrameIndex);var pe=yh(Q.data,[fe,ue,1]),we=A_(fe,ce,a,u),ge=function(Ve){var je=V(function(){var wt=it(pe,[Ve[0],0,0],[Ve[1]-Ve[0],-1,-1]);return h?Uo(wt):wt});t.getDataset?w.push(je.dataSync()):v.push(je),e==null&&k.push(S)};try{for(var Le=(F=void 0,Qt(we)),Pe=Le.next();!Pe.done;Pe=Le.next())ge(Pe.value)}catch(Ve){F={error:Ve}}finally{try{Pe&&!Pe.done&&(U=Le.return)&&U.call(Le)}finally{if(F)throw F.error}}Me(pe)};try{for(var R=(d=void 0,Qt(T)),$=R.next();!$.done;$=R.next())z($.value)}catch(N){d={error:N}}finally{try{$&&!$.done&&(m=R.return)&&m.call(R)}finally{if(d)throw d.error}}}}t.augmentByMixingNoiseRatio!=null&&r.augmentByMixingNoise(t.getDataset?w:v,k,t.augmentByMixingNoiseRatio);var B=t.shuffle==null||t.shuffle;if(t.getDataset){var H=t.datasetBatchSize==null?32:t.datasetBatchSize,Y=t.datasetValidationSplit==null?.15:t.datasetValidationSplit;E(Y>0&&Y<1,function(){return"Invalid dataset validation split: "+Y});var Z=w.map(function(N,F){return[N,k[F]]});_o(Z),w=Z.map(function(N){return N[0]});var ne=Z.map(function(N){return N[1]}),oe=w_(w,ne,Y),de=oe.trainXs,me=oe.trainYs,ve=oe.valXs,be=oe.valYs,Ne=pl(de).map(function(N){return yh(N,[a,g,1])}),Ie=pl(me).map(function(N){return zi(xl([N],o.length),[0])}),Ee=zv({xs:Ne,ys:Ie});B&&(Ee=Ee.shuffle(w.length)),Ee=Ee.batch(H).prefetch(4);var D=pl(ve).map(function(N){return yh(N,[a,g,1])}),I=pl(be).map(function(N){return zi(xl([N],o.length),[0])}),A=zv({xs:D,ys:I});return[Ee,A=A.batch(H).prefetch(4)]}if(B){var W=[];v.forEach(function(N,F){W.push({x:N,y:k[F]})}),_o(W),v=W.map(function(N){return N.x}),k=W.map(function(N){return N.y})}var te=e==null?Se(xl(jt(k,"int32"),o.length),"float32"):void 0;return{xs:ss(v),ys:te}})},n.prototype.augmentByMixingNoise=function(e,t,r){var o,a;if(e==null||e.length===0)throw new Error("Cannot perform augmentation because data is null or empty");for(var u=e[0]instanceof Float32Array,c=this.getVocabulary(),h=[],d=[],m=0;m<t.length;++m)c[t[m]]===Ii?h.push(m):d.push(m);if(h.length===0)throw new Error("Cannot perform augmentation by mixing with noise when there is no example with label "+Ii);var g=[],v=[],w=function(x){var T=h[y_(0,h.length)],z=u?jt(e[x]):e[x],R=u?jt(e[T]):e[T],$=V(function(){return Uo(le(z,P(R,r)))});u?g.push($.dataSync()):g.push($),v.push(t[x])};try{for(var k=Qt(d),S=k.next();!S.done;S=k.next())w(S.value)}catch(x){o={error:x}}finally{try{S&&!S.done&&(a=k.return)&&a.call(k)}finally{if(o)throw o.error}}console.log("Data augmentation: mixing noise: added "+g.length+" examples"),g.forEach(function(x){return e.push(x)}),t.push.apply(t,Ro(v))},n.prototype.getSortedUniqueNumFrames=function(){for(var e,t,r=new Set,o=this.getVocabulary(),a=0;a<o.length;++a){var u=o[a],c=this.label2Ids[u];try{for(var h=(e=void 0,Qt(c)),d=h.next();!d.done;d=h.next()){var m=d.value,g=this.examples[m].spectrogram,v=g.data.length/g.frameSize;r.add(v)}}catch(k){e={error:k}}finally{try{d&&!d.done&&(t=h.return)&&t.call(h)}finally{if(e)throw e.error}}}var w=Ro(r);return w.sort(),w},n.prototype.removeExample=function(e){if(!(e in this.examples))throw new Error("Nonexistent example UID: "+e);var t=this.examples[e].label;delete this.examples[e];var r=this.label2Ids[t].indexOf(e);this.label2Ids[t].splice(r,1),this.label2Ids[t].length===0&&delete this.label2Ids[t]},n.prototype.setExampleKeyFrameIndex=function(e,t){if(!(e in this.examples))throw new Error("Nonexistent example UID: "+e);var r=this.examples[e].spectrogram,o=r.data.length/r.frameSize;E(t>=0&&t<o&&Number.isInteger(t),function(){return"Invalid keyFrameIndex: "+t+". Must be >= 0, < "+o+", and an integer."}),r.keyFrameIndex=t},n.prototype.size=function(){return Object.keys(this.examples).length},n.prototype.durationMillis=function(){var e=0;for(var t in this.examples){var r=this.examples[t].spectrogram,o=23.22|r.frameDurationMillis;e+=r.data.length/r.frameSize*o}return e},n.prototype.empty=function(){return this.size()===0},n.prototype.clear=function(){this.examples={}},n.prototype.getVocabulary=function(){var e=new Set;for(var t in this.examples){var r=this.examples[t];e.add(r.label)}var o=Ro(e);return o.sort(),o},n.prototype.serialize=function(e){var t,r,o,a,u=this.getVocabulary();E(!this.empty(),function(){return"Cannot serialize empty Dataset"}),e!=null&&(Array.isArray(e)||(e=[e]),e.forEach(function(T){if(u.indexOf(T)===-1)throw new Error('Word label "'+T+'" does not exist in the vocabulary of this dataset. The vocabulary is: '+JSON.stringify(u)+".")}));var c=[],h=[];try{for(var d=Qt(u),m=d.next();!m.done;m=d.next()){var g=m.value;if(e==null||e.indexOf(g)!==-1){var v=this.label2Ids[g];try{for(var w=(o=void 0,Qt(v)),k=w.next();!k.done;k=w.next()){var S=k.value,x=k_(this.examples[S]);c.push(x.spec),h.push(x.data)}}catch(T){o={error:T}}finally{try{k&&!k.done&&(a=w.return)&&a.call(w)}finally{if(o)throw o.error}}}}}catch(T){t={error:T}}finally{try{m&&!m.done&&(r=d.return)&&r.call(d)}finally{if(t)throw t.error}}return x_({manifest:c,data:Zl(h)})},n})();function k_(n){var e=n.rawAudio!=null,t={label:n.label,spectrogramNumFrames:n.spectrogram.data.length/n.spectrogram.frameSize,spectrogramFrameSize:n.spectrogram.frameSize};n.spectrogram.keyFrameIndex!=null&&(t.spectrogramKeyFrameIndex=n.spectrogram.keyFrameIndex);var r=n.spectrogram.data.buffer.slice(0);return e&&(t.rawAudioNumSamples=n.rawAudio.data.length,t.rawAudioSampleRateHz=n.rawAudio.sampleRateHz,r=Zl([r,n.rawAudio.data.buffer])),{spec:t,data:r}}function S_(n){var e={frameSize:n.spec.spectrogramFrameSize,data:new Float32Array(n.data.slice(0,4*n.spec.spectrogramFrameSize*n.spec.spectrogramNumFrames))};n.spec.spectrogramKeyFrameIndex!=null&&(e.keyFrameIndex=n.spec.spectrogramKeyFrameIndex);var t={label:n.spec.label,spectrogram:e};return n.spec.rawAudioNumSamples!=null&&(t.rawAudio={sampleRateHz:n.spec.rawAudioSampleRateHz,data:new Float32Array(n.data.slice(4*n.spec.spectrogramFrameSize*n.spec.spectrogramNumFrames))}),t}function x_(n){var e=ow(JSON.stringify(n.manifest)),t=ow($l),r=new Uint32Array([b_]),o=new Uint32Array([e.byteLength]);return Zl([Zl([t,r.buffer,o.buffer]),e,n.data])}function E_(n){E(n!=null,function(){return"Received null or undefined buffer"});var e=0,t=aw(n.slice(e,$l.length));E(t===$l,function(){return"Deserialization error: Invalid descriptor"}),e+=$l.length,e+=4;var r=new Uint32Array(n,e,1),o=e+=4;e=o+r[0];var a=aw(n.slice(o,e));return{manifest:JSON.parse(a),data:n.slice(e)}}function A_(n,e,t,r){if(E(Number.isInteger(n)&&n>0,function(){return"snippetLength must be a positive integer, but got "+n}),e!=null&&E(Number.isInteger(e)&&e>=0,function(){return"focusIndex must be a non-negative integer, but got "+e}),E(Number.isInteger(t)&&t>0,function(){return"windowLength must be a positive integer, but got "+t}),E(Number.isInteger(r)&&r>0,function(){return"windowHop must be a positive integer, but got "+r}),E(t<=n,function(){return"windowLength ("+t+") exceeds snippetLength ("+n+")"}),E(e<n,function(){return"focusIndex ("+e+") equals or exceeds snippetLength ("+n+")"}),t===n)return[[0,n]];var o=[];if(e==null){for(var a=0;a+t<=n;)o.push([a,a+t]),a+=r;return o}var u=Math.floor(t/2),c=e-u;for(c<0?c=0:c+t>n&&(c=n-t);!(c-r<0||e>=c-r+t);)c-=r;for(;c+t<=n&&!(e<c);)o.push([c,c+t]),c+=r;return o}function I_(n){return V(function(){var e=n.data.length/n.frameSize,t=zl(n.data,[e,n.frameSize]);return St(t,-1)})}function T_(n){return V(function(){return Ni(I_(n))})}var Wk="0.5.4",N_="_unknown_",wf="tfjs-speech-commands-saved-model-metadata",C_="indexeddb://tfjs-speech-commands-model/",bf={localStorage:typeof window>"u"?null:window.localStorage};function D_(n){return n.split(".").slice(0,2).join(".")}var wl=.25,Vk=(function(){function n(e,t,r){this.MODEL_URL_PREFIX="https://storage.googleapis.com/tfjs-models/tfjs/speech-commands/v"+D_(Wk)+"/browser_fft",this.SAMPLE_RATE_HZ=44100,this.FFT_SIZE=1024,this.DEFAULT_SUPPRESSION_TIME_MILLIS=0,this.streaming=!1,this.transferRecognizers={},E(t==null&&r==null||t!=null&&r!=null,function(){return"modelURL and metadataURL must be both provided or both not provided."}),t==null?(e==null?e=n.DEFAULT_VOCABULARY_NAME:E(n.VALID_VOCABULARY_NAMES.indexOf(e)!==-1,function(){return"Invalid vocabulary name: '"+e+"'"}),this.vocabulary=e,this.modelArtifactsOrURL=this.MODEL_URL_PREFIX+"/"+this.vocabulary+"/model.json",this.metadataOrURL=this.MODEL_URL_PREFIX+"/"+this.vocabulary+"/metadata.json"):(E(e==null,function(){return"vocabulary name must be null or undefined when modelURL is provided"}),this.modelArtifactsOrURL=t,this.metadataOrURL=r),this.parameters={sampleRateHz:this.SAMPLE_RATE_HZ,fftSize:this.FFT_SIZE}}return n.prototype.listen=function(e,t){return ht(this,void 0,void 0,function(){var r,o,a,u,c,h=this;return ft(this,function(d){switch(d.label){case 0:if(this.streaming)throw new Error("Cannot start streaming again when streaming is ongoing.");return[4,this.ensureModelLoaded()];case 1:if(d.sent(),t==null&&(t={}),r=t.probabilityThreshold==null?0:t.probabilityThreshold,t.includeEmbedding&&(r=0),E(r>=0&&r<=1,function(){return"Invalid probabilityThreshold value: "+r}),o=t.invokeCallbackOnNoiseAndUnknown!=null&&t.invokeCallbackOnNoiseAndUnknown,t.includeEmbedding&&(o=!0),t.suppressionTimeMillis<0)throw new Error("suppressionTimeMillis is expected to be >= 0, but got "+t.suppressionTimeMillis);return a=t.overlapFactor==null?.5:t.overlapFactor,E(a>=0&&a<1,function(){return"Expected overlapFactor to be >= 0 and < 1, but got "+a}),u=function(m,g){return ht(h,void 0,void 0,function(){var v,w,k,S,x,T,z,R,$,B,H;return ft(this,function(Y){switch(Y.label){case 0:return v=Uo(m),t.includeEmbedding?[4,this.ensureModelWithEmbeddingOutputCreated()]:[3,2];case 1:return Y.sent(),H=sp(this.modelWithEmbeddingOutput.predict(v),2),w=H[0],k=H[1],[3,3];case 2:w=this.model.predict(v),Y.label=3;case 3:return[4,w.data()];case 4:return S=Y.sent(),[4,(x=w.argMax(-1)).data()];case 5:return T=Y.sent()[0],z=Math.max.apply(Math,Ro(S)),Me([w,x,v]),z<r?[2,!1]:[3,6];case 6:return R=void 0,t.includeSpectrogram?($={},[4,m.data()]):[3,8];case 7:$.data=Y.sent(),$.frameSize=this.nonBatchInputShape[1],R=$,Y.label=8;case 8:return B=!0,o||this.words[T]!==Ii&&this.words[T]!==N_||(B=!1),B&&e({scores:S,spectrogram:R,embedding:k}),[2,B]}})})},c=t.suppressionTimeMillis==null?this.DEFAULT_SUPPRESSION_TIME_MILLIS:t.suppressionTimeMillis,this.audioDataExtractor=new Jf({sampleRateHz:this.parameters.sampleRateHz,numFramesPerSpectrogram:this.nonBatchInputShape[0],columnTruncateLength:this.nonBatchInputShape[1],suppressionTimeMillis:c,spectrogramCallback:u,overlapFactor:a}),[4,this.audioDataExtractor.start(t.audioTrackConstraints)];case 2:return d.sent(),this.streaming=!0,[2]}})})},n.prototype.ensureModelLoaded=function(){return ht(this,void 0,void 0,function(){var e,t,r,o,a=this;return ft(this,function(u){switch(u.label){case 0:return this.model!=null?[2]:[4,this.ensureMetadataLoaded()];case 1:return u.sent(),typeof this.modelArtifactsOrURL!="string"?[3,3]:[4,Hf(this.modelArtifactsOrURL)];case 2:return e=u.sent(),[3,5];case 3:return[4,Hf(O2(this.modelArtifactsOrURL.modelTopology,this.modelArtifactsOrURL.weightSpecs,this.modelArtifactsOrURL.weightData))];case 4:e=u.sent(),u.label=5;case 5:if(e.inputs.length!==1)throw new Error("Expected model to have 1 input, but got a model with "+e.inputs.length+" inputs");if(e.inputs[0].shape.length!==4)throw new Error("Expected model to have an input shape of rank 4, but got an input shape of rank "+e.inputs[0].shape.length);if(e.inputs[0].shape[3]!==1)throw new Error("Expected model to have an input shape with 1 as the last dimension, but got input shape"+JSON.stringify(e.inputs[0].shape[3])+"}");if((t=e.outputShape).length!==2)throw new Error("Expected loaded model to have an output shape of rank 2,but received shape "+JSON.stringify(t));if(t[1]!==this.words.length)throw new Error("Mismatch between the last dimension of model's output shape ("+t[1]+") and number of words ("+this.words.length+").");return this.model=e,this.freezeModel(),this.nonBatchInputShape=e.inputs[0].shape.slice(1),this.elementsPerExample=1,e.inputs[0].shape.slice(1).forEach(function(c){return a.elementsPerExample*=c}),this.warmUpModel(),r=this.parameters.fftSize/this.parameters.sampleRateHz*1e3,o=e.inputs[0].shape[1],this.parameters.spectrogramDurationMillis=o*r,[2]}})})},n.prototype.ensureModelWithEmbeddingOutputCreated=function(){return ht(this,void 0,void 0,function(){var e,t;return ft(this,function(r){switch(r.label){case 0:return this.modelWithEmbeddingOutput!=null?[2]:[4,this.ensureModelLoaded()];case 1:for(r.sent(),t=this.model.layers.length-2;t>=0;--t)if(this.model.layers[t].getClassName()==="Dense"){e=this.model.layers[t];break}if(e==null)throw new Error("Failed to find second last dense layer in the original model.");return this.modelWithEmbeddingOutput=v1({inputs:this.model.inputs,outputs:[this.model.outputs[0],e.output]}),[2]}})})},n.prototype.warmUpModel=function(){var e=this;V(function(){for(var t=Ot([1].concat(e.nonBatchInputShape)),r=0;r<3;++r)e.model.predict(t)})},n.prototype.ensureMetadataLoaded=function(){return ht(this,void 0,void 0,function(){var e,t,r;return ft(this,function(o){switch(o.label){case 0:return this.words!=null?[2]:typeof this.metadataOrURL!="string"?[3,2]:[4,c_(this.metadataOrURL)];case 1:return t=o.sent(),[3,3];case 2:t=this.metadataOrURL,o.label=3;case 3:if((e=t).wordLabels==null){if((r=e.words)==null)throw new Error('Cannot find field "words" or "wordLabels" in metadata JSON file');this.words=r}else this.words=e.wordLabels;return[2]}})})},n.prototype.stopListening=function(){return ht(this,void 0,void 0,function(){return ft(this,function(e){switch(e.label){case 0:if(!this.streaming)throw new Error("Cannot stop streaming when streaming is not ongoing.");return[4,this.audioDataExtractor.stop()];case 1:return e.sent(),this.streaming=!1,[2]}})})},n.prototype.isListening=function(){return this.streaming},n.prototype.wordLabels=function(){return this.words},n.prototype.params=function(){return this.parameters},n.prototype.modelInputShape=function(){if(this.model==null)throw new Error("Model has not been loaded yet. Load model by calling ensureModelLoaded(), recognize(), or listen().");return this.model.inputs[0].shape},n.prototype.recognize=function(e,t){return ht(this,void 0,void 0,function(){var r,o,a,u,c,h,d,m,g,v,w,k,S;return ft(this,function(x){switch(x.label){case 0:return t==null&&(t={}),[4,this.ensureModelLoaded()];case 1:return x.sent(),e!=null?[3,3]:[4,this.recognizeOnline()];case 2:r=x.sent(),e=r.data,x.label=3;case 3:if(e instanceof ot)this.checkInputTensorShape(e),a=e,o=e.shape[0];else{if(e.length%this.elementsPerExample)throw new Error("The length of the input Float32Array "+e.length+" is not divisible by the number of tensor elements per per example expected by the model "+this.elementsPerExample+".");o=e.length/this.elementsPerExample,a=KN(e,[o].concat(this.nonBatchInputShape))}return c={scores:null},t.includeEmbedding?[4,this.ensureModelWithEmbeddingOutputCreated()]:[3,5];case 4:return x.sent(),h=this.modelWithEmbeddingOutput.predict(a),u=h[0],c.embedding=h[1],[3,6];case 5:u=this.model.predict(a),x.label=6;case 6:return o!==1?[3,8]:(d=c,[4,u.data()]);case 7:return d.scores=x.sent(),[3,10];case 8:return m=$i(u),g=m.map(function(T){return T.data()}),v=c,[4,Promise.all(g)];case 9:v.scores=x.sent(),Me(m),x.label=10;case 10:return t.includeSpectrogram?(w=c,k={},e instanceof ot?[4,e.data()]:[3,12]):[3,14];case 11:return S=x.sent(),[3,13];case 12:S=e,x.label=13;case 13:w.spectrogram=(k.data=S,k.frameSize=this.nonBatchInputShape[1],k),x.label=14;case 14:return Me(u),[2,c]}})})},n.prototype.recognizeOnline=function(){return ht(this,void 0,void 0,function(){var e=this;return ft(this,function(t){return[2,new Promise(function(r,o){e.audioDataExtractor=new Jf({sampleRateHz:e.parameters.sampleRateHz,numFramesPerSpectrogram:e.nonBatchInputShape[0],columnTruncateLength:e.nonBatchInputShape[1],suppressionTimeMillis:0,spectrogramCallback:function(a){return ht(e,void 0,void 0,function(){var u,c,h;return ft(this,function(d){switch(d.label){case 0:return u=Uo(a),[4,this.audioDataExtractor.stop()];case 1:return d.sent(),c=r,h={},[4,u.data()];case 2:return c.apply(void 0,[(h.data=d.sent(),h.frameSize=this.nonBatchInputShape[1],h)]),u.dispose(),[2,!1]}})})},overlapFactor:0}),e.audioDataExtractor.start()})]})})},n.prototype.createTransfer=function(e){if(this.model==null)throw new Error("Model has not been loaded yet. Load model by calling ensureModelLoaded(), recognizer(), or listen().");E(e!=null&&typeof e=="string"&&e.length>1,function(){return"Expected the name for a transfer-learning recognized to be a non-empty string, but got "+JSON.stringify(e)}),E(this.transferRecognizers[e]==null,function(){return"There is already a transfer-learning model named '"+e+"'"});var t=new z_(e,this.parameters,this.model);return this.transferRecognizers[e]=t,t},n.prototype.freezeModel=function(){var e,t;try{for(var r=Qt(this.model.layers),o=r.next();!o.done;o=r.next())o.value.trainable=!1}catch(a){e={error:a}}finally{try{o&&!o.done&&(t=r.return)&&t.call(r)}finally{if(e)throw e.error}}},n.prototype.checkInputTensorShape=function(e){var t=this.model.inputs[0].shape.length;if(e.shape.length!==t)throw new Error("Expected input Tensor to have rank "+t+", but got rank "+e.shape.length+" that differs ");var r=e.shape.slice(1),o=this.model.inputs[0].shape.slice(1);if(!nn(r,o))throw new Error("Expected input to have shape [null,"+o+"], but got shape [null,"+r+"]")},n.VALID_VOCABULARY_NAMES=["18w","directional4w"],n.DEFAULT_VOCABULARY_NAME="18w",n})(),z_=(function(n){function e(t,r,o){var a=n.call(this)||this;return a.name=t,a.parameters=r,a.baseModel=o,E(t!=null&&typeof t=="string"&&t.length>0,function(){return"The name of a transfer model must be a non-empty string, but got "+JSON.stringify(t)}),a.nonBatchInputShape=a.baseModel.inputs[0].shape.slice(1),a.words=null,a.dataset=new lw,a}return u_(e,n),e.prototype.collectExample=function(t,r){return ht(this,void 0,void 0,function(){var o,a,u,c,h=this;return ft(this,function(d){if(E(!this.streaming,function(){return"Cannot start collection of transfer-learning example because a streaming recognition or transfer-learning example collection is ongoing"}),E(t!=null&&typeof t=="string"&&t.length>0,function(){return"Must provide a non-empty string when collecting transfer-learning example"}),r==null&&(r={}),r.durationMultiplier!=null&&r.durationSec!=null)throw new Error("durationMultiplier and durationSec are mutually exclusive, but are both specified.");return r.durationSec!=null?(E(r.durationSec>0,function(){return"Expected durationSec to be > 0, but got "+r.durationSec}),a=this.parameters.fftSize/this.parameters.sampleRateHz,o=Math.ceil(r.durationSec/a)):r.durationMultiplier!=null?(E(r.durationMultiplier>=1,function(){return"Expected duration multiplier to be >= 1, but got "+r.durationMultiplier}),o=Math.round(this.nonBatchInputShape[0]*r.durationMultiplier)):o=this.nonBatchInputShape[0],r.snippetDurationSec!=null&&(E(r.snippetDurationSec>0,function(){return"snippetDurationSec is expected to be > 0, but got "+r.snippetDurationSec}),E(r.onSnippet!=null,function(){return"onSnippet must be provided if snippetDurationSec is provided."})),r.onSnippet!=null&&E(r.snippetDurationSec!=null,function(){return"snippetDurationSec must be provided if onSnippet is provided."}),u=this.parameters.fftSize/this.parameters.sampleRateHz,c=u*o,this.streaming=!0,[2,new Promise(function(m){var g=r.snippetDurationSec==null?1:r.snippetDurationSec/c,v=1-g,w=Math.round(1/g),k=0,S=-1,x=[];h.audioDataExtractor=new Jf({sampleRateHz:h.parameters.sampleRateHz,numFramesPerSpectrogram:o,columnTruncateLength:h.nonBatchInputShape[1],suppressionTimeMillis:0,spectrogramCallback:function(T,z){return ht(h,void 0,void 0,function(){var R,$,B,H,Y,Z,ne,oe,de,me,ve,be,Ne,Ie,Ee,D,I,A,W,te;return ft(this,function(N){switch(N.label){case 0:return r.onSnippet!=null?[3,7]:(R=Uo(T),B=($=this.dataset).addExample,H={label:t},Y={},[4,R.data()]);case 1:return H.spectrogram=(Y.data=N.sent(),Y.frameSize=this.nonBatchInputShape[1],Y),r.includeRawAudio?(ne={},[4,z.data()]):[3,3];case 2:return ne.data=N.sent(),ne.sampleRateHz=this.audioDataExtractor.sampleRateHz,Z=ne,[3,4];case 3:Z=void 0,N.label=4;case 4:return B.apply($,[(H.rawAudio=Z,H)]),R.dispose(),[4,this.audioDataExtractor.stop()];case 5:return N.sent(),this.streaming=!1,this.collateTransferWords(),oe=m,de={},[4,T.data()];case 6:return oe.apply(void 0,[(de.data=N.sent(),de.frameSize=this.nonBatchInputShape[1],de)]),[3,13];case 7:return[4,T.data()];case 8:for(me=N.sent(),S===-1&&(S=me.length),ve=S-1;me[ve]!==0&&ve>=0;)ve--;return be=S-ve-1,S=ve+1,Ne=me.slice(me.length-be,me.length),x.push(Ne),r.onSnippet!=null&&r.onSnippet({data:Ne,frameSize:this.nonBatchInputShape[1]}),k++!==w?[3,13]:[4,this.audioDataExtractor.stop()];case 9:return N.sent(),this.streaming=!1,this.collateTransferWords(),Ie=h_(m_(x)),Ee={data:Ie,frameSize:this.nonBatchInputShape[1]},I=(D=this.dataset).addExample,A={label:t,spectrogram:Ee},r.includeRawAudio?(te={},[4,z.data()]):[3,11];case 10:return te.data=N.sent(),te.sampleRateHz=this.audioDataExtractor.sampleRateHz,W=te,[3,12];case 11:W=void 0,N.label=12;case 12:I.apply(D,[(A.rawAudio=W,A)]),m(Ee),N.label=13;case 13:return[2,!1]}})})},overlapFactor:v,includeRawAudio:r.includeRawAudio}),h.audioDataExtractor.start(r.audioTrackConstraints)})]})})},e.prototype.clearExamples=function(){var t=this;E(this.words!=null&&this.words.length>0&&!this.dataset.empty(),function(){return"No transfer learning examples exist for model name "+t.name}),this.dataset.clear(),this.words=null},e.prototype.countExamples=function(){if(this.dataset.empty())throw new Error("No examples have been collected for transfer-learning model named '"+this.name+"' yet.");return this.dataset.getExampleCounts()},e.prototype.getExamples=function(t){return this.dataset.getExamples(t)},e.prototype.setExampleKeyFrameIndex=function(t,r){this.dataset.setExampleKeyFrameIndex(t,r)},e.prototype.removeExample=function(t){this.dataset.removeExample(t),this.collateTransferWords()},e.prototype.isDatasetEmpty=function(){return this.dataset.empty()},e.prototype.loadExamples=function(t,r){var o,a,u,c;r===void 0&&(r=!1);var h=new lw(t);r&&this.clearExamples();var d=h.getVocabulary();try{for(var m=Qt(d),g=m.next();!g.done;g=m.next()){var v=g.value,w=h.getExamples(v);try{for(var k=(u=void 0,Qt(w)),S=k.next();!S.done;S=k.next()){var x=S.value;this.dataset.addExample(x.example)}}catch(T){u={error:T}}finally{try{S&&!S.done&&(c=k.return)&&c.call(k)}finally{if(u)throw u.error}}}}catch(T){o={error:T}}finally{try{g&&!g.done&&(a=m.return)&&a.call(m)}finally{if(o)throw o.error}}this.collateTransferWords()},e.prototype.serializeExamples=function(t){return this.dataset.serialize(t)},e.prototype.collateTransferWords=function(){this.words=this.dataset.getVocabulary()},e.prototype.collectTransferDataAsTensors=function(t,r){var o=this.nonBatchInputShape[0];t=t||wl;var a=Math.round(t*o),u=this.dataset.getData(null,Kf({numFrames:o,hopFrames:a},r));return{xs:u.xs,ys:u.ys}},e.prototype.collectTransferDataAsTfDataset=function(t,r,o,a){r===void 0&&(r=.15),o===void 0&&(o=32);var u=this.nonBatchInputShape[0];t=t||wl;var c=Math.round(t*u);return this.dataset.getData(null,Kf({numFrames:u,hopFrames:c,getDataset:!0,datasetBatchSize:o,datasetValidationSplit:r},a))},e.prototype.train=function(t){return ht(this,void 0,void 0,function(){var r,o=this;return ft(this,function(a){return E(this.words!=null&&this.words.length>0,function(){return"Cannot train transfer-learning model '"+o.name+"' because no transfer learning example has been collected."}),E(this.words.length>1,function(){return"Cannot train transfer-learning model '"+o.name+"' because only 1 word label ('"+JSON.stringify(o.words)+"') has been collected for transfer learning. Requires at least 2."}),t.fineTuningEpochs!=null&&E(t.fineTuningEpochs>=0&&Number.isInteger(t.fineTuningEpochs),function(){return"If specified, fineTuningEpochs must be a non-negative integer, but received "+t.fineTuningEpochs}),t==null&&(t={}),this.model==null&&this.createTransferModelFromBaseModel(),this.secondLastBaseDenseLayer.trainable=!1,this.model.compile({loss:"categoricalCrossentropy",optimizer:t.optimizer||"sgd",metrics:["acc"]}),r=t.fitDatasetDurationMillisThreshold==null?6e4:t.fitDatasetDurationMillisThreshold,this.dataset.durationMillis()>r?(console.log("Detected large dataset: total duration = "+this.dataset.durationMillis()+" ms > "+r+" ms. Training transfer model using fitDataset() instead of fit()"),[2,this.trainOnDataset(t)]):[2,this.trainOnTensors(t)]})})},e.prototype.trainOnDataset=function(t){return ht(this,void 0,void 0,function(){var r,o,a,u,c,h,d,m,g;return ft(this,function(v){switch(v.label){case 0:return E(t.epochs>0,function(){return"Invalid config.epochs"}),r=t.batchSize==null?32:t.batchSize,o=t.windowHopRatio||wl,a=sp(this.collectTransferDataAsTfDataset(o,t.validationSplit,r,{augmentByMixingNoiseRatio:t.augmentByMixingNoiseRatio}),2),u=a[0],c=a[1],h=zn(),[4,this.model.fitDataset(u,{epochs:t.epochs,validationData:t.validationSplit>0?c:null,callbacks:t.callback==null?null:[t.callback]})];case 1:return d=v.sent(),console.log("fitDataset() took "+(zn()-h).toFixed(2)+" ms"),t.fineTuningEpochs!=null&&t.fineTuningEpochs>0?(m=zn(),[4,this.fineTuningUsingTfDatasets(t,u,c)]):[3,3];case 2:return g=v.sent(),console.log("fitDataset() (fine-tuning) took "+(zn()-m).toFixed(2)+" ms"),[2,[d,g]];case 3:return[2,d]}})})},e.prototype.trainOnTensors=function(t){return ht(this,void 0,void 0,function(){var r,o,a,u,c,h,d,m,g,v;return ft(this,function(w){switch(w.label){case 0:r=t.windowHopRatio||wl,o=this.collectTransferDataAsTensors(r,{augmentByMixingNoiseRatio:t.augmentByMixingNoiseRatio}),a=o.xs,u=o.ys,console.log("Training data: xs.shape = "+a.shape+", ys.shape = "+u.shape),w.label=1;case 1:return w.trys.push([1,,6,7]),t.validationSplit!=null?(m=v_(a,u,t.validationSplit),c=m.trainXs,h=m.trainYs,d=[m.valXs,m.valYs]):(c=a,h=u),[4,this.model.fit(c,h,{epochs:t.epochs==null?20:t.epochs,validationData:d,batchSize:t.batchSize,callbacks:t.callback==null?null:[t.callback]})];case 2:return g=w.sent(),t.fineTuningEpochs!=null&&t.fineTuningEpochs>0?[4,this.fineTuningUsingTensors(t,c,h,d)]:[3,4];case 3:return v=w.sent(),[2,[g,v]];case 4:return[2,g];case 5:return[3,7];case 6:return Me([a,u,c,h,d]),[7];case 7:return[2]}})})},e.prototype.fineTuningUsingTfDatasets=function(t,r,o){return ht(this,void 0,void 0,function(){var a,u,c;return ft(this,function(h){switch(h.label){case 0:return a=this.secondLastBaseDenseLayer.trainable,this.secondLastBaseDenseLayer.trainable=!0,u=t.fineTuningOptimizer==null?"sgd":t.fineTuningOptimizer,this.model.compile({loss:"categoricalCrossentropy",optimizer:u,metrics:["acc"]}),[4,this.model.fitDataset(r,{epochs:t.fineTuningEpochs,validationData:o,callbacks:t.callback==null?null:[t.callback]})];case 1:return c=h.sent(),this.secondLastBaseDenseLayer.trainable=a,[2,c]}})})},e.prototype.fineTuningUsingTensors=function(t,r,o,a){return ht(this,void 0,void 0,function(){var u,c,h;return ft(this,function(d){switch(d.label){case 0:return u=this.secondLastBaseDenseLayer.trainable,this.secondLastBaseDenseLayer.trainable=!0,c=t.fineTuningOptimizer==null?"sgd":t.fineTuningOptimizer,this.model.compile({loss:"categoricalCrossentropy",optimizer:c,metrics:["acc"]}),[4,this.model.fit(r,o,{epochs:t.fineTuningEpochs,validationData:a,batchSize:t.batchSize,callbacks:t.fineTuningCallback==null?null:[t.fineTuningCallback]})];case 1:return h=d.sent(),this.secondLastBaseDenseLayer.trainable=u,[2,h]}})})},e.prototype.evaluate=function(t){return ht(this,void 0,void 0,function(){var r,o=this;return ft(this,function(a){return E(t.wordProbThresholds!=null&&t.wordProbThresholds.length>0,function(){return"Received null or empty wordProbThresholds"}),r=0,E(this.words[r]===Ii,function(){return"Cannot perform evaluation when the first tag is not "+Ii}),[2,V(function(){for(var u=[],c=0,h=o.collectTransferDataAsTensors(t.windowHopRatio),d=h.xs,m=h.ys.argMax(-1).dataSync(),g=o.model.predict(d),v=Dr(it(g,[0,1],[g.shape[0],g.shape[1]-1]),-1),w=g.shape[0],k=0;k<t.wordProbThresholds.length;++k){for(var S=t.wordProbThresholds[k],x=v.greater(Je(S)).dataSync(),T=0,z=0,R=0,$=0,B=0;B<w;++B)m[B]===r?(T++,x[B]&&R++):(z++,x[B]&&$++);var H=R/T,Y=$/z;u.push({probThreshold:S,fpr:H,tpr:Y}),console.log("ROC thresh="+S+": fpr="+H.toFixed(4)+", tpr="+Y.toFixed(4)),k>0&&(c+=Math.abs(u[k-1].fpr-u[k].fpr)*(u[k-1].tpr+u[k].tpr)/2)}return{rocCurve:u,auc:c}})]})})},e.prototype.createTransferModelFromBaseModel=function(){var t=this;E(this.words!=null,function(){return"No word example is available for tranfer-learning model of name "+t.name});for(var r=this.baseModel.layers,o=r.length-2;o>=0&&r[o].getClassName().toLowerCase()!=="dense";)o--;if(o<0)throw new Error("Cannot find a hidden dense layer in the base model.");this.secondLastBaseDenseLayer=r[o];var a=this.secondLastBaseDenseLayer.output;this.transferHead=JR(),this.transferHead.add(l_({units:this.words.length,activation:"softmax",inputShape:a.shape.slice(1),name:"NewHeadDense"}));var u=this.transferHead.apply(a);this.model=v1({inputs:this.baseModel.inputs,outputs:u})},e.prototype.modelInputShape=function(){return this.baseModel.inputs[0].shape},e.prototype.getMetadata=function(){return{tfjsSpeechCommandsVersion:Wk,modelName:this.name,timeStamp:new Date().toISOString(),wordLabels:this.wordLabels()}},e.prototype.save=function(t){return ht(this,void 0,void 0,function(){var r,o,a;return ft(this,function(u){return r=t!=null,t=t||uw(this.name),r||(o=bf.localStorage.getItem(wf),(a=o==null?{}:JSON.parse(o))[this.name]=this.getMetadata(),bf.localStorage.setItem(wf,JSON.stringify(a))),console.log("Saving model to "+t),[2,this.model.save(t)]})})},e.prototype.load=function(t){return ht(this,void 0,void 0,function(){var r,o,a;return ft(this,function(u){switch(u.label){case 0:if(r=t!=null,t=t||uw(this.name),!r){if((o=JSON.parse(bf.localStorage.getItem(wf)))==null||o[this.name]==null)throw new Error("Cannot find metadata for transfer model named "+this.name+'"');this.words=o[this.name].wordLabels,console.log("Loaded word list for model named "+this.name+": "+this.words)}return a=this,[4,Hf(t)];case 1:return a.model=u.sent(),console.log("Loaded model from "+t+":"),this.model.summary(),[2]}})})},e.prototype.createTransfer=function(t){throw new Error("Creating transfer-learned recognizer from a transfer-learned recognizer is not supported.")},e})(Vk);function uw(n){return""+C_+n}function $_(n,e,t,r){if(E(r!=null,function(){return"customModelURL and customMetadataURL must be both provided or both not provided."}),E(e==null,function(){return"vocabulary name must be null or undefined when modelURL is provided."}),n==="BROWSER_FFT")return new Vk(e,t,r)}var kf={exports:{}},Sf,cw;function M_(){if(cw)return Sf;cw=1;var n="SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";return Sf=n,Sf}var xf,hw;function R_(){if(hw)return xf;hw=1;var n=M_();function e(){}function t(){}return t.resetWarningCache=e,xf=function(){function r(u,c,h,d,m,g){if(g!==n){var v=new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");throw v.name="Invariant Violation",v}}r.isRequired=r;function o(){return r}var a={array:r,bigint:r,bool:r,func:r,number:r,object:r,string:r,symbol:r,any:r,arrayOf:o,element:r,elementType:r,instanceOf:o,node:r,objectOf:o,oneOf:o,oneOfType:o,shape:o,exact:o,checkPropTypes:t,resetWarningCache:e};return a.PropTypes=a,a},xf}var fw;function __(){return fw||(fw=1,kf.exports=R_()()),kf.exports}var F_=__();const Gk=Xf(F_),qk=({maze:n})=>Xe.jsxs("div",{className:"flex ",children:[Xe.jsx("div",{className:"border-black border grid grid-cols-9",children:n&&Array.isArray(n)&&n.length>0&&n.map((e,t)=>e.map((r,o)=>Xe.jsx("div",{className:`
                                h-8 tablet:h-12 w-8 tablet:w-12 ring-[100px] ring-inset
                            ${r===1&&"ring-gray-900"} 
                            ${r===0&&"ring-white border  border-black"} 
                            ${r==="a"&&"ring-sky-500 border border-black"}
                            `},`${t}-${o}`)))}),Xe.jsx("div",{className:"grid grid-cols-1 items-center border-black border-2 bg-sky-500",children:Xe.jsx("p",{className:"rotate-[270deg] font-bold justify-self-center tablet:text-lg",children:"Finish"})})]});qk.propTypes={maze:Gk.array.isRequired};function L_(n){if(n.length===0)return-1;let e=0;for(let t=1;t<n.length;t++)n[t]>n[e]&&(e=t);return e}function O_(n){return n.map(e=>[...e])}function P_(n,e){for(let t=0;t<n.length;t++)for(let r=0;r<n[t].length;r++)if(n[t][r]===e)return[t,r];return[-1,-1]}function B_(n,e){const[t,r]=e;return t>=0&&t<n.length&&r>=0&&r<n[t].length?n[t][r]:null}function U_(){window.location.reload()}function j_(n){for(let e of n)if(e[e.length-1]!==1)return!1;return!0}function Hk(n,e){const t=[],r=2*n-1,o=2*e-1;for(let g=0;g<r;g++){const v=[];for(let w=0;w<o;w++)v.push(1);t.push(v)}const a=0,u=0;t[a][u]=0;const c=[[-2,0],[2,0],[0,-2],[0,2]];function h(g,v){return g>=0&&g<r&&v>=0&&v<o}function d(g){for(let v=g.length-1;v>0;v--){const w=Math.floor(Math.random()*(v+1));[g[v],g[w]]=[g[w],g[v]]}}function m(g,v){d(c);for(let w of c){const k=g+w[0],S=v+w[1];h(k,S)&&t[k][S]===1&&(t[k][S]=0,t[g+w[0]/2][v+w[1]/2]=0,m(k,S))}}return m(a,u),t[a][u]="a",j_(t)?Hk(5,5):t}function W_(n,e,t){const r=O_(n);let o,a,u=!1;for(o=0;o<r.length;o++){for(a=0;a<r[o].length;a++)if(r[o][a]===e){u=!0;break}if(u)break}if(u)switch(t){case"right":a<r[o].length-1&&(r[o][a]=r[o][a+1],r[o][a+1]=e);break;case"left":a>0&&(r[o][a]=r[o][a-1],r[o][a-1]=e);break;case"up":o>0&&(r[o][a]=r[o-1][a],r[o-1][a]=e);break;case"down":o<r.length-1&&(r[o][a]=r[o+1][a],r[o+1][a]=e);break}const c=P_(n,"a"),h=B_(r,c);if(h===0)return{maze:r,message:"",messageValue:0};if(h===1)return{maze:n,message:"You've hit a wall!",messageValue:1};if(h==="a"&&c[1]===8)return{maze:n,message:"You've won!",messageValue:2};if(h==="a")return{maze:n,message:"You're trying to go out of bounds!",messageValue:3}}const Kk=({messageObj:n})=>Xe.jsx("div",{className:"min-h-[156px] max-w-[357px] tablet:min-w-[357px] tablet:max-w-[459px] lg:min-w-[459px] lg:max-w-[509px]",children:Xe.jsxs("div",{className:`border-2 p-4 tablet:p-8 text-sm tablet:text-lg min-h-full grid justify-items-center items-center
${n.messageValue===0&&"border-sky-500 bg-sky-200"}
${n.messageValue===1&&"border-red-500 bg-red-200"}
${n.messageValue===2&&"border-green-500 bg-green-200"}
${n.messageValue===3&&"border-yellow-500 bg-yellow-200"}
`,children:[n.messageValue===0&&Xe.jsxs(Xe.Fragment,{children:[Xe.jsx("p",{children:`Press the microphone. While it's blinking instruct the blue square to move about the maze using the words "left", "right", "up" and "down".`}),Xe.jsx("p",{children:" Cross the FINISH line to win!"})]}),n.messageValue===1&&Xe.jsx("p",{children:n.message}),n.messageValue===2&&Xe.jsxs(Xe.Fragment,{children:[Xe.jsx("p",{children:n.message}),Xe.jsx("button",{className:"border-2 border-green-500 bg-green-500 px-2 hover:animate-quickPing",onClick:U_,children:"Play Again"})]}),n.messageValue===3&&Xe.jsx("p",{children:n.message})]})});Kk.propTypes={messageObj:Gk.object.isRequired};var ip={};(function n(e,t,r,o){var a=!!(e.Worker&&e.Blob&&e.Promise&&e.OffscreenCanvas&&e.OffscreenCanvasRenderingContext2D&&e.HTMLCanvasElement&&e.HTMLCanvasElement.prototype.transferControlToOffscreen&&e.URL&&e.URL.createObjectURL),u=typeof Path2D=="function"&&typeof DOMMatrix=="function";function c(){}function h(D){var I=t.exports.Promise,A=I!==void 0?I:e.Promise;return typeof A=="function"?new A(D):(D(c,c),null)}var d=(function(){var D=Math.floor(16.666666666666668),I,A,W={},te=0;return typeof requestAnimationFrame=="function"&&typeof cancelAnimationFrame=="function"?(I=function(N){var F=Math.random();return W[F]=requestAnimationFrame(function U(Q){te===Q||te+D-1<Q?(te=Q,delete W[F],N()):W[F]=requestAnimationFrame(U)}),F},A=function(N){W[N]&&cancelAnimationFrame(W[N])}):(I=function(N){return setTimeout(N,D)},A=function(N){return clearTimeout(N)}),{frame:I,cancel:A}})(),m=(function(){var D,I,A={};function W(te){function N(F,U){te.postMessage({options:F||{},callback:U})}te.init=function(U){var Q=U.transferControlToOffscreen();te.postMessage({canvas:Q},[Q])},te.fire=function(U,Q,ue){if(I)return N(U,null),I;var fe=Math.random().toString(36).slice(2);return I=h(function(ce){function pe(we){we.data.callback===fe&&(delete A[fe],te.removeEventListener("message",pe),I=null,ue(),ce())}te.addEventListener("message",pe),N(U,fe),A[fe]=pe.bind(null,{data:{callback:fe}})}),I},te.reset=function(){te.postMessage({reset:!0});for(var U in A)A[U](),delete A[U]}}return function(){if(D)return D;if(!r&&a){var te=["var CONFETTI, SIZE = {}, module = {};","("+n.toString()+")(this, module, true, SIZE);","onmessage = function(msg) {","  if (msg.data.options) {","    CONFETTI(msg.data.options).then(function () {","      if (msg.data.callback) {","        postMessage({ callback: msg.data.callback });","      }","    });","  } else if (msg.data.reset) {","    CONFETTI && CONFETTI.reset();","  } else if (msg.data.resize) {","    SIZE.width = msg.data.resize.width;","    SIZE.height = msg.data.resize.height;","  } else if (msg.data.canvas) {","    SIZE.width = msg.data.canvas.width;","    SIZE.height = msg.data.canvas.height;","    CONFETTI = module.exports.create(msg.data.canvas);","  }","}"].join(`
`);try{D=new Worker(URL.createObjectURL(new Blob([te])))}catch(N){return typeof console!==void 0&&typeof console.warn=="function"&&console.warn(" Could not load worker",N),null}W(D)}return D}})(),g={particleCount:50,angle:90,spread:45,startVelocity:45,decay:.9,gravity:1,drift:0,ticks:200,x:.5,y:.5,shapes:["square","circle"],zIndex:100,colors:["#26ccff","#a25afd","#ff5e7e","#88ff5a","#fcff42","#ffa62d","#ff36ff"],disableForReducedMotion:!1,scalar:1};function v(D,I){return I?I(D):D}function w(D){return D!=null}function k(D,I,A){return v(D&&w(D[I])?D[I]:g[I],A)}function S(D){return D<0?0:Math.floor(D)}function x(D,I){return Math.floor(Math.random()*(I-D))+D}function T(D){return parseInt(D,16)}function z(D){return D.map(R)}function R(D){var I=String(D).replace(/[^0-9a-f]/gi,"");return I.length<6&&(I=I[0]+I[0]+I[1]+I[1]+I[2]+I[2]),{r:T(I.substring(0,2)),g:T(I.substring(2,4)),b:T(I.substring(4,6))}}function $(D){var I=k(D,"origin",Object);return I.x=k(I,"x",Number),I.y=k(I,"y",Number),I}function B(D){D.width=document.documentElement.clientWidth,D.height=document.documentElement.clientHeight}function H(D){var I=D.getBoundingClientRect();D.width=I.width,D.height=I.height}function Y(D){var I=document.createElement("canvas");return I.style.position="fixed",I.style.top="0px",I.style.left="0px",I.style.pointerEvents="none",I.style.zIndex=D,I}function Z(D,I,A,W,te,N,F,U,Q){D.save(),D.translate(I,A),D.rotate(N),D.scale(W,te),D.arc(0,0,1,F,U,Q),D.restore()}function ne(D){var I=D.angle*(Math.PI/180),A=D.spread*(Math.PI/180);return{x:D.x,y:D.y,wobble:Math.random()*10,wobbleSpeed:Math.min(.11,Math.random()*.1+.05),velocity:D.startVelocity*.5+Math.random()*D.startVelocity,angle2D:-I+(.5*A-Math.random()*A),tiltAngle:(Math.random()*(.75-.25)+.25)*Math.PI,color:D.color,shape:D.shape,tick:0,totalTicks:D.ticks,decay:D.decay,drift:D.drift,random:Math.random()+2,tiltSin:0,tiltCos:0,wobbleX:0,wobbleY:0,gravity:D.gravity*3,ovalScalar:.6,scalar:D.scalar,flat:D.flat}}function oe(D,I){I.x+=Math.cos(I.angle2D)*I.velocity+I.drift,I.y+=Math.sin(I.angle2D)*I.velocity+I.gravity,I.velocity*=I.decay,I.flat?(I.wobble=0,I.wobbleX=I.x+10*I.scalar,I.wobbleY=I.y+10*I.scalar,I.tiltSin=0,I.tiltCos=0,I.random=1):(I.wobble+=I.wobbleSpeed,I.wobbleX=I.x+10*I.scalar*Math.cos(I.wobble),I.wobbleY=I.y+10*I.scalar*Math.sin(I.wobble),I.tiltAngle+=.1,I.tiltSin=Math.sin(I.tiltAngle),I.tiltCos=Math.cos(I.tiltAngle),I.random=Math.random()+2);var A=I.tick++/I.totalTicks,W=I.x+I.random*I.tiltCos,te=I.y+I.random*I.tiltSin,N=I.wobbleX+I.random*I.tiltCos,F=I.wobbleY+I.random*I.tiltSin;if(D.fillStyle="rgba("+I.color.r+", "+I.color.g+", "+I.color.b+", "+(1-A)+")",D.beginPath(),u&&I.shape.type==="path"&&typeof I.shape.path=="string"&&Array.isArray(I.shape.matrix))D.fill(Ne(I.shape.path,I.shape.matrix,I.x,I.y,Math.abs(N-W)*.1,Math.abs(F-te)*.1,Math.PI/10*I.wobble));else if(I.shape.type==="bitmap"){var U=Math.PI/10*I.wobble,Q=Math.abs(N-W)*.1,ue=Math.abs(F-te)*.1,fe=I.shape.bitmap.width*I.scalar,ce=I.shape.bitmap.height*I.scalar,pe=new DOMMatrix([Math.cos(U)*Q,Math.sin(U)*Q,-Math.sin(U)*ue,Math.cos(U)*ue,I.x,I.y]);pe.multiplySelf(new DOMMatrix(I.shape.matrix));var we=D.createPattern(I.shape.bitmap,"no-repeat");we.setTransform(pe),D.globalAlpha=1-A,D.fillStyle=we,D.fillRect(I.x-fe/2,I.y-ce/2,fe,ce),D.globalAlpha=1}else if(I.shape==="circle")D.ellipse?D.ellipse(I.x,I.y,Math.abs(N-W)*I.ovalScalar,Math.abs(F-te)*I.ovalScalar,Math.PI/10*I.wobble,0,2*Math.PI):Z(D,I.x,I.y,Math.abs(N-W)*I.ovalScalar,Math.abs(F-te)*I.ovalScalar,Math.PI/10*I.wobble,0,2*Math.PI);else if(I.shape==="star")for(var ge=Math.PI/2*3,Le=4*I.scalar,Pe=8*I.scalar,Ve=I.x,je=I.y,wt=5,Nt=Math.PI/wt;wt--;)Ve=I.x+Math.cos(ge)*Pe,je=I.y+Math.sin(ge)*Pe,D.lineTo(Ve,je),ge+=Nt,Ve=I.x+Math.cos(ge)*Le,je=I.y+Math.sin(ge)*Le,D.lineTo(Ve,je),ge+=Nt;else D.moveTo(Math.floor(I.x),Math.floor(I.y)),D.lineTo(Math.floor(I.wobbleX),Math.floor(te)),D.lineTo(Math.floor(N),Math.floor(F)),D.lineTo(Math.floor(W),Math.floor(I.wobbleY));return D.closePath(),D.fill(),I.tick<I.totalTicks}function de(D,I,A,W,te){var N=I.slice(),F=D.getContext("2d"),U,Q,ue=h(function(fe){function ce(){U=Q=null,F.clearRect(0,0,W.width,W.height),te(),fe()}function pe(){r&&!(W.width===o.width&&W.height===o.height)&&(W.width=D.width=o.width,W.height=D.height=o.height),!W.width&&!W.height&&(A(D),W.width=D.width,W.height=D.height),F.clearRect(0,0,W.width,W.height),N=N.filter(function(we){return oe(F,we)}),N.length?U=d.frame(pe):ce()}U=d.frame(pe),Q=ce});return{addFettis:function(fe){return N=N.concat(fe),ue},canvas:D,promise:ue,reset:function(){U&&d.cancel(U),Q&&Q()}}}function me(D,I){var A=!D,W=!!k(I||{},"resize"),te=!1,N=k(I,"disableForReducedMotion",Boolean),F=a&&!!k(I||{},"useWorker"),U=F?m():null,Q=A?B:H,ue=D&&U?!!D.__confetti_initialized:!1,fe=typeof matchMedia=="function"&&matchMedia("(prefers-reduced-motion)").matches,ce;function pe(ge,Le,Pe){for(var Ve=k(ge,"particleCount",S),je=k(ge,"angle",Number),wt=k(ge,"spread",Number),Nt=k(ge,"startVelocity",Number),ee=k(ge,"decay",Number),Jt=k(ge,"gravity",Number),Ct=k(ge,"drift",Number),Fn=k(ge,"colors",z),wr=k(ge,"ticks",Number),nr=k(ge,"shapes"),na=k(ge,"scalar"),ra=!!k(ge,"flat"),Vs=$(ge),hs=Ve,Gs=[],fs=D.width*Vs.x,ds=D.height*Vs.y;hs--;)Gs.push(ne({x:fs,y:ds,angle:je,spread:wt,startVelocity:Nt,color:Fn[hs%Fn.length],shape:nr[x(0,nr.length)],ticks:wr,decay:ee,gravity:Jt,drift:Ct,scalar:na,flat:ra}));return ce?ce.addFettis(Gs):(ce=de(D,Gs,Q,Le,Pe),ce.promise)}function we(ge){var Le=N||k(ge,"disableForReducedMotion",Boolean),Pe=k(ge,"zIndex",Number);if(Le&&fe)return h(function(Nt){Nt()});A&&ce?D=ce.canvas:A&&!D&&(D=Y(Pe),document.body.appendChild(D)),W&&!ue&&Q(D);var Ve={width:D.width,height:D.height};U&&!ue&&U.init(D),ue=!0,U&&(D.__confetti_initialized=!0);function je(){if(U){var Nt={getBoundingClientRect:function(){if(!A)return D.getBoundingClientRect()}};Q(Nt),U.postMessage({resize:{width:Nt.width,height:Nt.height}});return}Ve.width=Ve.height=null}function wt(){ce=null,W&&(te=!1,e.removeEventListener("resize",je)),A&&D&&(document.body.removeChild(D),D=null,ue=!1)}return W&&!te&&(te=!0,e.addEventListener("resize",je,!1)),U?U.fire(ge,Ve,wt):pe(ge,Ve,wt)}return we.reset=function(){U&&U.reset(),ce&&ce.reset()},we}var ve;function be(){return ve||(ve=me(null,{useWorker:!0,resize:!0})),ve}function Ne(D,I,A,W,te,N,F){var U=new Path2D(D),Q=new Path2D;Q.addPath(U,new DOMMatrix(I));var ue=new Path2D;return ue.addPath(Q,new DOMMatrix([Math.cos(F)*te,Math.sin(F)*te,-Math.sin(F)*N,Math.cos(F)*N,A,W])),ue}function Ie(D){if(!u)throw new Error("path confetti are not supported in this browser");var I,A;typeof D=="string"?I=D:(I=D.path,A=D.matrix);var W=new Path2D(I),te=document.createElement("canvas"),N=te.getContext("2d");if(!A){for(var F=1e3,U=F,Q=F,ue=0,fe=0,ce,pe,we=0;we<F;we+=2)for(var ge=0;ge<F;ge+=2)N.isPointInPath(W,we,ge,"nonzero")&&(U=Math.min(U,we),Q=Math.min(Q,ge),ue=Math.max(ue,we),fe=Math.max(fe,ge));ce=ue-U,pe=fe-Q;var Le=10,Pe=Math.min(Le/ce,Le/pe);A=[Pe,0,0,Pe,-Math.round(ce/2+U)*Pe,-Math.round(pe/2+Q)*Pe]}return{type:"path",path:I,matrix:A}}function Ee(D){var I,A=1,W="#000000",te='"Twemoji Mozilla", "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji", "EmojiOne Color", "Android Emoji", "system emoji", sans-serif';typeof D=="string"?I=D:(I=D.text,A="scalar"in D?D.scalar:A,te="fontFamily"in D?D.fontFamily:te,W="color"in D?D.color:W);var N=10*A,F=""+N+"px "+te,U=new OffscreenCanvas(N,N),Q=U.getContext("2d");Q.font=F;var ue=Q.measureText(I),fe=Math.floor(ue.width),ce=Math.floor(ue.fontBoundingBoxAscent+ue.fontBoundingBoxDescent);U=new OffscreenCanvas(fe,ce),Q=U.getContext("2d"),Q.font=F,Q.fillStyle=W,Q.fillText(I,0,N);var pe=1/A;return{type:"bitmap",bitmap:U.transferToImageBitmap(),matrix:[pe,0,0,pe,-fe*pe/2,-ce*pe/2]}}t.exports=function(){return be().apply(this,arguments)},t.exports.reset=function(){be().reset()},t.exports.create=me,t.exports.shapeFromPath=Ie,t.exports.shapeFromText=Ee})((function(){return typeof window<"u"?window:typeof self<"u"?self:this||{}})(),ip,!1);const dw=ip.exports;ip.exports.create;const V_=()=>{let n=6e4,e=Date.now()+n,t={startVelocity:50,spread:360,ticks:1e3,zIndex:0};function r(o,a){return Math.random()*(a-o)+o}(function(){var a=setInterval(function(){var u=e-Date.now();if(u<=0)return clearInterval(a);var c=50*(u/n);dw({...t,particleCount:c,origin:{x:r(.1,.3),y:Math.random()-.2}}),dw({...t,particleCount:c,origin:{x:r(.7,.9),y:Math.random()-.2}})},250)})()};function G_(){const[n,e]=vi.useState(Hk(5,5)),[t,r]=vi.useState({maze:n,message:"",messageValue:0}),[o,a]=vi.useState(!1),[u,c]=vi.useState(0);async function h(){const m="https://teachablemachine.withgoogle.com/models/7_pWxhluP/",g=m+"model.json",v=m+"metadata.json",w=$_("BROWSER_FFT",void 0,g,v);return await w.ensureModelLoaded(),w}async function d(){const m=await h();let g;c(()=>1);const v=w=>{c(()=>2),m.stopListening();const k=W_(n,"a",w);if(e(()=>k.maze),r(()=>k),k.messageValue===0){c(()=>0);return}if(k.messageValue===2){a(()=>!0),V_();return}else setTimeout(()=>{r(S=>({...S,message:"",messageValue:0})),c(()=>0)},3e3)};m.listen(w=>{const k=w.scores;switch(g=L_(k),g){case 1:v("down");break;case 2:v("left");break;case 3:v("right");break;case 4:v("up");break}},{includeSpectrogram:!0,probabilityThreshold:.75,invokeCallbackOnNoiseAndUnknown:!0,overlapFactor:.5})}return vi.useEffect(()=>{h()},[]),Xe.jsxs(Xe.Fragment,{children:[Xe.jsx("div",{className:"bg-gradient-to-b from-sky-100 to-sky-300 min-h-screen font-silkscreen",children:Xe.jsxs("div",{className:"p-8",children:[Xe.jsx("h1",{className:"text-xl xsm:text-2xl sm:text-3xl lg:text-5xl mb-12 tablet:mb-24",children:"Speech Recognition Maze"}),Xe.jsxs("div",{className:"grid tablet:grid-cols-2 justify-items-center gap-y-6 xsm:gap-y-10 tablet:gap-10 lg:gap-12 xlg:gap-y-32",children:[Xe.jsx(qk,{maze:n}),Xe.jsx(Kk,{messageObj:t})]}),!o&&Xe.jsx("button",{className:`mt-12 lg:mt-20 tablet:col-span-2 material-symbols-outlined rounded-full p-4 border-2 text-white
                        ${u===1&&"animate-quickPing disabled cursor-none"}
                        `,onClick:d,children:"mic"})]})}),Xe.jsx("footer",{children:Xe.jsx("p",{className:"text-sm",children:" 2025 Paul McJannet. All rights reserved."})})]})}typeof window.promisify>"u"&&(window.promisify=n=>(...e)=>new Promise((t,r)=>{n(...e,(o,a)=>{o?r(o):t(a)})}));nE.createRoot(document.getElementById("root")).render(Xe.jsx(Jx.StrictMode,{children:Xe.jsx(G_,{})}));
